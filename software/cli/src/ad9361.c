#include "axi_ad9361.h"
#include "ad9361_util.h"
#include "ad9361.h"

#define NO_GAIN_TABLE        ((uint32_t)-1)

#define SYNTH_LUT_SIZE    53

static const struct ad9361_synth_lut SynthLUT_FDD[LUT_FTDD_ENT][SYNTH_LUT_SIZE] =
{
    {
        {12605, 13, 1, 4, 2, 15, 12, 7, 14, 6, 14, 5, 15},  /* 40 MHz */
        {12245, 13, 1, 4, 2, 15, 12, 7, 14, 6, 14, 5, 15},
        {11906, 13, 1, 4, 2, 15, 12, 7, 15, 6, 14, 5, 15},
        {11588, 13, 1, 4, 2, 15, 12, 8, 15, 6, 14, 5, 15},
        {11288, 13, 1, 4, 2, 15, 12, 8, 15, 6, 14, 5, 15},
        {11007, 13, 1, 4, 2, 15, 12, 9, 15, 6, 14, 5, 15},
        {10742, 13, 1, 4, 2, 15, 12, 9, 15, 6, 14, 5, 15},
        {10492, 13, 1, 6, 2, 15, 12, 10, 15, 6, 14, 5, 15},
        {10258, 13, 1, 6, 2, 15, 12, 10, 15, 6, 14, 5, 15},
        {10036, 13, 1, 6, 2, 15, 12, 11, 15, 6, 14, 5, 15},
        {9827, 13, 1, 6, 2, 14, 12, 11, 15, 6, 14, 5, 15},
        {9631, 13, 1, 6, 2, 13, 12, 12, 15, 6, 14, 5, 15},
        {9445, 13, 1, 6, 2, 12, 12, 12, 15, 6, 14, 5, 15},
        {9269, 13, 1, 6, 2, 12, 12, 13, 15, 6, 14, 5, 15},
        {9103, 13, 1, 6, 2, 12, 12, 13, 15, 6, 14, 5, 15},
        {8946, 13, 1, 6, 2, 12, 12, 14, 15, 6, 14, 5, 15},
        {8797, 12, 1, 7, 2, 12, 12, 13, 15, 6, 14, 5, 15},
        {8655, 12, 1, 7, 2, 12, 12, 14, 15, 6, 14, 5, 15},
        {8520, 12, 1, 7, 2, 12, 12, 14, 15, 6, 14, 5, 15},
        {8392, 12, 1, 7, 2, 12, 12, 15, 15, 6, 14, 5, 15},
        {8269, 12, 1, 7, 2, 12, 12, 15, 15, 6, 14, 5, 15},
        {8153, 12, 1, 7, 2, 12, 12, 16, 15, 6, 14, 5, 15},
        {8041, 12, 1, 7, 2, 13, 12, 16, 15, 6, 14, 5, 15},
        {7934, 11, 1, 7, 2, 12, 12, 16, 15, 6, 14, 5, 15},
        {7831, 11, 1, 7, 2, 12, 12, 16, 15, 6, 14, 5, 15},
        {7733, 10, 1, 7, 3, 13, 12, 16, 15, 6, 14, 5, 15},
        {7638, 10, 1, 7, 2, 12, 12, 16, 15, 6, 14, 5, 15},
        {7547, 10, 1, 7, 2, 12, 12, 17, 15, 6, 14, 5, 15},
        {7459, 10, 1, 7, 2, 12, 12, 17, 15, 6, 14, 5, 15},
        {7374, 10, 2, 7, 3, 14, 13, 14, 15, 6, 14, 5, 15},
        {7291, 10, 2, 7, 3, 14, 13, 14, 15, 6, 14, 5, 15},
        {7212, 10, 2, 7, 3, 14, 13, 14, 15, 6, 14, 5, 15},
        {7135, 10, 2, 7, 3, 14, 13, 15, 15, 7, 14, 5, 15},
        {7061, 10, 2, 7, 3, 14, 13, 15, 15, 6, 14, 5, 15},
        {6988, 10, 1, 7, 3, 12, 14, 20, 15, 6, 14, 5, 15},
        {6918, 9, 2, 7, 3, 14, 13, 15, 15, 6, 14, 5, 15},
        {6850, 9, 2, 7, 3, 14, 13, 15, 15, 6, 14, 5, 15},
        {6784, 9, 2, 7, 2, 13, 13, 15, 15, 6, 14, 5, 15},
        {6720, 9, 2, 7, 2, 13, 13, 16, 15, 6, 14, 5, 15},
        {6658, 8, 2, 7, 3, 14, 13, 15, 15, 6, 14, 5, 15},
        {6597, 8, 2, 7, 2, 13, 13, 15, 15, 6, 14, 5, 15},
        {6539, 8, 2, 7, 2, 13, 13, 15, 15, 6, 14, 5, 15},
        {6482, 8, 2, 7, 2, 13, 13, 16, 15, 6, 14, 5, 15},
        {6427, 7, 2, 7, 3, 14, 13, 15, 15, 6, 14, 5, 15},
        {6373, 7, 2, 7, 3, 15, 13, 15, 15, 6, 14, 5, 15},
        {6321, 7, 2, 7, 3, 15, 13, 15, 15, 6, 14, 5, 15},
        {6270, 7, 2, 7, 3, 15, 13, 16, 15, 6, 14, 5, 15},
        {6222, 7, 2, 7, 3, 15, 13, 16, 15, 6, 14, 5, 15},
        {6174, 6, 2, 7, 3, 15, 13, 15, 15, 6, 14, 5, 15},
        {6128, 6, 2, 7, 3, 15, 13, 15, 15, 6, 14, 5, 15},
        {6083, 6, 2, 7, 3, 15, 13, 16, 15, 6, 14, 5, 15},
        {6040, 6, 2, 7, 3, 15, 13, 16, 15, 6, 14, 5, 15},
        {5997, 6, 2, 7, 3, 15, 13, 16, 15, 6, 14, 5, 15},
    }, {
        {12605, 13, 1, 4, 2, 15, 12, 13, 15, 12, 12, 5, 14},  /* 60 MHz */
        {12245, 13, 1, 4, 2, 15, 12, 13, 15, 12, 12, 5, 14},
        {11906, 13, 1, 4, 2, 15, 12, 13, 15, 13, 12, 5, 13},
        {11588, 13, 1, 4, 2, 15, 12, 14, 15, 13, 12, 5, 13},
        {11288, 13, 1, 5, 2, 15, 12, 15, 15, 13, 12, 5, 13},
        {11007, 13, 1, 5, 2, 15, 12, 16, 15, 13, 12, 5, 13},
        {10742, 13, 1, 5, 2, 15, 12, 16, 15, 12, 12, 5, 14},
        {10492, 13, 1, 6, 2, 15, 12, 17, 15, 12, 12, 5, 14},
        {10258, 13, 1, 6, 2, 15, 12, 18, 15, 13, 12, 5, 13},
        {10036, 13, 1, 6, 2, 15, 12, 19, 15, 13, 12, 5, 13},
        {9827, 13, 1, 6, 2, 14, 12, 20, 15, 13, 12, 5, 13},
        {9631, 13, 1, 6, 2, 13, 12, 21, 15, 13, 12, 5, 13},
        {9445, 13, 1, 6, 2, 12, 12, 22, 15, 13, 12, 5, 13},
        {9269, 13, 1, 6, 2, 12, 12, 22, 15, 12, 12, 5, 14},
        {9103, 13, 1, 6, 2, 12, 12, 23, 15, 13, 12, 5, 13},
        {8946, 13, 1, 6, 2, 12, 12, 24, 15, 13, 12, 5, 13},
        {8797, 12, 1, 7, 2, 12, 12, 24, 15, 13, 12, 5, 13},
        {8655, 12, 1, 7, 2, 12, 12, 25, 15, 13, 12, 5, 13},
        {8520, 12, 1, 7, 2, 12, 12, 25, 15, 13, 12, 5, 13},
        {8392, 12, 1, 7, 2, 12, 12, 26, 15, 13, 12, 5, 13},
        {8269, 12, 1, 7, 2, 12, 12, 27, 15, 13, 12, 5, 13},
        {8153, 12, 1, 7, 2, 12, 12, 28, 15, 13, 12, 5, 13},
        {8041, 12, 1, 7, 2, 13, 12, 29, 15, 13, 12, 5, 13},
        {7934, 11, 1, 7, 2, 12, 12, 28, 15, 13, 12, 5, 13},
        {7831, 11, 1, 7, 2, 12, 12, 29, 15, 13, 12, 5, 13},
        {7733, 10, 1, 7, 3, 13, 12, 28, 15, 13, 12, 5, 13},
        {7638, 10, 1, 7, 2, 12, 12, 29, 15, 13, 12, 5, 13},
        {7547, 10, 1, 7, 2, 12, 12, 29, 15, 13, 12, 5, 13},
        {7459, 10, 1, 7, 2, 12, 12, 30, 15, 13, 12, 5, 13},
        {7374, 10, 2, 7, 3, 14, 13, 24, 15, 13, 12, 5, 13},
        {7291, 10, 2, 7, 3, 14, 13, 25, 15, 13, 12, 5, 13},
        {7212, 10, 2, 7, 3, 14, 13, 25, 15, 13, 12, 5, 13},
        {7135, 10, 2, 7, 3, 14, 13, 26, 15, 13, 12, 5, 13},
        {7061, 10, 2, 7, 3, 14, 13, 26, 15, 13, 12, 5, 13},
        {6988, 10, 1, 7, 3, 12, 14, 35, 15, 13, 12, 5, 13},
        {6918, 9, 1, 7, 3, 12, 14, 33, 15, 13, 12, 5, 13},
        {6850, 9, 1, 7, 3, 12, 14, 34, 15, 13, 12, 5, 13},
        {6784, 9, 1, 7, 2, 11, 14, 35, 15, 13, 12, 5, 13},
        {6720, 9, 1, 7, 2, 11, 14, 35, 15, 13, 12, 5, 13},
        {6658, 8, 2, 7, 3, 15, 13, 26, 15, 13, 12, 5, 13},
        {6597, 8, 2, 7, 2, 15, 13, 27, 15, 13, 12, 5, 13},
        {6539, 8, 2, 7, 2, 15, 13, 27, 15, 13, 12, 5, 13},
        {6482, 8, 2, 7, 2, 15, 13, 28, 15, 13, 12, 5, 13},
        {6427, 7, 2, 7, 3, 14, 13, 27, 15, 13, 12, 5, 13},
        {6373, 7, 2, 7, 3, 15, 13, 27, 15, 13, 12, 5, 13},
        {6321, 7, 2, 7, 3, 15, 13, 27, 15, 13, 12, 5, 13},
        {6270, 7, 2, 7, 3, 15, 13, 28, 15, 13, 12, 5, 13},
        {6222, 7, 2, 7, 3, 15, 13, 28, 15, 13, 12, 5, 13},
        {6174, 6, 2, 7, 3, 15, 13, 27, 15, 13, 12, 5, 13},
        {6128, 6, 2, 7, 3, 15, 13, 27, 15, 13, 12, 5, 13},
        {6083, 6, 2, 7, 3, 15, 13, 28, 15, 13, 12, 5, 13},
        {6040, 6, 2, 7, 3, 15, 13, 28, 15, 13, 12, 5, 13},
        {5997, 6, 2, 7, 3, 15, 13, 29, 15, 13, 12, 5, 13},
    }, {
        {12605, 13, 1, 4, 2, 15, 12, 7, 15, 6, 13, 5, 14},  /* 80 MHz */
        {12245, 13, 1, 4, 2, 15, 12, 7, 15, 6, 13, 5, 14},
        {11906, 13, 1, 4, 2, 15, 12, 7, 15, 6, 13, 5, 14},
        {11588, 13, 1, 4, 2, 15, 12, 7, 14, 6, 14, 4, 14},
        {11288, 13, 1, 4, 2, 15, 12, 8, 15, 6, 13, 5, 14},
        {11007, 13, 1, 4, 2, 15, 12, 8, 14, 6, 13, 5, 14},
        {10742, 13, 1, 4, 2, 15, 12, 9, 15, 6, 13, 5, 14},
        {10492, 13, 1, 6, 2, 15, 12, 9, 14, 6, 13, 5, 14},
        {10258, 13, 1, 6, 2, 15, 12, 10, 15, 6, 13, 5, 14},
        {10036, 13, 1, 6, 2, 15, 12, 10, 15, 6, 13, 5, 14},
        {9827, 13, 1, 6, 2, 14, 12, 11, 15, 6, 13, 5, 14},
        {9631, 13, 1, 6, 2, 13, 12, 11, 15, 6, 13, 5, 14},
        {9445, 13, 1, 6, 2, 12, 12, 12, 15, 6, 13, 5, 14},
        {9269, 13, 1, 6, 2, 12, 12, 12, 15, 6, 13, 5, 14},
        {9103, 13, 1, 6, 2, 12, 12, 13, 15, 6, 13, 5, 14},
        {8946, 13, 1, 6, 2, 12, 12, 13, 15, 6, 13, 5, 14},
        {8797, 12, 1, 7, 2, 12, 12, 13, 15, 6, 13, 5, 14},
        {8655, 12, 1, 7, 2, 12, 12, 14, 15, 6, 13, 5, 14},
        {8520, 12, 1, 7, 2, 12, 12, 14, 15, 6, 13, 5, 14},
        {8392, 12, 1, 7, 2, 12, 12, 15, 15, 7, 13, 5, 14},
        {8269, 12, 1, 7, 2, 12, 12, 15, 15, 6, 13, 5, 14},
        {8153, 12, 1, 7, 2, 12, 12, 15, 15, 6, 13, 5, 14},
        {8041, 12, 1, 7, 2, 13, 12, 16, 15, 6, 13, 5, 14},
        {7934, 11, 1, 7, 2, 12, 12, 15, 15, 6, 13, 5, 14},
        {7831, 11, 1, 7, 2, 12, 12, 16, 15, 6, 13, 5, 14},
        {7733, 10, 1, 7, 3, 13, 12, 15, 15, 6, 13, 5, 14},
        {7638, 10, 1, 7, 2, 12, 12, 16, 15, 6, 13, 5, 14},
        {7547, 10, 1, 7, 2, 12, 12, 16, 15, 6, 13, 5, 14},
        {7459, 10, 1, 7, 2, 12, 12, 17, 15, 6, 13, 5, 14},
        {7374, 10, 2, 7, 3, 14, 13, 13, 15, 6, 13, 5, 14},
        {7291, 10, 2, 7, 3, 14, 13, 14, 15, 6, 13, 5, 14},
        {7212, 10, 2, 7, 3, 14, 13, 14, 15, 6, 13, 5, 14},
        {7135, 10, 2, 7, 3, 14, 13, 14, 15, 6, 13, 5, 14},
        {7061, 10, 2, 7, 3, 14, 13, 15, 15, 6, 13, 5, 14},
        {6988, 10, 1, 7, 3, 12, 14, 19, 15, 6, 13, 5, 14},
        {6918, 9, 2, 7, 3, 14, 13, 14, 15, 6, 13, 5, 14},
        {6850, 9, 2, 7, 3, 14, 13, 15, 15, 6, 13, 5, 14},
        {6784, 9, 2, 7, 2, 13, 13, 15, 15, 6, 13, 5, 14},
        {6720, 9, 2, 7, 2, 13, 13, 15, 15, 6, 13, 5, 14},
        {6658, 8, 2, 7, 3, 14, 13, 15, 15, 6, 13, 5, 14},
        {6597, 8, 2, 7, 2, 13, 13, 15, 15, 6, 13, 5, 14},
        {6539, 8, 2, 7, 2, 13, 13, 15, 15, 6, 13, 5, 14},
        {6482, 8, 2, 7, 2, 13, 13, 15, 15, 6, 13, 5, 14},
        {6427, 7, 2, 7, 3, 14, 13, 15, 15, 6, 13, 5, 14},
        {6373, 7, 2, 7, 3, 15, 13, 15, 15, 6, 13, 5, 14},
        {6321, 7, 2, 7, 3, 15, 13, 15, 15, 6, 13, 5, 14},
        {6270, 7, 2, 7, 3, 15, 13, 15, 15, 6, 13, 5, 14},
        {6222, 7, 2, 7, 3, 15, 13, 16, 15, 6, 13, 5, 14},
        {6174, 6, 2, 7, 3, 15, 13, 15, 15, 6, 13, 5, 14},
        {6128, 6, 2, 7, 3, 15, 13, 15, 15, 6, 13, 5, 14},
        {6083, 6, 2, 7, 3, 15, 13, 15, 15, 6, 13, 5, 14},
        {6040, 6, 2, 7, 3, 15, 13, 16, 15, 6, 13, 5, 14},
        {5997, 6, 2, 7, 3, 15, 13, 16, 15, 6, 13, 5, 14},
    }
};

static const struct ad9361_synth_lut SynthLUT_TDD[LUT_FTDD_ENT][SYNTH_LUT_SIZE] =
{
    {
        {12605, 13, 1, 4, 2, 15, 12, 27, 12, 15, 12, 4, 13},  /* 40 MHz */
        {12245, 13, 1, 4, 2, 15, 12, 27, 12, 15, 12, 4, 13},
        {11906, 13, 1, 4, 2, 15, 12, 26, 11, 15, 12, 4, 13},
        {11588, 13, 1, 4, 2, 15, 12, 28, 12, 15, 12, 4, 13},
        {11288, 13, 1, 4, 2, 15, 12, 30, 12, 15, 12, 4, 13},
        {11007, 13, 1, 4, 2, 15, 12, 32, 12, 15, 12, 4, 13},
        {10742, 13, 1, 4, 2, 15, 12, 33, 12, 15, 12, 4, 13},
        {10492, 13, 1, 6, 2, 15, 12, 35, 12, 15, 12, 4, 13},
        {10258, 13, 1, 6, 2, 15, 12, 37, 12, 15, 12, 4, 13},
        {10036, 13, 1, 6, 2, 15, 12, 38, 12, 15, 12, 4, 13},
        {9827, 13, 1, 6, 2, 14, 12, 40, 12, 15, 12, 4, 13},
        {9631, 13, 1, 6, 2, 13, 12, 42, 12, 15, 12, 4, 13},
        {9445, 13, 1, 6, 2, 12, 12, 44, 12, 15, 12, 4, 13},
        {9269, 13, 1, 6, 2, 12, 12, 45, 12, 15, 12, 4, 13},
        {9103, 13, 1, 6, 2, 12, 12, 47, 12, 15, 12, 4, 13},
        {8946, 13, 1, 6, 2, 12, 12, 49, 12, 15, 12, 4, 13},
        {8797, 12, 1, 7, 2, 12, 12, 48, 12, 15, 12, 4, 13},
        {8655, 12, 1, 7, 2, 12, 12, 50, 12, 15, 12, 4, 13},
        {8520, 12, 1, 7, 2, 12, 12, 51, 12, 15, 12, 4, 13},
        {8392, 12, 1, 7, 2, 12, 12, 53, 12, 15, 12, 4, 13},
        {8269, 12, 1, 7, 2, 12, 12, 55, 12, 15, 12, 4, 13},
        {8153, 12, 1, 7, 2, 12, 12, 56, 12, 15, 12, 4, 13},
        {8041, 12, 1, 7, 2, 13, 12, 58, 12, 15, 12, 4, 13},
        {7934, 11, 1, 7, 2, 12, 12, 57, 12, 15, 12, 4, 13},
        {7831, 11, 1, 7, 2, 12, 12, 58, 12, 15, 12, 4, 13},
        {7733, 10, 1, 7, 3, 13, 12, 56, 12, 15, 12, 4, 13},
        {7638, 10, 1, 7, 2, 12, 12, 58, 12, 15, 12, 4, 13},
        {7547, 10, 1, 7, 2, 12, 12, 59, 12, 15, 12, 4, 13},
        {7459, 10, 1, 7, 2, 12, 12, 61, 12, 15, 12, 4, 13},
        {7374, 10, 2, 7, 3, 14, 13, 49, 12, 15, 12, 4, 13},
        {7291, 10, 2, 7, 3, 14, 13, 50, 12, 15, 12, 4, 13},
        {7212, 10, 2, 7, 3, 14, 13, 51, 12, 15, 12, 4, 13},
        {7135, 10, 2, 7, 3, 14, 13, 52, 12, 15, 12, 4, 13},
        {7061, 10, 2, 7, 3, 14, 13, 53, 12, 15, 12, 4, 13},
        {6988, 10, 1, 7, 3, 12, 14, 63, 11, 14, 12, 3, 13},
        {6918, 9, 2, 7, 3, 14, 13, 52, 12, 15, 12, 4, 13},
        {6850, 9, 2, 7, 3, 14, 13, 53, 12, 15, 12, 4, 13},
        {6784, 9, 2, 7, 2, 13, 13, 54, 12, 15, 12, 4, 13},
        {6720, 9, 2, 7, 2, 13, 13, 56, 12, 15, 12, 4, 13},
        {6658, 8, 2, 7, 3, 14, 13, 53, 12, 15, 12, 4, 13},
        {6597, 8, 2, 7, 2, 13, 13, 54, 12, 15, 12, 4, 13},
        {6539, 8, 2, 7, 2, 13, 13, 55, 12, 15, 12, 4, 13},
        {6482, 8, 2, 7, 2, 13, 13, 56, 12, 15, 12, 4, 13},
        {6427, 7, 2, 7, 3, 14, 13, 54, 12, 15, 12, 4, 13},
        {6373, 7, 2, 7, 3, 15, 13, 54, 12, 15, 12, 4, 13},
        {6321, 7, 2, 7, 3, 15, 13, 55, 12, 15, 12, 4, 13},
        {6270, 7, 2, 7, 3, 15, 13, 56, 12, 15, 12, 4, 13},
        {6222, 7, 2, 7, 3, 15, 13, 57, 12, 15, 12, 4, 13},
        {6174, 6, 2, 7, 3, 15, 13, 54, 12, 15, 12, 4, 13},
        {6128, 6, 2, 7, 3, 15, 13, 55, 12, 15, 12, 4, 13},
        {6083, 6, 2, 7, 3, 15, 13, 56, 12, 15, 12, 4, 13},
        {6040, 6, 2, 7, 3, 15, 13, 57, 12, 15, 12, 4, 13},
        {5997, 6, 2, 7, 3, 15, 13, 58, 12, 15, 12, 4, 13},
    }, {
        {12605, 13, 1, 4, 2, 15, 12, 26, 11, 15, 11, 4, 13},  /* 60 MHz */
        {12245, 13, 1, 4, 2, 15, 12, 26, 11, 15, 11, 4, 13},
        {11906, 13, 1, 4, 2, 15, 12, 26, 12, 15, 11, 4, 12},
        {11588, 13, 1, 4, 2, 15, 12, 30, 12, 15, 11, 4, 12},
        {11288, 13, 1, 4, 2, 15, 12, 32, 12, 15, 10, 4, 12},
        {11007, 13, 1, 4, 2, 15, 12, 31, 12, 15, 11, 4, 12},
        {10742, 13, 1, 4, 2, 15, 12, 33, 12, 15, 10, 4, 12},
        {10492, 13, 1, 6, 2, 15, 12, 37, 12, 15, 10, 4, 12},
        {10258, 13, 1, 6, 2, 15, 12, 38, 12, 15, 11, 4, 13},
        {10036, 13, 1, 6, 2, 15, 12, 38, 12, 15, 10, 4, 12},
        {9827, 13, 1, 6, 2, 14, 12, 42, 12, 15, 11, 4, 12},
        {9631, 13, 1, 6, 2, 13, 12, 41, 12, 15, 11, 4, 12},
        {9445, 13, 1, 6, 2, 12, 12, 45, 12, 15, 11, 4, 12},
        {9269, 13, 1, 6, 2, 12, 12, 47, 12, 15, 11, 4, 12},
        {9103, 13, 1, 6, 2, 12, 12, 46, 12, 15, 11, 4, 12},
        {8946, 13, 1, 6, 2, 12, 12, 48, 12, 15, 10, 4, 12},
        {8797, 12, 1, 7, 2, 12, 12, 49, 12, 15, 11, 4, 13},
        {8655, 12, 1, 7, 2, 12, 12, 51, 12, 15, 11, 4, 12},
        {8520, 12, 1, 7, 2, 12, 12, 50, 12, 15, 11, 4, 12},
        {8392, 12, 1, 7, 2, 12, 12, 52, 12, 15, 10, 4, 12},
        {8269, 12, 1, 7, 2, 12, 12, 56, 12, 15, 10, 4, 12},
        {8153, 12, 1, 7, 2, 12, 12, 55, 12, 15, 11, 4, 12},
        {8041, 12, 1, 7, 2, 13, 12, 57, 12, 15, 10, 4, 12},
        {7934, 11, 1, 7, 2, 12, 12, 55, 12, 15, 11, 4, 12},
        {7831, 11, 1, 7, 2, 12, 12, 57, 12, 15, 10, 4, 12},
        {7733, 10, 1, 7, 3, 13, 12, 55, 12, 15, 11, 4, 12},
        {7638, 10, 1, 7, 2, 12, 12, 59, 12, 15, 10, 4, 12},
        {7547, 10, 1, 7, 2, 12, 12, 60, 12, 15, 11, 4, 12},
        {7459, 10, 1, 7, 2, 12, 12, 48, 12, 15, 11, 4, 12},
        {7374, 10, 2, 7, 3, 14, 13, 47, 12, 15, 11, 4, 13},
        {7291, 10, 2, 7, 3, 14, 13, 49, 12, 15, 10, 4, 12},
        {7212, 10, 2, 7, 3, 14, 13, 50, 12, 15, 10, 4, 12},
        {7135, 10, 2, 7, 3, 14, 13, 52, 12, 15, 11, 4, 13},
        {7061, 10, 2, 7, 3, 14, 13, 52, 12, 15, 11, 4, 12},
        {6988, 10, 1, 7, 3, 12, 14, 63, 11, 15, 11, 4, 13},
        {6918, 9, 1, 7, 3, 12, 14, 63, 11, 15, 11, 4, 13},
        {6850, 9, 1, 7, 3, 12, 14, 63, 11, 15, 11, 4, 13},
        {6784, 9, 1, 7, 2, 11, 14, 63, 11, 15, 11, 4, 13},
        {6720, 9, 1, 7, 2, 11, 14, 63, 11, 14, 11, 3, 13},
        {6658, 8, 1, 7, 3, 12, 14, 63, 11, 15, 11, 4, 13},
        {6597, 8, 1, 7, 2, 11, 14, 63, 11, 14, 11, 3, 13},
        {6539, 8, 1, 7, 2, 11, 14, 63, 10, 14, 11, 3, 13},
        {6482, 8, 1, 7, 2, 11, 14, 63, 10, 14, 11, 3, 13},
        {6427, 7, 2, 7, 3, 14, 13, 54, 12, 15, 10, 4, 12},
        {6373, 7, 2, 7, 3, 15, 13, 53, 12, 15, 11, 4, 12},
        {6321, 7, 2, 7, 3, 15, 13, 54, 12, 15, 11, 4, 12},
        {6270, 7, 2, 7, 3, 15, 13, 55, 12, 15, 11, 4, 12},
        {6222, 7, 2, 7, 3, 15, 13, 56, 12, 15, 11, 4, 12},
        {6174, 6, 2, 7, 3, 15, 13, 53, 12, 15, 11, 4, 12},
        {6128, 6, 2, 7, 3, 15, 13, 55, 12, 15, 11, 4, 12},
        {6083, 6, 2, 7, 3, 15, 13, 55, 12, 15, 10, 4, 12},
        {6040, 6, 2, 7, 3, 15, 13, 56, 12, 15, 10, 4, 12},
        {5997, 6, 2, 7, 3, 15, 13, 57, 12, 15, 10, 4, 12},
    }, {
        {12605, 13, 1, 4, 2, 15, 12, 21, 12, 15, 11, 4, 13},  /* 80 MHz */
        {12245, 13, 1, 4, 2, 15, 12, 21, 12, 15, 11, 4, 13},
        {11906, 13, 1, 4, 2, 15, 12, 20, 11, 15, 11, 4, 13},
        {11588, 13, 1, 4, 2, 15, 12, 22, 12, 15, 11, 4, 12},
        {11288, 13, 1, 5, 2, 15, 12, 23, 12, 15, 11, 4, 13},
        {11007, 13, 1, 5, 2, 15, 12, 25, 12, 15, 10, 4, 12},
        {10742, 13, 1, 5, 2, 15, 12, 26, 12, 15, 11, 4, 13},
        {10492, 13, 1, 6, 2, 15, 12, 27, 11, 15, 11, 4, 13},
        {10258, 13, 1, 6, 2, 15, 12, 29, 12, 15, 10, 4, 12},
        {10036, 13, 1, 6, 2, 15, 12, 30, 12, 15, 11, 4, 12},
        {9827, 13, 1, 6, 2, 14, 12, 31, 12, 15, 11, 4, 13},
        {9631, 13, 1, 6, 2, 13, 12, 33, 12, 15, 10, 4, 12},
        {9445, 13, 1, 6, 2, 12, 12, 34, 12, 15, 11, 4, 12},
        {9269, 13, 1, 6, 2, 12, 12, 35, 12, 15, 11, 4, 13},
        {9103, 13, 1, 6, 2, 12, 12, 37, 12, 15, 10, 4, 12},
        {8946, 13, 1, 6, 2, 12, 12, 38, 12, 15, 11, 4, 12},
        {8797, 12, 1, 7, 2, 12, 12, 37, 12, 15, 11, 4, 13},
        {8655, 12, 1, 7, 2, 12, 12, 39, 12, 15, 11, 4, 12},
        {8520, 12, 1, 7, 2, 12, 12, 40, 12, 15, 11, 4, 12},
        {8392, 12, 1, 7, 2, 12, 12, 41, 12, 15, 11, 4, 13},
        {8269, 12, 1, 7, 2, 12, 12, 43, 12, 15, 10, 4, 12},
        {8153, 12, 1, 7, 2, 12, 12, 44, 12, 15, 11, 4, 12},
        {8041, 12, 1, 7, 2, 13, 12, 45, 12, 15, 11, 4, 12},
        {7934, 11, 1, 7, 2, 12, 12, 44, 12, 15, 11, 4, 12},
        {7831, 11, 1, 7, 2, 12, 12, 45, 12, 15, 11, 4, 13},
        {7733, 10, 1, 7, 3, 13, 12, 44, 12, 15, 11, 4, 12},
        {7638, 10, 1, 7, 2, 12, 12, 45, 12, 15, 11, 4, 12},
        {7547, 10, 1, 7, 2, 12, 12, 46, 12, 15, 11, 4, 12},
        {7459, 10, 1, 7, 2, 12, 12, 47, 12, 15, 11, 4, 13},
        {7374, 10, 2, 7, 3, 14, 13, 38, 12, 15, 11, 4, 12},
        {7291, 10, 2, 7, 3, 14, 13, 39, 12, 15, 10, 4, 12},
        {7212, 10, 2, 7, 3, 14, 13, 40, 12, 15, 10, 4, 12},
        {7135, 10, 2, 7, 3, 14, 13, 41, 12, 15, 10, 4, 12},
        {7061, 10, 2, 7, 3, 14, 13, 41, 12, 15, 11, 4, 13},
        {6988, 10, 1, 7, 3, 12, 14, 54, 12, 15, 11, 4, 12},
        {6918, 9, 2, 7, 3, 14, 13, 41, 12, 15, 10, 4, 12},
        {6850, 9, 2, 7, 3, 14, 13, 42, 12, 15, 10, 4, 12},
        {6784, 9, 2, 7, 2, 13, 13, 42, 12, 15, 11, 4, 13},
        {6720, 9, 2, 7, 2, 13, 13, 43, 12, 15, 11, 4, 13},
        {6658, 8, 2, 7, 3, 14, 13, 41, 12, 15, 11, 4, 13},
        {6597, 8, 2, 7, 2, 13, 13, 42, 12, 15, 11, 4, 12},
        {6539, 8, 2, 7, 2, 13, 13, 43, 12, 15, 11, 4, 12},
        {6482, 8, 2, 7, 2, 13, 13, 44, 12, 15, 11, 4, 12},
        {6427, 7, 2, 7, 3, 14, 13, 42, 12, 15, 10, 4, 12},
        {6373, 7, 2, 7, 3, 15, 13, 42, 12, 15, 11, 4, 13},
        {6321, 7, 2, 7, 3, 15, 13, 43, 12, 15, 11, 4, 12},
        {6270, 7, 2, 7, 3, 15, 13, 44, 12, 15, 11, 4, 12},
        {6222, 7, 2, 7, 3, 15, 13, 45, 12, 15, 10, 4, 12},
        {6174, 6, 2, 7, 3, 15, 13, 42, 12, 15, 11, 4, 13},
        {6128, 6, 2, 7, 3, 15, 13, 43, 12, 15, 11, 4, 12},
        {6083, 6, 2, 7, 3, 15, 13, 44, 12, 15, 10, 4, 12},
        {6040, 6, 2, 7, 3, 15, 13, 44, 12, 15, 11, 4, 13},
        {5997, 6, 2, 7, 3, 15, 13, 45, 12, 15, 11, 4, 12},
    }
};

/* Rx Gain Tables */
#define SIZE_FULL_TABLE        77

static const uint8_t full_gain_table[RXGAIN_TBLS_END][SIZE_FULL_TABLE][3] =
{
    {  /* 800 MHz */
        {0x00, 0x00, 0x20}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00},
        {0x00, 0x01, 0x00}, {0x00, 0x02, 0x00}, {0x00, 0x03, 0x00},
        {0x00, 0x04, 0x00}, {0x00, 0x05, 0x00}, {0x01, 0x03, 0x20},
        {0x01, 0x04, 0x00}, {0x01, 0x05, 0x00}, {0x01, 0x06, 0x00},
        {0x01, 0x07, 0x00}, {0x01, 0x08, 0x00}, {0x01, 0x09, 0x00},
        {0x01, 0x0A, 0x00}, {0x01, 0x0B, 0x00}, {0x01, 0x0C, 0x00},
        {0x01, 0x0D, 0x00}, {0x01, 0x0E, 0x00}, {0x02, 0x09, 0x20},
        {0x02, 0x0A, 0x00}, {0x02, 0x0B, 0x00}, {0x02, 0x0C, 0x00},
        {0x02, 0x0D, 0x00}, {0x02, 0x0E, 0x00}, {0x02, 0x0F, 0x00},
        {0x02, 0x10, 0x00}, {0x02, 0x2B, 0x20}, {0x02, 0x2C, 0x00},
        {0x04, 0x28, 0x20}, {0x04, 0x29, 0x00}, {0x04, 0x2A, 0x00},
        {0x04, 0x2B, 0x00}, {0x24, 0x20, 0x20}, {0x24, 0x21, 0x00},
        {0x44, 0x20, 0x20}, {0x44, 0x21, 0x00}, {0x44, 0x22, 0x00},
        {0x44, 0x23, 0x00}, {0x44, 0x24, 0x00}, {0x44, 0x25, 0x00},
        {0x44, 0x26, 0x00}, {0x44, 0x27, 0x00}, {0x44, 0x28, 0x00},
        {0x44, 0x29, 0x00}, {0x44, 0x2A, 0x00}, {0x44, 0x2B, 0x00},
        {0x44, 0x2C, 0x00}, {0x44, 0x2D, 0x00}, {0x44, 0x2E, 0x00},
        {0x44, 0x2F, 0x00}, {0x44, 0x30, 0x00}, {0x44, 0x31, 0x00},
        {0x44, 0x32, 0x00}, {0x64, 0x2E, 0x20}, {0x64, 0x2F, 0x00},
        {0x64, 0x30, 0x00}, {0x64, 0x31, 0x00}, {0x64, 0x32, 0x00},
        {0x64, 0x33, 0x00}, {0x64, 0x34, 0x00}, {0x64, 0x35, 0x00},
        {0x64, 0x36, 0x00}, {0x64, 0x37, 0x00}, {0x64, 0x38, 0x00},
        {0x65, 0x38, 0x20}, {0x66, 0x38, 0x20}, {0x67, 0x38, 0x20},
        {0x68, 0x38, 0x20}, {0x69, 0x38, 0x20}, {0x6A, 0x38, 0x20},
        {0x6B, 0x38, 0x20}, {0x6C, 0x38, 0x20}, {0x6D, 0x38, 0x20},
        {0x6E, 0x38, 0x20}, {0x6F, 0x38, 0x20}
    },{  /* 2300 MHz */
        {0x00, 0x00, 0x20}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00},
        {0x00, 0x01, 0x00}, {0x00, 0x02, 0x00}, {0x00, 0x03, 0x00},
        {0x00, 0x04, 0x00}, {0x00, 0x05, 0x00}, {0x01, 0x03, 0x20},
        {0x01, 0x04, 0x00}, {0x01, 0x05, 0x00}, {0x01, 0x06, 0x00},
        {0x01, 0x07, 0x00}, {0x01, 0x08, 0x00}, {0x01, 0x09, 0x00},
        {0x01, 0x0A, 0x00}, {0x01, 0x0B, 0x00}, {0x01, 0x0C, 0x00},
        {0x01, 0x0D, 0x00}, {0x01, 0x0E, 0x00}, {0x02, 0x09, 0x20},
        {0x02, 0x0A, 0x00}, {0x02, 0x0B, 0x00}, {0x02, 0x0C, 0x00},
        {0x02, 0x0D, 0x00}, {0x02, 0x0E, 0x00}, {0x02, 0x0F, 0x00},
        {0x02, 0x10, 0x00}, {0x02, 0x2B, 0x20}, {0x02, 0x2C, 0x00},
        {0x04, 0x27, 0x20}, {0x04, 0x28, 0x00}, {0x04, 0x29, 0x00},
        {0x04, 0x2A, 0x00}, {0x04, 0x2B, 0x00}, {0x24, 0x21, 0x20},
        {0x24, 0x22, 0x00}, {0x44, 0x20, 0x20}, {0x44, 0x21, 0x00},
        {0x44, 0x22, 0x00}, {0x44, 0x23, 0x00}, {0x44, 0x24, 0x00},
        {0x44, 0x25, 0x00}, {0x44, 0x26, 0x00}, {0x44, 0x27, 0x00},
        {0x44, 0x28, 0x00}, {0x44, 0x29, 0x00}, {0x44, 0x2A, 0x00},
        {0x44, 0x2B, 0x00}, {0x44, 0x2C, 0x00}, {0x44, 0x2D, 0x00},
        {0x44, 0x2E, 0x00}, {0x44, 0x2F, 0x00}, {0x44, 0x30, 0x00},
        {0x44, 0x31, 0x00}, {0x64, 0x2E, 0x20}, {0x64, 0x2F, 0x00},
        {0x64, 0x30, 0x00}, {0x64, 0x31, 0x00}, {0x64, 0x32, 0x00},
        {0x64, 0x33, 0x00}, {0x64, 0x34, 0x00}, {0x64, 0x35, 0x00},
        {0x64, 0x36, 0x00}, {0x64, 0x37, 0x00}, {0x64, 0x38, 0x00},
        {0x65, 0x38, 0x20}, {0x66, 0x38, 0x20}, {0x67, 0x38, 0x20},
        {0x68, 0x38, 0x20}, {0x69, 0x38, 0x20}, {0x6A, 0x38, 0x20},
        {0x6B, 0x38, 0x20}, {0x6C, 0x38, 0x20}, {0x6D, 0x38, 0x20},
        {0x6E, 0x38, 0x20}, {0x6F, 0x38, 0x20},
    },{  /* 5500 MHz */
        {0x00, 0x00, 0x20}, {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00},
        {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}, {0x00, 0x01, 0x00},
        {0x00, 0x02, 0x00}, {0x00, 0x03, 0x00}, {0x01, 0x01, 0x20},
        {0x01, 0x02, 0x00}, {0x01, 0x03, 0x00}, {0x01, 0x04, 0x20},
        {0x01, 0x05, 0x00}, {0x01, 0x06, 0x00}, {0x01, 0x07, 0x00},
        {0x01, 0x08, 0x00}, {0x01, 0x09, 0x00}, {0x01, 0x0A, 0x00},
        {0x01, 0x0B, 0x00}, {0x01, 0x0C, 0x00}, {0x02, 0x08, 0x20},
        {0x02, 0x09, 0x00}, {0x02, 0x0A, 0x00}, {0x02, 0x0B, 0x20},
        {0x02, 0x0C, 0x00}, {0x02, 0x0D, 0x00}, {0x02, 0x0E, 0x00},
        {0x02, 0x0F, 0x00}, {0x02, 0x2A, 0x20}, {0x02, 0x2B, 0x00},
        {0x04, 0x27, 0x20}, {0x04, 0x28, 0x00}, {0x04, 0x29, 0x00},
        {0x04, 0x2A, 0x00}, {0x04, 0x2B, 0x00}, {0x04, 0x2C, 0x00},
        {0x04, 0x2D, 0x00}, {0x24, 0x20, 0x20}, {0x24, 0x21, 0x00},
        {0x24, 0x22, 0x00}, {0x44, 0x20, 0x20}, {0x44, 0x21, 0x00},
        {0x44, 0x22, 0x00}, {0x44, 0x23, 0x00}, {0x44, 0x24, 0x00},
        {0x44, 0x25, 0x00}, {0x44, 0x26, 0x00}, {0x44, 0x27, 0x00},
        {0x44, 0x28, 0x00}, {0x44, 0x29, 0x00}, {0x44, 0x2A, 0x00},
        {0x44, 0x2B, 0x00}, {0x44, 0x2C, 0x00}, {0x44, 0x2D, 0x00},
        {0x44, 0x2E, 0x00}, {0x64, 0x2E, 0x20}, {0x64, 0x2F, 0x00},
        {0x64, 0x30, 0x00}, {0x64, 0x31, 0x00}, {0x64, 0x32, 0x00},
        {0x64, 0x33, 0x00}, {0x64, 0x34, 0x00}, {0x64, 0x35, 0x00},
        {0x64, 0x36, 0x00}, {0x64, 0x37, 0x00}, {0x64, 0x38, 0x00},
        {0x65, 0x38, 0x20}, {0x66, 0x38, 0x20}, {0x67, 0x38, 0x20},
        {0x68, 0x38, 0x20}, {0x69, 0x38, 0x20}, {0x6A, 0x38, 0x20},
        {0x6B, 0x38, 0x20}, {0x6C, 0x38, 0x20}, {0x6D, 0x38, 0x20},
        {0x6E, 0x38, 0x20}, {0x6F, 0x38, 0x20}
    }
};

static const int8_t full_gain_table_abs_gain[RXGAIN_TBLS_END][SIZE_FULL_TABLE] =
{
    {  /* 800 MHz */
        -1, -1, -1, 0, 1, 2, 3, 4,
            5, 6, 7, 8, 9, 10, 11, 12,
            13, 14, 15, 16, 17, 18, 19, 20,
            21, 22, 23, 24, 25, 26, 27, 28,
            29, 30, 31, 32, 33, 34, 35, 36,
            37, 38, 39, 40, 41, 42, 43, 44,
            45, 46, 47, 48, 49, 50, 51, 52,
            53, 54, 55, 56, 57, 58, 59, 60,
            61, 62, 63, 64, 65, 66, 67, 68,
            69, 70, 71, 72, 73
        }, {  /* 2300 MHz */
        -3, -3, -3, -2, -1, 0, 1, 2,
            3, 4, 5, 6, 7, 8, 9, 10,
            11, 12, 13, 14, 15, 16, 17, 18,
            19, 20, 21, 22, 23, 24, 25, 26,
            27, 28, 29, 30, 31, 32, 33, 34,
            35, 36, 37, 38, 39, 40, 41, 42,
            43, 44, 45, 46, 47, 48, 49, 50,
            51, 52, 53, 54, 55, 56, 57, 58,
            59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71
        }, {  /* 5500 MHz */
        -10, -10, -10, -10, -10, -9, -8, -7,
            -6, -5, -4, -3, -2, -1, 0, 1,
            2, 3, 4, 5, 6, 7, 8, 9,
            10, 11, 12, 13, 14, 15, 16, 17,
            18, 19, 20, 21, 22, 23, 24, 25,
            26, 27, 28, 29, 30, 31, 32, 33,
            34, 35, 36, 37, 38, 39, 40, 41,
            42, 43, 44, 45, 46, 47, 48, 49,
            50, 51, 52, 53, 54, 55, 56, 57,
            58, 59, 60, 61, 62
        }
};

#define SIZE_SPLIT_TABLE        41

static const uint8_t split_gain_table[RXGAIN_TBLS_END][SIZE_SPLIT_TABLE][3] =
{
    {  /* 800 MHz */
        {0x00, 0x18, 0x20}, {0x00, 0x18, 0x00}, {0x00, 0x18, 0x00},
        {0x00, 0x18, 0x00}, {0x00, 0x18, 0x00}, {0x00, 0x18, 0x00},
        {0x00, 0x18, 0x20}, {0x01, 0x18, 0x20}, {0x02, 0x18, 0x20},
        {0x04, 0x18, 0x20}, {0x04, 0x38, 0x20}, {0x05, 0x38, 0x20},
        {0x06, 0x38, 0x20}, {0x07, 0x38, 0x20}, {0x08, 0x38, 0x20},
        {0x09, 0x38, 0x20}, {0x0A, 0x38, 0x20}, {0x0B, 0x38, 0x20},
        {0x0C, 0x38, 0x20}, {0x0D, 0x38, 0x20}, {0x0E, 0x38, 0x20},
        {0x0F, 0x38, 0x20}, {0x24, 0x38, 0x20}, {0x25, 0x38, 0x20},
        {0x44, 0x38, 0x20}, {0x45, 0x38, 0x20}, {0x46, 0x38, 0x20},
        {0x47, 0x38, 0x20}, {0x48, 0x38, 0x20}, {0x64, 0x38, 0x20},
        {0x65, 0x38, 0x20}, {0x66, 0x38, 0x20}, {0x67, 0x38, 0x20},
        {0x68, 0x38, 0x20}, {0x69, 0x38, 0x20}, {0x6A, 0x38, 0x20},
        {0x6B, 0x38, 0x20}, {0x6C, 0x38, 0x20}, {0x6D, 0x38, 0x20},
        {0x6E, 0x38, 0x20}, {0x6F, 0x38, 0x20},
    },{  /* 2300 MHz */
        {0x00, 0x18, 0x20}, {0x00, 0x18, 0x00}, {0x00, 0x18, 0x00},
        {0x00, 0x18, 0x00}, {0x00, 0x18, 0x00}, {0x00, 0x18, 0x00},
        {0x00, 0x18, 0x00}, {0x00, 0x18, 0x20}, {0x01, 0x18, 0x20},
        {0x02, 0x18, 0x20}, {0x04, 0x18, 0x20}, {0x04, 0x38, 0x20},
        {0x05, 0x38, 0x20}, {0x06, 0x38, 0x20}, {0x07, 0x38, 0x20},
        {0x08, 0x38, 0x20}, {0x09, 0x38, 0x20}, {0x0A, 0x38, 0x20},
        {0x0B, 0x38, 0x20}, {0x0C, 0x38, 0x20}, {0x0D, 0x38, 0x20},
        {0x0E, 0x38, 0x20}, {0x0F, 0x38, 0x20}, {0x25, 0x38, 0x20},
        {0x26, 0x38, 0x20}, {0x44, 0x38, 0x20}, {0x45, 0x38, 0x20},
        {0x46, 0x38, 0x20}, {0x47, 0x38, 0x20}, {0x64, 0x38, 0x20},
        {0x65, 0x38, 0x20}, {0x66, 0x38, 0x20}, {0x67, 0x38, 0x20},
        {0x68, 0x38, 0x20}, {0x69, 0x38, 0x20}, {0x6A, 0x38, 0x20},
        {0x6B, 0x38, 0x20}, {0x6C, 0x38, 0x20}, {0x6D, 0x38, 0x20},
        {0x6E, 0x38, 0x20}, {0x6F, 0x38, 0x20},
    },{  /* 5500 MHz */
        {0x00, 0x18, 0x20}, {0x00, 0x18, 0x00}, {0x00, 0x18, 0x00},
        {0x00, 0x18, 0x00}, {0x00, 0x18, 0x00}, {0x00, 0x18, 0x00},
        {0x00, 0x18, 0x00}, {0x00, 0x18, 0x00}, {0x00, 0x18, 0x00},
        {0x00, 0x18, 0x00}, {0x01, 0x18, 0x20}, {0x02, 0x18, 0x20},
        {0x04, 0x18, 0x20}, {0x04, 0x38, 0x20}, {0x05, 0x38, 0x20},
        {0x06, 0x38, 0x20}, {0x07, 0x38, 0x20}, {0x08, 0x38, 0x20},
        {0x09, 0x38, 0x20}, {0x0A, 0x38, 0x20}, {0x0B, 0x38, 0x20},
        {0x0C, 0x38, 0x20}, {0x0D, 0x38, 0x20}, {0x0E, 0x38, 0x20},
        {0x0F, 0x38, 0x20}, {0x62, 0x38, 0x20}, {0x25, 0x38, 0x20},
        {0x26, 0x38, 0x20}, {0x44, 0x38, 0x20}, {0x64, 0x38, 0x20},
        {0x65, 0x38, 0x20}, {0x66, 0x38, 0x20}, {0x67, 0x38, 0x20},
        {0x68, 0x38, 0x20}, {0x69, 0x38, 0x20}, {0x6A, 0x38, 0x20},
        {0x6B, 0x38, 0x20}, {0x6C, 0x38, 0x20}, {0x6D, 0x38, 0x20},
        {0x6E, 0x38, 0x20}, {0x6F, 0x38, 0x20},
    }
};

static const int8_t split_gain_table_abs_gain[RXGAIN_TBLS_END][SIZE_SPLIT_TABLE] =
{
    {  /* 800 MHz */
        -1, -1, -1, -1, -1, -1, -1, 2,
            8, 13, 19, 20, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32,
            33, 34, 35, 36, 37, 38, 39, 40,
            41, 42, 43, 44, 45, 46, 47, 48,
            49
        }, {  /* 2300 MHz */
        -3, -3, -3, -3, -3, -3, -3, -3,
            0, 6, 12, 18, 19, 20, 21, 22,
            23, 24, 25, 26, 27, 28, 29, 30,
            31, 32, 33, 34, 35, 36, 37, 38,
            39, 40, 41, 42, 43, 44, 45, 46,
            47
        }, {  /* 5500 MHz */
        -10, -10, -10, -10, -10, -10, -10, -10,
            -10, -10, -7, -2, 3, 9, 10, 11,
            12, 13, 14, 15, 16, 17, 18, 19,
            20, 22, 24, 25, 26, 27, 28, 29,
            30, 31, 32, 33, 34, 35, 36, 37,
            38
        }
};

struct ad9361_gain_table_info ad9361_adi_gt_info[] =
{
    {
        .start = 0,
        .end = 1300000000ULL,
        .max_index = SIZE_FULL_TABLE,
        .abs_gain_tbl = (int8_t*)&full_gain_table_abs_gain[TBL_200_1300_MHZ],
        .tab = (uint8_t(*)[3]) full_gain_table[TBL_200_1300_MHZ],
    },{
        .start = 1300000000ULL,
        .end = 4000000000ULL,
        .max_index = SIZE_FULL_TABLE,
        .abs_gain_tbl = (int8_t*)&full_gain_table_abs_gain[TBL_1300_4000_MHZ],
        .tab = (uint8_t(*)[3]) full_gain_table[TBL_1300_4000_MHZ],
    },{
        .start = 4000000000ULL,
        .end = 6000000000ULL,
        .max_index = SIZE_FULL_TABLE,
        .abs_gain_tbl = (int8_t*)&full_gain_table_abs_gain[TBL_4000_6000_MHZ],
        .tab = (uint8_t(*)[3]) full_gain_table[TBL_4000_6000_MHZ],
    },{
        .start = 0,
        .end = 1300000000ULL,
        .max_index = SIZE_SPLIT_TABLE,
        .split_table = 1,
        .abs_gain_tbl = (int8_t*)&split_gain_table_abs_gain[TBL_200_1300_MHZ],
        .tab = (uint8_t(*)[3]) split_gain_table[TBL_200_1300_MHZ],
    },{
        .start = 1300000000ULL,
        .end = 4000000000ULL,
        .max_index = SIZE_SPLIT_TABLE,
        .split_table = 1,
        .abs_gain_tbl = (int8_t*)&split_gain_table_abs_gain[TBL_1300_4000_MHZ],
        .tab = (uint8_t(*)[3]) split_gain_table[TBL_1300_4000_MHZ],
    },{
        .start = 4000000000ULL,
        .end = 6000000000ULL,
        .max_index = SIZE_SPLIT_TABLE,
        .split_table = 1,
        .abs_gain_tbl = (int8_t*)&split_gain_table_abs_gain[TBL_4000_6000_MHZ],
        .tab = (uint8_t(*)[3]) split_gain_table[TBL_4000_6000_MHZ],
    },{
        .start = 0,
        .end = 0,
        .max_index = 0,
        .split_table = 0,
        .abs_gain_tbl = NULL,
        .tab = NULL,
    }, /* Don't Remove */
};

/* Mixer GM Sub-table */
static const uint8_t gm_st_gain[16] = {0x78, 0x74, 0x70, 0x6C, 0x68, 0x64, 0x60, 0x5C, 0x58, 0x54, 0x50, 0x4C, 0x48, 0x30, 0x18, 0x0};
static const uint8_t gm_st_ctrl[16] = {0x0, 0xD, 0x15, 0x1B, 0x21, 0x25, 0x29, 0x2C, 0x2F, 0x31, 0x33, 0x34, 0x35, 0x3A, 0x3D, 0x3E};

static const int8_t lna_table[RXGAIN_TBLS_END][4] =
{
    {5, 17, 19, 24},
    {3, 14, 17, 21},
    {-4, 10, 13, 14}
};
static const int8_t tia_table[] = {-6, 0};
static const int8_t mixer_table[RXGAIN_TBLS_END][16] =
{
    {0, 3, 9, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25},
    {0, 3, 9, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26},
    {0, 3, 8, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24}
};
static const uint32_t gain_step_calib_reg_val[4][5] =
{
    {0xC0, 0x2E, 0x10, 0x06, 0x00},    // LO Frequency Range: 600 to 1300 MHz
    {0xC0, 0x2C, 0x10, 0x06, 0x00},    // LO Frequency Range: 1300 to 3300 MHz
    {0xB8, 0x2C, 0x10, 0x06, 0x00},    // LO Frequency Range: 2700 to 4100 MHz
    {0xA0, 0x24, 0x10, 0x06, 0x00},    // LO Frequency Range: 4000 to 6000 MHz
};

const char* ad9361_ensm_states[] = {"SLEEP", "ENSM_RSVD_1", "ENSM_RSVD_2", "ENSM_RSVD_3", "ENSM_RSVD_4", "ALERT", "TX", "TX Flush", "RX", "RX Flush", "FDD", "FDD Flush"};

struct ad9361_rf_phy* g_pAD9361Phy = NULL;

/**
 * SPI multiple bytes register read.
 * @param spi
 * @param reg The register address.
 * @param rbuf The data buffer.
 * @param num The number of bytes to read.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_spi_readm(uint32_t reg, uint8_t* rbuf, uint32_t num)
{
    uint16_t cmd;

    if(num > MAX_MBYTE_SPI)
        return -EINVAL;

    if(rbuf == NULL)
        return -EINVAL;

    cmd = AD_READ | AD_CNT(num) | AD_ADDR(reg);

    axi_quad_spi_slave_select(AXI_QUAD_SPI_TRX_INST, AXI_QUAD_SPI1_TRX_SS, 1);

    axi_quad_spi_write_byte(AXI_QUAD_SPI_TRX_INST, cmd >> 8, 0);
    axi_quad_spi_write_byte(AXI_QUAD_SPI_TRX_INST, cmd & 0xFF, 1);
    axi_quad_spi_read(AXI_QUAD_SPI_TRX_INST, rbuf, num, 0x00);

    axi_quad_spi_slave_select(AXI_QUAD_SPI_TRX_INST, AXI_QUAD_SPI1_TRX_SS, 0);

    return 0;
}

/**
 * SPI register read.
 * @param spi
 * @param reg The register address.
 * @return The register value or negative error code in case of failure.
 */
int32_t ad9361_spi_read(uint32_t reg)
{
    uint8_t buf;
    int32_t ret;

    ret = ad9361_spi_readm(reg, &buf, 1);

    if(ret < 0)
        return ret;

    return buf;
}

/**
 * IIO SPI register read.
 * @param phy The AD9361 state structure.
 * @param reg The register address.
 * @param val The value read from register address.
 * @return The register value or negative error code in case of failure.
 */
int32_t ad9361_reg_read(uint32_t reg, uint32_t* val)
{
    int32_t ret;

    ret = ad9361_spi_read(reg);

    if(ret < 0)
        return ret;

    if(val != NULL)
        *val = ret;

    return 0;
}

/**
 * SPI register bits read.
 * @param spi
 * @param reg The register address.
 * @param mask The bits mask.
 * @param offset The mask offset.
 * @return The bits value or negative error code in case of failure.
 */
static int32_t __ad9361_spi_readf(uint32_t reg, uint32_t mask, uint32_t offset)
{
    uint8_t buf;
    int32_t ret;

    if(!mask)
        return -EINVAL;

    ret = ad9361_spi_readm(reg, &buf, 1);

    if(ret < 0)
        return ret;

    buf &= mask;
    buf >>= offset;

    return buf;
}

/**
 * SPI register bits read.
 * @param spi
 * @param reg The register address.
 * @param mask The bits mask.
 * @return The bits value or negative error code in case of failure.
 */
#define ad9361_spi_readf(reg, mask) __ad9361_spi_readf(reg, mask, utils_find_first_set_bit(mask))

 /**
  * SPI register write.
  * @param spi
  * @param reg The register address.
  * @param val The value of the register.
  * @return 0 in case of success, negative error code otherwise.
  */
int32_t ad9361_spi_write(uint32_t reg, uint32_t val)
{
    uint16_t cmd;

    cmd = AD_WRITE | AD_CNT(1) | AD_ADDR(reg);

    axi_quad_spi_slave_select(AXI_QUAD_SPI_TRX_INST, AXI_QUAD_SPI1_TRX_SS, 1);

    axi_quad_spi_write_byte(AXI_QUAD_SPI_TRX_INST, cmd >> 8, 0);
    axi_quad_spi_write_byte(AXI_QUAD_SPI_TRX_INST, cmd & 0xFF, 0);
    axi_quad_spi_write_byte(AXI_QUAD_SPI_TRX_INST, val & 0xFF, 1);

    axi_quad_spi_slave_select(AXI_QUAD_SPI_TRX_INST, AXI_QUAD_SPI1_TRX_SS, 0);

    return 0;
}

/**
 * IIO SPI register write.
 * @param phy The AD9361 state structure.
 * @param reg The register address.
 * @param val The value of the register.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_reg_write(uint32_t reg, uint32_t val)
{
    return ad9361_spi_write(reg, val);
}

/**
 * SPI register bits write.
 * @param spi
 * @param reg The register address.
 * @param mask The bits mask.
 * @param offset The mask offset.
 * @param val The bits value.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t __ad9361_spi_writef(uint32_t reg, uint32_t mask, uint32_t offset, uint32_t val)
{
    uint8_t buf;
    int32_t ret;

    if(!mask)
        return -EINVAL;

    ret = ad9361_spi_readm(reg, &buf, 1);

    if(ret < 0)
        return ret;

    buf &= ~mask;
    buf |= ((val << offset) & mask);

    return ad9361_spi_write(reg, buf);
}

/**
 * SPI register bits write.
 * @param spi
 * @param reg The register address.
 * @param mask The bits mask.
 * @param val The bits value.
 * @return 0 in case of success, negative error code otherwise.
 */
#define ad9361_spi_writef(reg, mask, val) __ad9361_spi_writef(reg, mask, utils_find_first_set_bit(mask), val)

/**
  * SPI multiple bytes register write.
  * @param spi
  * @param reg The register address.
  * @param tbuf The data buffer.
  * @param num The number of bytes to read.
  * @return 0 in case of success, negative error code otherwise.
  */
static int32_t ad9361_spi_writem(uint32_t reg, uint8_t* tbuf, uint32_t num)
{
    uint16_t cmd;

    if(num > MAX_MBYTE_SPI)
        return -EINVAL;

    if(tbuf == NULL)
        return -EINVAL;

    cmd = AD_WRITE | AD_CNT(num) | AD_ADDR(reg);

    axi_quad_spi_slave_select(AXI_QUAD_SPI_TRX_INST, AXI_QUAD_SPI1_TRX_SS, 1);

    axi_quad_spi_write_byte(AXI_QUAD_SPI_TRX_INST, cmd >> 8, 0);
    axi_quad_spi_write_byte(AXI_QUAD_SPI_TRX_INST, cmd & 0xFF, 0);
    axi_quad_spi_write(AXI_QUAD_SPI_TRX_INST, tbuf, num, 1);

    axi_quad_spi_slave_select(AXI_QUAD_SPI_TRX_INST, AXI_QUAD_SPI1_TRX_SS, 0);

#ifdef _DEBUG
    {
        int32_t i;
        for(i = 0; i < num; i++)
            dev_dbg("Reg 0x%"PRIX32" val 0x%X", reg--, tbuf[i]);
    }
#endif

    return 0;
}

/**
 * Validate RF BW frequency.
 * @param phy The AD9361 state structure.
 * @param bw The RF BW frequency.
 * @return The validated RF BW frequency.
 */
uint32_t ad9361_validate_rf_bw(uint32_t bw)
{
    switch(g_pAD9361Phy->dev_sel)
    {
        case ID_AD9363A:
            return CLAMP_T(uint32_t, bw, 200000UL, 20000000UL);
        default:
            return CLAMP_T(uint32_t, bw, 200000UL, 56000000UL);
    }
}

/**
 * Validate RF PLL frequency.
 * @param phy The AD9361 state structure.
 * @param is_tx TX enabled.
 * @param freq The RF PLL frequency.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_validate_rfpll(bool is_tx, uint64_t freq)
{
    switch(g_pAD9361Phy->dev_sel)
    {
        case ID_AD9363A:
            if(freq > AD9363A_MAX_CARRIER_FREQ_HZ || freq < AD9363A_MIN_CARRIER_FREQ_HZ)
                return -EINVAL;
        break;
        default:
            if(freq > MAX_CARRIER_FREQ_HZ || freq < (is_tx ? MIN_TX_CARRIER_FREQ_HZ : MIN_RX_CARRIER_FREQ_HZ))
                return -EINVAL;
    }

    return 0;
}

/**
 * Select the channel mapping in 1rx1tx mode.
 * @param phy The AD9361 state structure.
 * @param tx TX
 * @param channel Channel
 * @return The channel number.
 */
int32_t ad9361_1rx1tx_channel_map(bool tx, int32_t channel)
{
    uint32_t map;

    if(g_pAD9361Phy->pdata->rx2tx2)
        return channel;

    if(tx)
        map = g_pAD9361Phy->pdata->rx1tx1_mode_use_tx_num;
    else
        map = g_pAD9361Phy->pdata->rx1tx1_mode_use_rx_num;

    if(map == 2)
        return channel + 1;

    return channel;
}

/**
 * AD9361 Device Reset
 * @param phy The AD9361 state structure.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_reset()
{
    axi_gpio_set_value(AXI_GPIO_TRX_INST, AXI_GPIO0_TRX_RESETn_BIT, 0);
    usleep(1000);
    axi_gpio_set_value(AXI_GPIO_TRX_INST, AXI_GPIO0_TRX_RESETn_BIT, 1);
    usleep(1000);

    return 0;

    /* SPI Soft Reset was removed from the register map, since it doesn't
     * work reliably. Without a prober HW reset randomness may happen.
     * Please specify a RESET GPIO.
     */

    // ad9361_spi_write(REG_SPI_CONF, SOFT_RESET | _SOFT_RESET);
    // ad9361_spi_write(REG_SPI_CONF, 0x0);
    // DBGPRINTLN_CTX("Reset by SPI, this may cause unpredicted behavior!");

    // return -ENODEV;
}

/**
 * Enable/disable the desired TX channel.
 * @param phy The AD9361 state structure.
 * @param tx_if The desired channel number [1, 2].
 * @param enable Enable/disable option.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_en_dis_tx(uint32_t tx_if, uint32_t enable)
{
    if((tx_if & enable) > 1 && g_pAD9361Phy->dev_sel == ID_AD9364 && enable)
        return -EINVAL;

    return ad9361_spi_writef(REG_TX_ENABLE_FILTER_CTRL, TX_CHANNEL_ENABLE(tx_if), enable);
}

/**
 * Enable/disable the desired RX channel.
 * @param phy The AD9361 state structure.
 * @param rx_if The desired channel number [1, 2].
 * @param enable Enable/disable option.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_en_dis_rx(uint32_t rx_if, uint32_t enable)
{
    if((rx_if & enable) > 1 && g_pAD9361Phy->dev_sel == ID_AD9364 && enable)
        return -EINVAL;

    return ad9361_spi_writef(REG_RX_ENABLE_FILTER_CTRL, RX_CHANNEL_ENABLE(rx_if), enable);
}

/**
 * Loopback works only TX1->RX1 or TX2->RX2.
 * @param phy The AD9361 state structure.
 * @param enable Enable.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_int_loopback_fix_ch_cross(bool enable)
{
    /* Loopback works only TX1->RX1 or RX2->RX2 */
    if(!g_pAD9361Phy->pdata->rx2tx2 && g_pAD9361Phy->pdata->rx1tx1_mode_use_rx_num != g_pAD9361Phy->pdata->rx1tx1_mode_use_tx_num)
        return ad9361_en_dis_tx(TX_1 | TX_2, enable ? g_pAD9361Phy->pdata->rx1tx1_mode_use_rx_num : g_pAD9361Phy->pdata->rx1tx1_mode_use_tx_num);

    return 0;
}

/**
 * BIST loopback mode.
 * @param phy The AD9361 state structure.
 * @param mode BIST loopback mode.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_bist_loopback(int32_t mode)
{
    uint32_t sp_hd, reg;

    DBGPRINTLN_CTX("BIST loopback mode %"PRId32, mode);

    reg = ad9361_spi_read(REG_OBSERVE_CONFIG);

    g_pAD9361Phy->bist_loopback_mode = mode;

    switch(mode)
    {
        case 0:
            axi_ad9361_set_hdl_loopback(0);
            ad9361_int_loopback_fix_ch_cross(false);

            reg &= ~(DATA_PORT_SP_HD_LOOP_TEST_OE | DATA_PORT_LOOP_TEST_ENABLE);

            return ad9361_spi_write(REG_OBSERVE_CONFIG, reg);
        case 1:
            /* loopback (AD9361 internal) TX->RX */
            axi_ad9361_set_hdl_loopback(0);
            ad9361_int_loopback_fix_ch_cross(true);

            sp_hd = ad9361_spi_read(REG_PARALLEL_PORT_CONF_3);

            if((sp_hd & SINGLE_PORT_MODE) && (sp_hd & HALF_DUPLEX_MODE))
                reg |= DATA_PORT_SP_HD_LOOP_TEST_OE;
            else
                reg &= ~DATA_PORT_SP_HD_LOOP_TEST_OE;

            reg |= DATA_PORT_LOOP_TEST_ENABLE;

            return ad9361_spi_write(REG_OBSERVE_CONFIG, reg);
        case 2:
            /* loopback (FPGA internal) RX->TX */
            axi_ad9361_set_hdl_loopback(1);
            ad9361_int_loopback_fix_ch_cross(false);

            reg &= ~(DATA_PORT_SP_HD_LOOP_TEST_OE | DATA_PORT_LOOP_TEST_ENABLE);

            return ad9361_spi_write(REG_OBSERVE_CONFIG, reg);
        default:
            return -EINVAL;
    }
}

/**
 * Get BIST loopback mode.
 * @param phy The AD9361 state structure.
 * @param mode BIST loopback mode.
 * @return 0 in case of success, negative error code otherwise.
 */
void ad9361_get_bist_loopback(int32_t* mode)
{
    *mode = g_pAD9361Phy->bist_loopback_mode;
}

/**
 * BIST mode.
 * @param phy The AD9361 state structure.
 * @param mode Bist mode.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_bist_prbs(enum ad9361_bist_mode mode)
{
    uint32_t reg = 0;

    DBGPRINTLN_CTX("BIST PRBS mode %"PRId32, mode);

    g_pAD9361Phy->bist_prbs_mode = mode;

    switch(mode)
    {
        case BIST_DISABLE:
            reg = 0;
        break;
        case BIST_INJ_TX:
            reg = BIST_CTRL_POINT(0) | BIST_ENABLE;
        break;
        case BIST_INJ_RX:
            reg = BIST_CTRL_POINT(2) | BIST_ENABLE;
        break;
    };

    g_pAD9361Phy->bist_config = reg;

    return ad9361_spi_write(REG_BIST_CONFIG, reg);
}

/**
 * Get BIST mode settings.
 * @param phy The AD9361 state structure.
 * @param mode Bist mode.
 * @return 0 in case of success, negative error code otherwise.
 */
void ad9361_get_bist_prbs(enum ad9361_bist_mode* mode)
{
    *mode = g_pAD9361Phy->bist_prbs_mode;
}

/**
 * BIST tone.
 * @param phy The AD9361 state structure.
 * @param mode Bist tone mode.
 * @param freq_Hz Bist tone frequency.
 * @param level_dB Bist tone level.
 * @param mask Bist reg mask.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_bist_tone(enum ad9361_bist_mode mode, uint32_t freq_Hz, uint32_t level_dB, uint32_t mask)
{
    uint32_t clk = 0;
    uint32_t reg = 0, reg1, reg_mask;

    DBGPRINTLN_CTX("BIST tone mode %"PRId32, mode);

    g_pAD9361Phy->bist_tone_mode = mode;
    g_pAD9361Phy->bist_tone_freq_Hz = freq_Hz;
    g_pAD9361Phy->bist_tone_level_dB = level_dB;
    g_pAD9361Phy->bist_tone_mask = mask;

    switch(mode)
    {
        case BIST_DISABLE:
            reg = 0;
        break;
        case BIST_INJ_TX:
            clk = ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[TX_SAMPL_CLK]);
            reg = BIST_CTRL_POINT(0) | BIST_ENABLE;
        break;
        case BIST_INJ_RX:
            clk = ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[RX_SAMPL_CLK]);
            reg = BIST_CTRL_POINT(2) | BIST_ENABLE;
        break;
    };

    reg |= TONE_PRBS;
    reg |= TONE_LEVEL(level_dB / 6);

    if(freq_Hz < 4)
        reg |= TONE_FREQ(freq_Hz);
    else if(clk)
        reg |= TONE_FREQ(DIV_ROUND(freq_Hz * 32, clk) - 1);

    reg_mask = BIST_MASK_CHANNEL_1_I_DATA | BIST_MASK_CHANNEL_1_Q_DATA | BIST_MASK_CHANNEL_2_I_DATA | BIST_MASK_CHANNEL_2_Q_DATA;

    reg1 = ((mask << 2) & reg_mask);
    ad9361_spi_write(REG_BIST_AND_DATA_PORT_TEST_CONFIG, reg1);

    g_pAD9361Phy->bist_config = reg;

    return ad9361_spi_write(REG_BIST_CONFIG, reg);
}

/**
 * Get BIST tone settings.
 * @param phy The AD9361 state structure.
 * @param mode Bist tone mode.
 * @param freq_Hz Bist tone frequency.
 * @param level_dB Bist tone level.
 * @param mask Bist reg mask.
 * @return 0 in case of success, negative error code otherwise.
 */
void ad9361_get_bist_tone(enum ad9361_bist_mode* mode, uint32_t* freq_Hz, uint32_t* level_dB, uint32_t* mask)
{
    *mode = g_pAD9361Phy->bist_tone_mode;
    *freq_Hz = g_pAD9361Phy->bist_tone_freq_Hz;
    *level_dB = g_pAD9361Phy->bist_tone_level_dB;
    *mask = g_pAD9361Phy->bist_tone_mask;
}

/**
 * Check the calibration done bit.
 * @param phy The AD9361 state structure.
 * @param reg The register address.
 * @param mask The bit mask.
 * @param done_state The done state [0,1].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_check_cal_done(uint32_t reg, uint32_t mask, uint32_t done_state)
{
    uint32_t timeout = 20000; /* RFDC_CAL can take long */
    uint32_t state;

    do
    {
        state = ad9361_spi_readf(reg, mask);

        if(state == done_state)
            return 0;

        if(reg == REG_CALIBRATION_CTRL)
            usleep(1200);
        else
            usleep(120);
    }
    while(timeout--);

    DBGPRINTLN_CTX("Calibration TIMEOUT (0x%"PRIX32", 0x%"PRIX32")", reg, mask);

    return -ETIMEDOUT;
}

/**
 * Run an AD9361 calibration and check the calibration done bit.
 * @param phy The AD9361 state structure.
 * @param mask The calibration bit mask[RX_BB_TUNE_CAL, TX_BB_TUNE_CAL,
 *             RX_QUAD_CAL, TX_QUAD_CAL, RX_GAIN_STEP_CAL, TXMON_CAL,
 *             RFDC_CAL, BBDC_CAL].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_run_calibration(uint32_t mask)
{
    int32_t ret = ad9361_spi_write(REG_CALIBRATION_CTRL, mask);

    if(ret < 0)
        return ret;

    DBGPRINTLN_CTX("Calibration started (0x%"PRIX32")", mask);

    return ad9361_check_cal_done(REG_CALIBRATION_CTRL, mask, 0);
}

/**
 * Choose the right RX gain table index for the selected frequency.
 * @param freq The frequency value [Hz].
 * @return The index to the RX gain table.
 */
static int32_t ad9361_gt_tableindex(uint64_t freq)
{
    int32_t i;

    for(i = 0; g_pAD9361Phy->gt_info[i].tab != NULL; i++)
        if((g_pAD9361Phy->pdata->split_gt == g_pAD9361Phy->gt_info[i].split_table) && (g_pAD9361Phy->gt_info[i].start < freq) && (freq <= g_pAD9361Phy->gt_info[i].end))
            return i;

    DBGPRINTLN_CTX("No gain table found for %"PRIu64" Hz", freq);

    return 0;
}

/**
 * Return the current gain table index.
 * @param phy The AD9361 state structure.
 * @return The current gain table index or 0 if the table was not chosen.
 */
uint32_t ad9361_gt()
{
    if(g_pAD9361Phy->current_table == NO_GAIN_TABLE)
    {
        DBGPRINTLN_CTX("No current gain table selected");

        return 0;
    }

    return g_pAD9361Phy->current_table;
}

/**
 * Shift the real frequency value, so it fits type unsigned long
 * Note: PLL operates between 47 .. 6000 MHz which is > 2^32.
 * @param freq The frequency value [Hz].
 * @return The shifted frequency value.
 */
uint32_t ad9361_to_clk(uint64_t freq)
{
    return (uint32_t)(freq >> 1);
}

/**
 * Shift back the frequency value, so it reflects the real value.
 * Note: PLL operates between 47 .. 6000 MHz which is > 2^32.
 * @param freq The frequency value [Hz].
 * @return The shifted frequency value.
 */
uint64_t ad9361_from_clk(uint32_t freq)
{
    return ((uint64_t)freq << 1);
}

/**
 * Find the corresponding table index for a specific gain value.
 * @param phy The AD9361 state structure.
 * @param gain The gain value.
 * @return The table index.
 */
static int find_table_index(int gain)
{
    uint32_t i, nm1, n;

    for(i = 0; i < g_pAD9361Phy->gt_info[ad9361_gt()].max_index; i++)
    {
        if(g_pAD9361Phy->gt_info[ad9361_gt()].abs_gain_tbl[i] >= gain)
        {
            nm1 = abs(g_pAD9361Phy->gt_info[ad9361_gt()].abs_gain_tbl[(i > 0) ? i - 1 : i] - gain);
            n = abs(g_pAD9361Phy->gt_info[ad9361_gt()].abs_gain_tbl[i] - gain);

            if(nm1 < n)
                return (i > 0) ? i - 1 : i;
            else
                return i;
        }
    }

    return -EINVAL;
}

/**
 * Load the gain table for the selected frequency range and receiver.
 * @param phy The AD9361 state structure.
 * @param freq The frequency value [Hz].
 * @param dest The destination [GT_RX1, GT_RX2].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_load_gt(uint64_t freq, uint32_t dest)
{
    uint8_t(*tab)[3];
    uint32_t band, index_max, lna, lpf_tia_mask, set_gain;
    int32_t ret, rx1_gain, rx2_gain;

    DBGPRINTLN_CTX("Load gain table for %"PRIu64" Hz", freq);

    band = ad9361_gt_tableindex(freq);

    DBGPRINTLN_CTX("Gain table for %"PRIu64" Hz is %"PRIu32, freq, band);

    /* check if table is present */
    if(g_pAD9361Phy->current_table == band)
        return 0;

    tab = g_pAD9361Phy->gt_info[band].tab;
    index_max = g_pAD9361Phy->gt_info[band].max_index;

    ad9361_spi_writef(REG_AGC_CONFIG_2, AGC_USE_FULL_GAIN_TABLE, !g_pAD9361Phy->pdata->split_gt);

    ad9361_spi_write(REG_MAX_LMT_FULL_GAIN, index_max - 1); /* Max Full/LMT Gain Table Index */

    set_gain = ad9361_spi_readf(REG_RX1_MANUAL_LMT_FULL_GAIN, RX_FULL_TBL_IDX_MASK);

    if(g_pAD9361Phy->current_table != NO_GAIN_TABLE)
    {
        rx1_gain = g_pAD9361Phy->gt_info[g_pAD9361Phy->current_table].abs_gain_tbl[set_gain];
    }
    else
    {
        if(set_gain > (index_max - 1))
            set_gain = index_max - 1;

        rx1_gain = g_pAD9361Phy->gt_info[band].abs_gain_tbl[set_gain];
    }

    set_gain = ad9361_spi_readf(REG_RX2_MANUAL_LMT_FULL_GAIN, RX_FULL_TBL_IDX_MASK);

    if(g_pAD9361Phy->current_table != NO_GAIN_TABLE)
    {
        rx2_gain = g_pAD9361Phy->gt_info[g_pAD9361Phy->current_table].abs_gain_tbl[set_gain];
    }
    else
    {
        if(set_gain > (index_max - 1))
            set_gain = index_max - 1;

        rx2_gain = g_pAD9361Phy->gt_info[band].abs_gain_tbl[set_gain];
    }

    lna = g_pAD9361Phy->pdata->elna_ctrl.elna_in_gaintable_all_index_en ? EXT_LNA_CTRL : 0;

    ad9361_spi_write(REG_GAIN_TABLE_CONFIG, START_GAIN_TABLE_CLOCK | RECEIVER_SELECT(dest)); /* Start Gain Table Clock */

    /* TX QUAD Calibration */
    if(g_pAD9361Phy->pdata->split_gt)
        lpf_tia_mask = 0x20;
    else
        lpf_tia_mask = 0x3F;

    g_pAD9361Phy->tx_quad_lpf_tia_match = -EINVAL;

    for(uint32_t i = 0; i < index_max; i++)
    {
        ad9361_spi_write(REG_GAIN_TABLE_ADDRESS, i); /* Gain Table Index */
        ad9361_spi_write(REG_GAIN_TABLE_WRITE_DATA1, tab[i][0] | lna); /* Ext LNA, Int LNA, & Mixer Gain Word */
        ad9361_spi_write(REG_GAIN_TABLE_WRITE_DATA2, tab[i][1]); /* TIA & LPF Word */
        ad9361_spi_write(REG_GAIN_TABLE_WRITE_DATA3, tab[i][2]); /* DC Cal bit & Dig Gain Word */
        ad9361_spi_write(REG_GAIN_TABLE_CONFIG, START_GAIN_TABLE_CLOCK | WRITE_GAIN_TABLE | RECEIVER_SELECT(dest)); /* Gain Table Index */
        ad9361_spi_write(REG_GAIN_TABLE_READ_DATA1, 0); /* Dummy Write to delay 3 ADCCLK/16 cycles */
        ad9361_spi_write(REG_GAIN_TABLE_READ_DATA1, 0); /* Dummy Write to delay ~1u */

        if((tab[i][1] & lpf_tia_mask) == 0x20)
            g_pAD9361Phy->tx_quad_lpf_tia_match = i;
    }

    ad9361_spi_write(REG_GAIN_TABLE_CONFIG, START_GAIN_TABLE_CLOCK | RECEIVER_SELECT(dest)); /* Clear Write Bit */
    ad9361_spi_write(REG_GAIN_TABLE_READ_DATA1, 0); /* Dummy Write to delay ~1u */
    ad9361_spi_write(REG_GAIN_TABLE_READ_DATA1, 0); /* Dummy Write to delay ~1u */
    ad9361_spi_write(REG_GAIN_TABLE_CONFIG, 0); /* Stop Gain Table Clock */

    g_pAD9361Phy->current_table = band;

    ret = find_table_index(rx1_gain);

    if(ret < 0)
        ret = g_pAD9361Phy->gt_info[band].max_index - 1;

    ad9361_spi_writef(REG_RX1_MANUAL_LMT_FULL_GAIN, RX_FULL_TBL_IDX_MASK, ret); /* Rx1 Full/LMT Gain Index */

    ret = find_table_index(rx2_gain);

    if(ret < 0)
        ret = g_pAD9361Phy->gt_info[band].max_index - 1;

    ad9361_spi_write(REG_RX2_MANUAL_LMT_FULL_GAIN, ret); /* Rx2 Full/LMT Gain Index */

    return 0;
}

/**
 * Setup the external low-noise amplifier (LNA).
 * @param phy The AD9361 state structure.
 * @param ctrl Pointer to eLNA control structure.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_setup_ext_lna(struct ad9361_elna_control* ctrl)
{
    ad9361_spi_writef(REG_EXTERNAL_LNA_CTRL, EXTERNAL_LNA1_CTRL, ctrl->elna_1_control_en);
    ad9361_spi_writef(REG_EXTERNAL_LNA_CTRL, EXTERNAL_LNA2_CTRL, ctrl->elna_2_control_en);

    ad9361_spi_write(REG_EXT_LNA_HIGH_GAIN, EXT_LNA_HIGH_GAIN(ctrl->gain_mdB / 500));

    return ad9361_spi_write(REG_EXT_LNA_LOW_GAIN, EXT_LNA_LOW_GAIN(ctrl->bypass_loss_mdB / 500));
}

/**
 * Set the clock output mode.
 * @param phy The AD9361 state structure.
 * @param mode The clock output mode [].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_clkout_control(enum ad9361_clkout mode)
{
    if(mode == CLKOUT_DISABLE)
        return ad9361_spi_writef(REG_BBPLL, CLKOUT_ENABLE, 0);

    return ad9361_spi_writef(REG_BBPLL, CLKOUT_ENABLE | CLKOUT_SELECT(~0), ((mode - 1) << 1) | 0x1);
}

/**
 * Load the Gm Sub Table.
 * @param phy The AD9361 state structure.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_load_mixer_gm_subtable()
{
    DBGPRINTLN_CTX("Load gm sub table with %"PRIu64" entries", ARRAY_SIZE(gm_st_ctrl));

    ad9361_spi_write(REG_GM_SUB_TABLE_CONFIG, START_GM_SUB_TABLE_CLOCK); /* Start Clock */

    for(uint32_t i = 0, addr = ARRAY_SIZE(gm_st_ctrl); i < ARRAY_SIZE(gm_st_ctrl); i++)
    {
        ad9361_spi_write(REG_GM_SUB_TABLE_ADDRESS, --addr); /* Gain Table Index */
        ad9361_spi_write(REG_GM_SUB_TABLE_BIAS_WRITE, 0); /* Bias */
        ad9361_spi_write(REG_GM_SUB_TABLE_GAIN_WRITE, gm_st_gain[i]); /* Gain */
        ad9361_spi_write(REG_GM_SUB_TABLE_CTRL_WRITE, gm_st_ctrl[i]); /* Control */
        ad9361_spi_write(REG_GM_SUB_TABLE_CONFIG, WRITE_GM_SUB_TABLE | START_GM_SUB_TABLE_CLOCK); /* Write Words */
        ad9361_spi_write(REG_GM_SUB_TABLE_GAIN_READ, 0); /* Dummy Delay */
        ad9361_spi_write(REG_GM_SUB_TABLE_GAIN_READ, 0); /* Dummy Delay */
    }

    ad9361_spi_write(REG_GM_SUB_TABLE_CONFIG, START_GM_SUB_TABLE_CLOCK); /* Clear Write */
    ad9361_spi_write(REG_GM_SUB_TABLE_GAIN_READ, 0); /* Dummy Delay */
    ad9361_spi_write(REG_GM_SUB_TABLE_GAIN_READ, 0); /* Dummy Delay */
    ad9361_spi_write(REG_GM_SUB_TABLE_CONFIG, 0); /* Stop Clock */

    return 0;
}

/**
 * Set the attenuation for the selected TX channels.
 * @param phy The AD9361 state structure.
 * @param atten_mdb Attenuation value [mdB].
 * @param tx1 Set true, the attenuation of the TX1 will be affected.
 * @param tx2 Set true, the attenuation of the TX2 will be affected.
 * @param immed Set true, an immediate update will take place.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_set_tx_atten(uint32_t atten_mdb, bool tx1, bool tx2, bool immed)
{
    uint8_t buf[2];
    int32_t ret = 0;

    DBGPRINTLN_CTX("Set TX attenuation %"PRIu32" mdB, tx1 = %s, tx2 = %s, immed = %s", atten_mdb, tx1 ? "true" : "false", tx2 ? "true" : "false", immed ? "true" : "false");

    if(atten_mdb > MAX_TX_ATTENUATION_DB) /* 89.75 dB */
        return -EINVAL;

    atten_mdb /= 250; /* Scale to 0.25dB / LSB */

    buf[0] = atten_mdb >> 8;
    buf[1] = atten_mdb & 0xFF;

    ad9361_spi_writef(REG_TX2_DIG_ATTEN, IMMEDIATELY_UPDATE_TPC_ATTEN, 0);

    if(tx1)
        ret = ad9361_spi_writem(REG_TX1_ATTEN_1, buf, 2);

    if(tx2)
        ret = ad9361_spi_writem(REG_TX2_ATTEN_1, buf, 2);

    if(immed)
        ad9361_spi_writef(REG_TX2_DIG_ATTEN, IMMEDIATELY_UPDATE_TPC_ATTEN, 1);

    return ret;
}

/**
 * Get the attenuation for the selected TX channel.
 * @param phy The AD9361 state structure.
 * @param tx_num The selected channel [1, 2].
 * @return The attenuation value [mdB] or negative error code in case of failure.
 */
int32_t ad9361_get_tx_atten(uint32_t tx_num)
{
    uint8_t buf[2];
    int32_t ret = 0;
    uint32_t code;

    ret = ad9361_spi_readm((tx_num == 1) ? REG_TX1_ATTEN_1 : REG_TX2_ATTEN_1, buf, 2);

    if(ret < 0)
        return ret;

    code = (buf[0] << 8) | buf[1];
    code *= 250;

    return code;
}

/**
 * Mute TX.
 * @param phy The AD9361 state structure.
 * @param mute true to mute, false to unmute.
 * @return 0 in case of success
 */
int32_t ad9361_tx_mute(bool mute)
{
    int32_t ret;

    if(mute)
    {
        g_pAD9361Phy->tx1_atten_cached = ad9361_get_tx_atten(1);
        g_pAD9361Phy->tx2_atten_cached = ad9361_get_tx_atten(2);

        return ad9361_set_tx_atten(MAX_TX_ATTENUATION_DB, true, true, true);
    }
    else
    {
        if(g_pAD9361Phy->tx1_atten_cached == g_pAD9361Phy->tx2_atten_cached)
            return ad9361_set_tx_atten(g_pAD9361Phy->tx1_atten_cached, true, true, true);

        ret = ad9361_set_tx_atten(g_pAD9361Phy->tx1_atten_cached, true, false, true);
        ret |= ad9361_set_tx_atten(g_pAD9361Phy->tx2_atten_cached, false, true, true);

        return ret;
    }
}

/**
 * Choose the right RF VCO table index for the selected frequency.
 * @param freq The frequency value [Hz].
 * @return The index from the RF VCO table.
 */
static uint32_t ad9361_rfvco_tableindex(uint32_t freq)
{
    if(freq < 50000000UL)
        return LUT_FTDD_40;

    if(freq <= 70000000UL)
        return LUT_FTDD_60;

    return LUT_FTDD_80;
}

/**
 * Initialize the RFPLL VCO.
 * @param phy The AD9361 state structure.
 * @param tx Set true for TX_RFPLL.
 * @param vco_freq The VCO frequency [Hz].
 * @param ref_clk The reference clock frequency [Hz].
 * @return 0 in case of success
 */
static int32_t ad9361_rfpll_vco_init(bool tx, uint64_t vco_freq, uint32_t ref_clk)
{
    const struct ad9361_synth_lut(*tab);
    int32_t i = 0;
    uint32_t range, offs = 0;

    range = ad9361_rfvco_tableindex(ref_clk);

    DBGPRINTLN_CTX("RFPLL VCO init for %"PRIu64" Hz, ref_clk %"PRIu32" Hz, range %"PRIu32, vco_freq, ref_clk, range);

    utils_do_div(&vco_freq, 1000000UL); /* vco_freq in MHz */

    if((g_pAD9361Phy->pdata->fdd && !g_pAD9361Phy->pdata->fdd_independent_mode) && (g_pAD9361Phy->current_tx_lo_freq != g_pAD9361Phy->current_rx_lo_freq))
    {
        tab = &SynthLUT_FDD[range][0];

        if(tx)
            g_pAD9361Phy->current_tx_use_tdd_table = false;
        else
            g_pAD9361Phy->current_rx_use_tdd_table = false;
    }
    else
    {
        tab = &SynthLUT_TDD[range][0];

        if(tx)
            g_pAD9361Phy->current_tx_use_tdd_table = true;
        else
            g_pAD9361Phy->current_rx_use_tdd_table = true;
    }

    if(tx)
        offs = REG_TX_VCO_OUTPUT - REG_RX_VCO_OUTPUT;

    while(i < SYNTH_LUT_SIZE && tab[i].VCO_MHz > vco_freq)
        i++;

    DBGPRINTLN_CTX("Using VCO table index %"PRId32" for %"PRIu32" MHz", i, tab[i].VCO_MHz);

    ad9361_spi_write(REG_RX_VCO_OUTPUT + offs, VCO_OUTPUT_LEVEL(tab[i].VCO_Output_Level) | PORB_VCO_LOGIC);
    ad9361_spi_writef(REG_RX_ALC_VARACTOR + offs, VCO_VARACTOR(~0), tab[i].VCO_Varactor);
    ad9361_spi_write(REG_RX_VCO_BIAS_1 + offs, VCO_BIAS_REF(tab[i].VCO_Bias_Ref) | VCO_BIAS_TCF(tab[i].VCO_Bias_Tcf));

    ad9361_spi_write(REG_RX_FORCE_VCO_TUNE_1 + offs, VCO_CAL_OFFSET(tab[i].VCO_Cal_Offset));
    ad9361_spi_write(REG_RX_VCO_VARACTOR_CTRL_1 + offs, VCO_VARACTOR_REFERENCE(tab[i].VCO_Varactor_Reference));

    ad9361_spi_write(REG_RX_VCO_CAL_REF + offs, VCO_CAL_REF_TCF(0));

    ad9361_spi_write(REG_RX_VCO_VARACTOR_CTRL_0 + offs, VCO_VARACTOR_OFFSET(0) | VCO_VARACTOR_REFERENCE_TCF(7));

    ad9361_spi_writef(REG_RX_CP_CURRENT + offs, CHARGE_PUMP_CURRENT(~0), tab[i].Charge_Pump_Current);
    ad9361_spi_write(REG_RX_LOOP_FILTER_1 + offs, LOOP_FILTER_C2(tab[i].LF_C2) | LOOP_FILTER_C1(tab[i].LF_C1));
    ad9361_spi_write(REG_RX_LOOP_FILTER_2 + offs, LOOP_FILTER_R1(tab[i].LF_R1) | LOOP_FILTER_C3(tab[i].LF_C3));
    ad9361_spi_write(REG_RX_LOOP_FILTER_3 + offs, LOOP_FILTER_R3(tab[i].LF_R3));

    return 0;
}

/**
 * Get the current gain in Split Gain Table Mode
 * @param phy The AD9361 state structure.
 * @param idx_reg Register base address for the selected receiver
 * @param rx_gain  A rf_rx_gain struct to store the RF gain.
 * @return 0 in case of success,
 */
static int32_t ad9361_get_split_table_gain(uint32_t idx_reg, struct ad9361_rf_rx_gain* rx_gain)
{
    uint32_t val, tbl_addr;
    int32_t rc = 0;

    rx_gain->fgt_lmt_index = ad9361_spi_readf(idx_reg, FULL_TABLE_GAIN_INDEX(~0));
    tbl_addr = ad9361_spi_read(REG_GAIN_TABLE_ADDRESS);

    ad9361_spi_write(REG_GAIN_TABLE_ADDRESS, rx_gain->fgt_lmt_index);

    val = ad9361_spi_read(REG_GAIN_TABLE_READ_DATA1);
    rx_gain->lna_index = TO_LNA_GAIN(val);
    rx_gain->mixer_index = TO_MIXER_GM_GAIN(val);

    rx_gain->tia_index = ad9361_spi_readf(REG_GAIN_TABLE_READ_DATA2, TIA_GAIN);

    rx_gain->lmt_gain = lna_table[ad9361_gt() - RXGAIN_TBLS_END][rx_gain->lna_index] + mixer_table[ad9361_gt() - RXGAIN_TBLS_END][rx_gain->mixer_index] + tia_table[rx_gain->tia_index];

    ad9361_spi_write(REG_GAIN_TABLE_ADDRESS, tbl_addr);

    /* Read LPF Index */
    rx_gain->lpf_gain = ad9361_spi_readf(idx_reg + 1, LPF_GAIN_RX(~0));

    /* Read Digital Gain */
    rx_gain->digital_gain = ad9361_spi_readf(idx_reg + 2, DIGITAL_GAIN_RX(~0));

    rx_gain->gain_db = rx_gain->lmt_gain + rx_gain->lpf_gain + rx_gain->digital_gain;

    return rc;
}

/**
 * Get the current gain in Full Gain Table Mode
 * @param phy The AD9361 state structure.
 * @param idx_reg Register base address for the selected receiver
 * @param rx_gain A rf_rx_gain struct to store the RF gain.
 * @return 0 in case of success
 */
static int32_t ad9361_get_full_table_gain(uint32_t idx_reg, struct ad9361_rf_rx_gain* rx_gain)
{
    uint32_t val;

    rx_gain->fgt_lmt_index = val = ad9361_spi_readf(idx_reg, FULL_TABLE_GAIN_INDEX(~0));
    /* Read Digital Gain */
    rx_gain->digital_gain = ad9361_spi_readf(idx_reg + 2, DIGITAL_GAIN_RX(~0));

    rx_gain->gain_db = g_pAD9361Phy->gt_info[ad9361_gt()].abs_gain_tbl[val];

    return 0;
}

/**
 * Get current RX gain for the selected channel.
 * @param phy The AD9361 state structure.
 * @param rx_id The desired channel number (0, 1).
 * @param rx_gain A rf_rx_gain struct to store the RF gain.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_get_rx_gain(uint32_t rx_id, struct ad9361_rf_rx_gain* rx_gain)
{
    uint32_t val, idx_reg;
    uint8_t gain_ctl_shift, rx_enable_mask;
    uint8_t fast_atk_shift;
    int32_t rc = 0;

    if(rx_id == 1)
    {
        gain_ctl_shift = RX1_GAIN_CTRL_SHIFT;
        idx_reg = REG_GAIN_RX1;
        rx_enable_mask = RX_CHANNEL_ENABLE(RX_1);
        fast_atk_shift = RX1_FAST_ATK_SHIFT;

    }
    else if(rx_id == 2)
    {
        gain_ctl_shift = RX2_GAIN_CTRL_SHIFT;
        idx_reg = REG_GAIN_RX2;
        rx_enable_mask = RX_CHANNEL_ENABLE(RX_2);
        fast_atk_shift = RX2_FAST_ATK_SHIFT;
    }
    else
    {
        DBGPRINTLN_CTX("Unknown Rx path %"PRIu32, rx_id);

        return -EINVAL;
    }

    val = ad9361_spi_readf(REG_RX_ENABLE_FILTER_CTRL, rx_enable_mask);

    if(!val)
    {
        DBGPRINTLN_CTX("Rx%"PRIu32" is not enabled", rx_id);

        return -EAGAIN;
    }

    val = ad9361_spi_read(REG_AGC_CONFIG_1);

    val = (val >> gain_ctl_shift) & RX_GAIN_CTL_MASK;

    if(val == RX_GAIN_CTL_AGC_FAST_ATK)
    {
        /* In fast attack mode check whether Fast attack state machine
        * has locked gain, if not then we can not read gain.
        */
        val = ad9361_spi_read(REG_FAST_ATTACK_STATE);
        val = (val >> fast_atk_shift) & FAST_ATK_MASK;

        if(val != FAST_ATK_GAIN_LOCKED)
        {
            DBGPRINTLN_CTX("Rx%"PRIu32" gain is not locked, state m/c at %"PRIx32, rx_id, val);

            return -EAGAIN;
        }
    }

    if(g_pAD9361Phy->pdata->split_gt)
        rc = ad9361_get_split_table_gain(idx_reg, rx_gain);
    else
        rc = ad9361_get_full_table_gain(idx_reg, rx_gain);

    return rc;
}

/**
 * Get Enable State Machine (ENSM) state.
 * @param phy The AD9361 state structure.
 * @return The state.
 */
uint8_t ad9361_ensm_get_state()
{
    return ad9361_spi_readf(REG_STATE, ENSM_STATE(~0));
}

/**
 * Force Enable State Machine (ENSM) to the desired state (internally used only).
 * @param phy The AD9361 state structure.
 * @param ensm_state The ENSM state [ENSM_STATE_SLEEP_WAIT, ENSM_STATE_ALERT,
 *                   ENSM_STATE_TX, ENSM_STATE_TX_FLUSH, ENSM_STATE_RX,
 *                   ENSM_STATE_RX_FLUSH, ENSM_STATE_FDD, ENSM_STATE_FDD_FLUSH].
 * @return None.
 */
void ad9361_ensm_force_state(uint8_t ensm_state)
{
    uint8_t dev_ensm_state;
    int32_t rc, timeout = 10;
    uint32_t val;

    dev_ensm_state = ad9361_spi_readf(REG_STATE, ENSM_STATE(~0));

    g_pAD9361Phy->prev_ensm_state = dev_ensm_state;

    if(dev_ensm_state == ensm_state)
    {
        DBGPRINTLN_CTX("Nothing to do, device ENSM is already in state %s (0x%X)", ad9361_ensm_states[ensm_state], ensm_state);

        return;
    }

    DBGPRINTLN_CTX("Force device ENSM from %s (0x%X) to %s (0x%X)", ad9361_ensm_states[dev_ensm_state], dev_ensm_state, ad9361_ensm_states[ensm_state], ensm_state);

    val = ad9361_spi_read(REG_ENSM_CONFIG_1);

    /* Enable control through SPI writes, and take out from
    * Alert
    */
    if(val & ENABLE_ENSM_PIN_CTRL)
    {
        val &= ~ENABLE_ENSM_PIN_CTRL;
        g_pAD9361Phy->ensm_pin_ctl_en = true;
    }
    else
    {
        g_pAD9361Phy->ensm_pin_ctl_en = false;
    }

    if(dev_ensm_state)
        val &= ~(TO_ALERT);

    switch(ensm_state)
    {
        case ENSM_STATE_TX:
        case ENSM_STATE_FDD:
            val |= FORCE_TX_ON;
        break;
        case ENSM_STATE_RX:
            val |= FORCE_RX_ON;
        break;
        case ENSM_STATE_ALERT:
            val &= ~(FORCE_TX_ON | FORCE_RX_ON);
            val |= TO_ALERT | FORCE_ALERT_STATE;
        break;
        default:
            DBGPRINTLN_CTX("No handling for forcing ENSM state %s (0x%X)", ad9361_ensm_states[ensm_state], ensm_state);

            return;
        break;
    }

    ad9361_spi_write(REG_ENSM_CONFIG_1, TO_ALERT | FORCE_ALERT_STATE);

    rc = ad9361_spi_write(REG_ENSM_CONFIG_1, val);

    if(rc)
    {
        DBGPRINTLN_CTX("Failed to write ENSM_CONFIG_1");

        return;
    }

    while(ad9361_ensm_get_state() != ensm_state && --timeout)
        usleep(1000);

    if(timeout == 0)
        DBGPRINTLN_CTX("Timeout waiting for ENSM state %s (0x%X)", ad9361_ensm_states[ensm_state], ensm_state);
}

/**
 * Restore an Enable State Machine (ENSM) state.
 * @param phy The AD9361 state structure.
 * @param ensm_state The state.
 * @return None.
 */
void ad9361_ensm_restore_state(uint8_t ensm_state)
{
    int32_t rc;
    uint32_t val;

    val = ad9361_spi_read(REG_ENSM_CONFIG_1);

    /* We are restoring state only, so clear State bits first
    * which might have set while forcing a particular state
    */
    val &= ~(FORCE_TX_ON | FORCE_RX_ON | FORCE_ALERT_STATE);
    val |= TO_ALERT;

    switch(ensm_state)
    {
        case ENSM_STATE_TX:
        case ENSM_STATE_FDD:
            val |= FORCE_TX_ON;
        break;
        case ENSM_STATE_RX:
            val |= FORCE_RX_ON;
        break;
        case ENSM_STATE_ALERT:
            val |= TO_ALERT;
        break;
        case ENSM_STATE_INVALID:
            DBGPRINTLN_CTX("No need to restore, ENSM state wasn't saved");

            return;
        break;
        default:
            DBGPRINTLN_CTX("No handling for restoring ENSM state %s (0x%X)", ad9361_ensm_states[ensm_state], ensm_state);

            return;
        break;
    }

    ad9361_spi_write(REG_ENSM_CONFIG_1, TO_ALERT | FORCE_ALERT_STATE);

    rc = ad9361_spi_write(REG_ENSM_CONFIG_1, val);

    if(rc)
    {
        DBGPRINTLN_CTX("Failed to write ENSM_CONFIG_1");

        return;
    }

    if(g_pAD9361Phy->ensm_pin_ctl_en)
    {
        val |= ENABLE_ENSM_PIN_CTRL;

        rc = ad9361_spi_write(REG_ENSM_CONFIG_1, val);

        if(rc)
            DBGPRINTLN_CTX("Failed to write ENSM_CONFIG_1");
    }

    DBGPRINTLN_CTX("Device ENSM restored to %s (0x%X)", ad9361_ensm_states[ensm_state], ensm_state);
}

/**
 * Restore the previous Enable State Machine (ENSM) state.
 * @param phy The AD9361 state structure.
 * @return None.
 */
void ad9361_ensm_restore_prev_state()
{
    return ad9361_ensm_restore_state(g_pAD9361Phy->prev_ensm_state);
}

/**
 * Set gain in Split Gain Table Mode (used only in Manual Gain Control Mode).
 * @param phy The AD9361 state structure.
 * @param idx_reg Register base address for the selected receiver
 * @param rx_gain The rf_rx_gain struct containing the RF gain.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t set_split_table_gain(uint32_t idx_reg, struct ad9361_rf_rx_gain* rx_gain)
{
    int32_t rc = 0;

    if((rx_gain->fgt_lmt_index > MAX_LMT_INDEX) || (rx_gain->lpf_gain > MAX_LPF_GAIN) || (rx_gain->digital_gain > MAX_DIG_GAIN))
    {
        DBGPRINTLN_CTX("LMT_INDEX %"PRIu32" (> %"PRIu32"), LPF_GAIN %"PRIu32" (> %"PRIu32"), DIGITAL_GAIN %"PRIu32" (> %"PRIu32")", rx_gain->fgt_lmt_index, MAX_LMT_INDEX, rx_gain->lpf_gain, MAX_LPF_GAIN, rx_gain->digital_gain, MAX_DIG_GAIN);

        return -EINVAL;
    }

    rc = find_table_index(rx_gain->gain_db);

    if(rc < 0)
    {
        DBGPRINTLN_CTX("Invalid gain %"PRId32", supported range [%d - %d]", rx_gain->gain_db, g_pAD9361Phy->gt_info[ad9361_gt()].abs_gain_tbl[0], g_pAD9361Phy->gt_info[ad9361_gt()].abs_gain_tbl[g_pAD9361Phy->gt_info[ad9361_gt()].max_index - 1]);

        return rc;
    }

    rx_gain->fgt_lmt_index = rc;

    rc = ad9361_spi_writef(idx_reg, RX_FULL_TBL_IDX_MASK, rx_gain->fgt_lmt_index);

    if(rc < 0)
        return rc;

    rc = ad9361_spi_writef(idx_reg + 1, RX_LPF_IDX_MASK, rx_gain->lpf_gain);

    if(rc < 0)
        return rc;

    if(g_pAD9361Phy->pdata->gain_ctrl.dig_gain_en)
        rc = ad9361_spi_writef(idx_reg + 2, RX_DIGITAL_IDX_MASK, rx_gain->digital_gain);
    else if(rx_gain->digital_gain > 0)
        DBGPRINTLN_CTX("Digital gain is disabled and cannot be set (%"PRIu32")", rx_gain->digital_gain);

    return rc;
}

/**
 * Set gain in Full Gain Table Mode (used only in Manual Gain Control Mode).
 * @param phy The AD9361 state structure.
 * @param idx_reg Register base address for the selected receiver
 * @param rx_gain The rf_rx_gain struct containing the RF gain.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t set_full_table_gain(uint32_t idx_reg, struct ad9361_rf_rx_gain* rx_gain)
{
    int rc = 0;

    if(rx_gain->fgt_lmt_index != ((uint32_t)~0) || rx_gain->lpf_gain != ((uint32_t)~0) || rx_gain->digital_gain > 0)
        DBGPRINTLN_CTX("Ignoring LMT/LPF/DIGITAL gains in Single Table mode");

    rc = find_table_index(rx_gain->gain_db);

    if(rc < 0)
    {
        DBGPRINTLN_CTX("Invalid gain %"PRId32", supported range [%d - %d]", rx_gain->gain_db, g_pAD9361Phy->gt_info[ad9361_gt()].abs_gain_tbl[0], g_pAD9361Phy->gt_info[ad9361_gt()].abs_gain_tbl[g_pAD9361Phy->gt_info[ad9361_gt()].max_index - 1]);

        return rc;
    }

    rc = ad9361_spi_writef(idx_reg, RX_FULL_TBL_IDX_MASK, rc);

    return rc;
}

/**
 * Set the RX gain for the selected channel.
 * @param phy The AD9361 state structure.
 * @param rx_id The desired channel number (0, 1).
 * @param rx_gain The rf_rx_gain struct containing the RF gain.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_set_rx_gain(uint32_t rx_id, struct ad9361_rf_rx_gain* rx_gain)
{
    uint32_t val, idx_reg;
    uint8_t gain_ctl_shift;
    int32_t rc = 0;

    if(rx_id == 1)
    {
        gain_ctl_shift = RX1_GAIN_CTRL_SHIFT;
        idx_reg = REG_RX1_MANUAL_LMT_FULL_GAIN;
    }
    else if(rx_id == 2)
    {
        gain_ctl_shift = RX2_GAIN_CTRL_SHIFT;
        idx_reg = REG_RX2_MANUAL_LMT_FULL_GAIN;
    }
    else
    {
        DBGPRINTLN_CTX("Unknown Rx path %"PRIu32, rx_id);

        return -EINVAL;
    }

    val = ad9361_spi_read(REG_AGC_CONFIG_1);
    val = (val >> gain_ctl_shift) & RX_GAIN_CTL_MASK;

    if(val != RX_GAIN_CTL_MGC)
    {
        DBGPRINTLN_CTX("Rx gain can be set in MGC mode only");

        return -EOPNOTSUPP;
    }

    if(g_pAD9361Phy->pdata->split_gt)
        rc = set_split_table_gain(idx_reg, rx_gain);
    else
        rc = set_full_table_gain(idx_reg, rx_gain);

    if(rc < 0)
        DBGPRINTLN_CTX("Unable to writ Rx%"PRIu32" gain table %"PRIX32, rx_id, idx_reg);

    return rc;

}

/**
 * Update the Gain Control.
 * @param phy The AD9361 state structure.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_gc_update()
{
    uint32_t clkrf;
    uint32_t reg, delay_lna, settling_delay, dec_pow_meas_dur;
    int32_t ret;
    uint32_t fir_div;

    clkrf = ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[CLKRF_CLK]);
    delay_lna = g_pAD9361Phy->pdata->elna_ctrl.settling_delay_ns;

    /*
     * AGC Attack Delay (us)=ceiling((((0.2+Delay_LNA)*ClkRF+14))/(2*ClkRF))+1
     * ClkRF in MHz, delay in us
     */

    reg = (200 + delay_lna) / 2 + (14000000UL / (clkrf / 500U));
    reg = DIV_CEIL(reg, 1000UL) + g_pAD9361Phy->pdata->gain_ctrl.agc_attack_delay_extra_margin_us;
    reg = CLAMP_T(uint8_t, reg, 0U, 31U);
    ret = ad9361_spi_writef(REG_AGC_ATTACK_DELAY, AGC_ATTACK_DELAY(~0), reg);

    /*
     * Peak Overload Wait Time (ClkRF cycles)=ceiling((0.1+Delay_LNA) *clkRF+1)
     */

    reg = (delay_lna + 100UL) * (clkrf / 1000UL);
    reg = DIV_CEIL(reg, 1000000UL) + 1;
    reg = CLAMP_T(uint8_t, reg, 0U, 31U);
    ret |= ad9361_spi_writef(REG_PEAK_WAIT_TIME, PEAK_OVERLOAD_WAIT_TIME(~0), reg);

    /*
     * Settling Delay in 0x111.  Applies to all gain control modes:
     * 0x111[D4:D0]= ceiling(((0.2+Delay_LNA)*clkRF
     */

    reg = (delay_lna + 200UL) * (clkrf / 2000UL);
    reg = DIV_CEIL(reg, 1000000UL) + 7;
    reg = settling_delay = CLAMP_T(uint8_t, reg, 0U, 31U);
    ret |= ad9361_spi_writef(REG_FAST_CONFIG_2_SETTLING_DELAY, SETTLING_DELAY(~0), reg);

    /*
     * Gain Update Counter [15:0]= round((((time*ClkRF-0x111[D4:D0]*2)-2))/2)
     */
    reg = g_pAD9361Phy->pdata->gain_ctrl.gain_update_interval_us * (clkrf / 1000UL) - settling_delay * 2000UL - 2000UL;

    reg = DIV_ROUND(reg, 2000UL);
    reg = CLAMP_T(uint32_t, reg, 0U, 131071UL);

    if(g_pAD9361Phy->agc_mode[0] == RF_GAIN_FASTATTACK_AGC || g_pAD9361Phy->agc_mode[1] == RF_GAIN_FASTATTACK_AGC)
    {
        dec_pow_meas_dur = g_pAD9361Phy->pdata->gain_ctrl.f_agc_dec_pow_measuremnt_duration;
    }
    else
    {
        fir_div = DIV_ROUND(clkrf, ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[RX_SAMPL_CLK]));
        dec_pow_meas_dur = g_pAD9361Phy->pdata->gain_ctrl.dec_pow_measuremnt_duration;

        if(((reg * 2 / fir_div) / dec_pow_meas_dur) < 2)
            dec_pow_meas_dur = reg / fir_div;
    }

    /* Power Measurement Duration */
    ad9361_spi_writef(REG_DEC_POWER_MEASURE_DURATION_0, DEC_POWER_MEASUREMENT_DURATION(~0), utils_ilog2(dec_pow_meas_dur / 16));

    ret |= ad9361_spi_writef(REG_DIGITAL_SAT_COUNTER, DOUBLE_GAIN_COUNTER, reg > 65535);

    if(reg > 65535)
        reg /= 2;

    ret |= ad9361_spi_write(REG_GAIN_UPDATE_COUNTER1, reg & 0xFF);
    ret |= ad9361_spi_write(REG_GAIN_UPDATE_COUNTER2, reg >> 8);

    /*
     * Fast AGC State Wait Time - Energy Detect Count
     */

    reg = DIV_ROUND(g_pAD9361Phy->pdata->gain_ctrl.f_agc_state_wait_time_ns * (clkrf / 1000UL), 1000000UL);
    reg = CLAMP_T(uint32_t, reg, 0U, 31U);
    ret |= ad9361_spi_writef(REG_FAST_ENERGY_DETECT_COUNT, ENERGY_DETECT_COUNT(~0), reg);

    return ret;
}

/**
 * Set the gain control mode.
 * @param phy The AD9361 state structure.
 * @param gain_ctrl A ad9361_rf_gain_ctrl struct that contains the the desired
 *        channel information and the gain control mode.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_set_gain_ctrl_mode(struct ad9361_rf_gain_ctrl* gain_ctrl)
{
    int32_t rc = 0;
    uint32_t gain_ctl_shift, mode;
    uint8_t val;

    rc = ad9361_spi_readm(REG_AGC_CONFIG_1, &val, 1);

    if(rc < 0)
    {
        DBGPRINTLN_CTX("Unable to read AGC_CONFIG_1 register (%"PRIX32")", REG_AGC_CONFIG_1);

        return rc;
    }

    switch(gain_ctrl->mode)
    {
        case RF_GAIN_MGC:
            mode = RX_GAIN_CTL_MGC;
        break;
        case RF_GAIN_FASTATTACK_AGC:
            mode = RX_GAIN_CTL_AGC_FAST_ATK;
        break;
        case RF_GAIN_SLOWATTACK_AGC:
            mode = RX_GAIN_CTL_AGC_SLOW_ATK;
        break;
        case RF_GAIN_HYBRID_AGC:
            mode = RX_GAIN_CTL_AGC_SLOW_ATK_HYBD;
        break;
        default:
            return -EINVAL;
        break;
    }

    if(gain_ctrl->ant == 1)
    {
        gain_ctl_shift = RX1_GAIN_CTRL_SHIFT;
    }
    else if(gain_ctrl->ant == 2)
    {
        gain_ctl_shift = RX2_GAIN_CTRL_SHIFT;
    }
    else
    {
        DBGPRINTLN_CTX("Unknown Rx path %"PRIu32, gain_ctrl->ant);

        return -EINVAL;
    }

    rc = ad9361_en_dis_rx(gain_ctrl->ant, RX_DISABLE);

    if(rc < 0)
    {
        DBGPRINTLN_CTX("Unable to disable Rx%"PRIu32, gain_ctrl->ant);

        return rc;
    }

    val &= ~(RX_GAIN_CTL_MASK << gain_ctl_shift);
    val |= mode << gain_ctl_shift;

    if(mode == RX_GAIN_CTL_AGC_SLOW_ATK_HYBD)
        val |= SLOW_ATTACK_HYBRID_MODE;
    else
        val &= ~SLOW_ATTACK_HYBRID_MODE;

    rc = ad9361_spi_write(REG_AGC_CONFIG_1, val);

    if(rc < 0)
    {
        DBGPRINTLN_CTX("Unable to write AGC_CONFIG_1 register (%"PRIX32")", REG_AGC_CONFIG_1);

        return rc;
    }

    ad9361_en_dis_rx(gain_ctrl->ant, RX_ENABLE);

    rc = ad9361_gc_update();

    return rc;
}

/**
 * Get the RSSI.
 * @param phy The AD9361 state structure.
 * @param rssi A rf_rssi struct to store the RSSI.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_read_rssi(struct ad9361_rf_rssi* rssi)
{
    uint8_t reg_val_buf[6];
    int32_t rc;

    rc = ad9361_spi_readm(REG_PREAMBLE_LSB, reg_val_buf, ARRAY_SIZE(reg_val_buf));

    if(rssi->ant == 1)
    {
        rssi->symbol = RSSI_RESOLUTION * ((reg_val_buf[5] << RSSI_LSB_SHIFT) + (reg_val_buf[1] & RSSI_LSB_MASK1));
        rssi->preamble = RSSI_RESOLUTION * ((reg_val_buf[4] << RSSI_LSB_SHIFT) + (reg_val_buf[0] & RSSI_LSB_MASK1));
    }
    else if(rssi->ant == 2)
    {
        rssi->symbol = RSSI_RESOLUTION * ((reg_val_buf[3] << RSSI_LSB_SHIFT) + ((reg_val_buf[1] & RSSI_LSB_MASK2) >> 1));
        rssi->preamble = RSSI_RESOLUTION * ((reg_val_buf[2] << RSSI_LSB_SHIFT) + ((reg_val_buf[0] & RSSI_LSB_MASK2) >> 1));
    }
    else
    {
        rc = -EFAULT;
    }

    rssi->multiplier = RSSI_MULTIPLIER;

    return rc;
}

/**
 * Setup the RX ADC.
 * @param phy The AD9361 state structure.
 * @param bbpll_freq The BBPLL frequency [Hz].
 * @param adc_sampl_freq_Hz The ADC sampling frequency [Hz].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_rx_adc_setup(uint32_t bbpll_freq, uint32_t adc_sampl_freq_Hz)
{
    uint32_t scale_snr_1e3, maxsnr, sqrt_inv_rc_tconst_1e3, tmp_1e3, scaled_adc_clk_1e6, inv_scaled_adc_clk_1e3, sqrt_term_1e3, min_sqrt_term_1e3, bb_bw_Hz;
    uint64_t tmp, invrc_tconst_1e6;
    uint8_t data[40];
    int32_t ret;

    uint8_t c3_msb = ad9361_spi_read(REG_RX_BBF_C3_MSB);
    uint8_t c3_lsb = ad9361_spi_read(REG_RX_BBF_C3_LSB);
    uint8_t r2346 = ad9361_spi_read(REG_RX_BBF_R2346);

    /*
    * BBBW = (BBPLL / RxTuneDiv) * ln(2) / (1.4 * 2PI )
    * We assume ad9361_rx_bb_analog_filter_calib() is always run prior
    */

    tmp = bbpll_freq * 10000ULL;
    utils_do_div(&tmp, 126906UL * g_pAD9361Phy->rxbbf_div);
    bb_bw_Hz = tmp;

    DBGPRINTLN_CTX("BBBW: %"PRIu32" Hz, ADCfreq: %"PRIu32" Hz", bb_bw_Hz, adc_sampl_freq_Hz);
    DBGPRINTLN_CTX("c3_msb: 0x%X, c3_lsb: 0x%X, r2346: 0x%X", c3_msb, c3_lsb, r2346);

    bb_bw_Hz = CLAMP(bb_bw_Hz, 200000UL, 28000000UL);

    if(adc_sampl_freq_Hz < 80000000)
        scale_snr_1e3 = 1000;
    else
        scale_snr_1e3 = 1585; /* pow(10, scale_snr_dB/10); */

    if(bb_bw_Hz >= 18000000)
    {
        invrc_tconst_1e6 = (160975ULL * r2346 * (160 * c3_msb + 10 * c3_lsb + 140) * (bb_bw_Hz) * (1000 + (10 * (bb_bw_Hz - 18000000) / 1000000)));

        utils_do_div(&invrc_tconst_1e6, 1000UL);
    }
    else
    {
        invrc_tconst_1e6 = (160975ULL * r2346 * (160 * c3_msb + 10 * c3_lsb + 140) * (bb_bw_Hz));
    }

    utils_do_div(&invrc_tconst_1e6, 1000000000UL);

    if(invrc_tconst_1e6 > ULONG_MAX)
        DBGPRINTLN_CTX("invrc_tconst_1e6 > ULONG_MAX");

    sqrt_inv_rc_tconst_1e3 = utils_int_sqrt((uint32_t)invrc_tconst_1e6);
    maxsnr = 640 / 160;
    scaled_adc_clk_1e6 = DIV_ROUND(adc_sampl_freq_Hz, 640);
    inv_scaled_adc_clk_1e3 = DIV_ROUND(640000000, DIV_ROUND(adc_sampl_freq_Hz, 1000));
    tmp_1e3 = DIV_ROUND(980000 + 20 * MAX_T(uint32_t, 1000U, DIV_ROUND(inv_scaled_adc_clk_1e3, maxsnr)), 1000);
    sqrt_term_1e3 = utils_int_sqrt(scaled_adc_clk_1e6);
    min_sqrt_term_1e3 = MIN_T(uint32_t, 1000U, utils_int_sqrt(maxsnr * scaled_adc_clk_1e6));

    DBGPRINTLN_CTX("invrc_tconst_1e6: %"PRIu64", sqrt_inv_rc_tconst_1e3: %"PRIu32, invrc_tconst_1e6, sqrt_inv_rc_tconst_1e3);
    DBGPRINTLN_CTX("scaled_adc_clk_1e6: %"PRIu32", inv_scaled_adc_clk_1e3: %"PRIu32, scaled_adc_clk_1e6, inv_scaled_adc_clk_1e3);
    DBGPRINTLN_CTX("tmp_1e3: %"PRIu32", sqrt_term_1e3: %"PRIu32", min_sqrt_term_1e3: %"PRIu32, tmp_1e3, sqrt_term_1e3, min_sqrt_term_1e3);

    data[0] = 0;
    data[1] = 0;
    data[2] = 0;
    data[3] = 0x24;
    data[4] = 0x24;
    data[5] = 0;
    data[6] = 0;

    tmp = -50000000 + 8ULL * scale_snr_1e3 * sqrt_inv_rc_tconst_1e3 * min_sqrt_term_1e3;
    utils_do_div(&tmp, 100000000UL);
    data[7] = MIN_T(uint64_t, 124U, tmp);

    tmp = (invrc_tconst_1e6 >> 1) + 20 * inv_scaled_adc_clk_1e3 * data[7] / 80 * 1000ULL;
    utils_do_div(&tmp, invrc_tconst_1e6);
    data[8] = MIN_T(uint64_t, 255U, tmp);

    tmp = (-500000 + 77ULL * sqrt_inv_rc_tconst_1e3 * min_sqrt_term_1e3);
    utils_do_div(&tmp, 1000000UL);
    data[10] = MIN_T(uint64_t, 127U, tmp);

    data[9] = MIN_T(uint32_t, 127U, ((800 * data[10]) / 1000));
    tmp = ((invrc_tconst_1e6 >> 1) + (20 * inv_scaled_adc_clk_1e3 * data[10] * 1000ULL));
    utils_do_div(&tmp, invrc_tconst_1e6 * 77);
    data[11] = MIN_T(uint64_t, 255U, tmp);
    data[12] = MIN_T(uint32_t, 127U, (-500000 + 80 * sqrt_inv_rc_tconst_1e3 * min_sqrt_term_1e3) / 1000000UL);

    tmp = -3 * (long)(invrc_tconst_1e6 >> 1) + inv_scaled_adc_clk_1e3 * data[12] * (1000ULL * 20 / 80);
    utils_do_div(&tmp, invrc_tconst_1e6);
    data[13] = MIN_T(uint64_t, 255, tmp);

    data[14] = 21 * (inv_scaled_adc_clk_1e3 / 10000);
    data[15] = MIN_T(uint32_t, 127U, (500 + 1025 * data[7]) / 1000);
    data[16] = MIN_T(uint32_t, 127U, (data[15] * tmp_1e3) / 1000);
    data[17] = data[15];
    data[18] = MIN_T(uint32_t, 127U, (500 + 975 * data[10]) / 1000);
    data[19] = MIN_T(uint32_t, 127U, (data[18] * tmp_1e3) / 1000);
    data[20] = data[18];
    data[21] = MIN_T(uint32_t, 127U, (500 + 975 * data[12]) / 1000);
    data[22] = MIN_T(uint32_t, 127, (data[21] * tmp_1e3) / 1000);
    data[23] = data[21];
    data[24] = 0x2E;
    data[25] = (128 + MIN_T(uint32_t, 63000U, DIV_ROUND(63 * scaled_adc_clk_1e6, 1000)) / 1000);
    data[26] = MIN_T(uint32_t, 63U, 63 * scaled_adc_clk_1e6 / 1000000 * (920 + 80 * inv_scaled_adc_clk_1e3 / 1000) / 1000);
    data[27] = MIN_T(uint32_t, 63, (32 * sqrt_term_1e3) / 1000);
    data[28] = data[25];
    data[29] = data[26];
    data[30] = data[27];
    data[31] = data[25];
    data[32] = data[26];
    data[33] = MIN_T(uint32_t, 63U, 63 * sqrt_term_1e3 / 1000);
    data[34] = MIN_T(uint32_t, 127U, 64 * sqrt_term_1e3 / 1000);
    data[35] = 0x40;
    data[36] = 0x40;
    data[37] = 0x2C;
    data[38] = 0x00;
    data[39] = 0x00;

    for(uint8_t i = 0; i < 40; i++)
    {
        ret = ad9361_spi_write(0x200 + i, data[i]);

        if(ret < 0)
            return ret;
    }

    return 0;
}

/**
 * Perform a RX TIA calibration.
 * @param phy The AD9361 state structure.
 * @param bb_bw_Hz The baseband bandwidth [Hz].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_rx_tia_calib(uint32_t bb_bw_Hz)
{
    uint32_t Cbbf, R2346;
    uint64_t CTIA_fF;

    uint8_t reg1EB = ad9361_spi_read(REG_RX_BBF_C3_MSB);
    uint8_t reg1EC = ad9361_spi_read(REG_RX_BBF_C3_LSB);
    uint8_t reg1E6 = ad9361_spi_read(REG_RX_BBF_R2346);
    uint8_t reg1DB, reg1DF, reg1DD, reg1DC, reg1DE, temp;

    DBGPRINTLN_CTX("RX TIA calibration, bb_bw_Hz: %"PRIu32" Hz", bb_bw_Hz);

    bb_bw_Hz = CLAMP(bb_bw_Hz, 200000UL, 20000000UL);

    Cbbf = (reg1EB * 160) + (reg1EC * 10) + 140; /* fF */
    R2346 = 18300 * RX_BBF_R2346(reg1E6);

    CTIA_fF = Cbbf * R2346 * 560ULL;
    utils_do_div(&CTIA_fF, 3500000UL);

    if(bb_bw_Hz <= 3000000UL)
        reg1DB = 0xE0;
    else if(bb_bw_Hz <= 10000000UL)
        reg1DB = 0x60;
    else
        reg1DB = 0x20;

    if(CTIA_fF > 2920ULL)
    {
        reg1DC = 0x40;
        reg1DE = 0x40;
        temp = MIN(127U, DIV_ROUND((uint32_t)CTIA_fF - 400, 320U));
        reg1DD = temp;
        reg1DF = temp;
    }
    else
    {
        temp = DIV_ROUND((uint32_t)CTIA_fF - 400, 40U) + 0x40;
        reg1DC = temp;
        reg1DE = temp;
        reg1DD = 0;
        reg1DF = 0;
    }

    ad9361_spi_write(REG_RX_TIA_CONFIG, reg1DB);
    ad9361_spi_write(REG_TIA1_C_LSB, reg1DC);
    ad9361_spi_write(REG_TIA1_C_MSB, reg1DD);
    ad9361_spi_write(REG_TIA2_C_LSB, reg1DE);
    ad9361_spi_write(REG_TIA2_C_MSB, reg1DF);

    return 0;
}

/**
 * Perform a baseband RX analog filter calibration.
 * @param phy The AD9361 state structure.
 * @param rx_bb_bw The baseband bandwidth [Hz].
 * @param bbpll_freq The BBPLL frequency [Hz].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_rx_bb_analog_filter_calib(uint32_t rx_bb_bw, uint32_t bbpll_freq)
{
    uint32_t target;
    uint8_t tmp;
    int32_t ret;

    DBGPRINTLN_CTX("RX Baseband analog filter calibration, rx_bb_bw: %"PRIu32" Hz, bbpll_freq: %"PRIu32" Hz", rx_bb_bw, bbpll_freq);

    rx_bb_bw = CLAMP(rx_bb_bw, 200000UL, 28000000UL);

    /* 1.4 * BBBW * 2PI / ln(2) */
    target = 126906UL * (rx_bb_bw / 10000UL);
    g_pAD9361Phy->rxbbf_div = MIN_T(uint32_t, 511UL, DIV_CEIL(bbpll_freq, target));

    /* Set RX baseband filter divide value */
    ad9361_spi_write(REG_RX_BBF_TUNE_DIVIDE, g_pAD9361Phy->rxbbf_div);
    ad9361_spi_writef(REG_RX_BBF_TUNE_CONFIG, BIT(0), g_pAD9361Phy->rxbbf_div >> 8);

    /* Write the BBBW into registers 0x1FB and 0x1FC */
    ad9361_spi_write(REG_RX_BBBW_MHZ, rx_bb_bw / 1000000UL);

    tmp = DIV_ROUND((rx_bb_bw % 1000000UL) * 128, 1000000UL);
    ad9361_spi_write(REG_RX_BBBW_KHZ, MIN_T(uint8_t, 127, tmp));

    ad9361_spi_write(REG_RX_MIX_LO_CM, RX_MIX_LO_CM(0x3F)); /* Set Rx Mix LO CM */
    ad9361_spi_write(REG_RX_MIX_GM_CONFIG, RX_MIX_GM_PLOAD(3)); /* Set GM common mode */

    /* Enable the RX BBF tune circuit by writing 0x1E2=0x02 and 0x1E3=0x02 */
    ad9361_spi_write(REG_RX1_TUNE_CTRL, RX1_TUNE_RESAMPLE);
    ad9361_spi_write(REG_RX2_TUNE_CTRL, RX2_TUNE_RESAMPLE);

    /* Start the RX Baseband Filter calibration in register 0x016[7] */
    /* Calibration is complete when register 0x016[7] self clears */
    ret = ad9361_run_calibration(RX_BB_TUNE_CAL);

    /* Disable the RX baseband filter tune circuit, write 0x1E2=3, 0x1E3=3 */
    ad9361_spi_write(REG_RX1_TUNE_CTRL, RX1_TUNE_RESAMPLE | RX1_PD_TUNE);
    ad9361_spi_write(REG_RX2_TUNE_CTRL, RX2_TUNE_RESAMPLE | RX2_PD_TUNE);

    return ret;
}

/**
 * Perform a baseband TX analog filter calibration.
 * @param phy The AD9361 state structure.
 * @param tx_bb_bw The baseband bandwidth [Hz].
 * @param bbpll_freq The BBPLL frequency [Hz].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_tx_bb_analog_filter_calib(uint32_t tx_bb_bw, uint32_t bbpll_freq)
{
    uint32_t target, txbbf_div;
    int32_t ret;

    DBGPRINTLN_CTX("TX Baseband analog filter calibration, tx_bb_bw: %"PRIu32" Hz, bbpll_freq: %"PRIu32" Hz", tx_bb_bw, bbpll_freq);

    tx_bb_bw = CLAMP(tx_bb_bw, 625000UL, 20000000UL);

    /* 1.6 * BBBW * 2PI / ln(2) */
    target = 145036 * (tx_bb_bw / 10000UL);
    txbbf_div = MIN_T(uint32_t, 511UL, DIV_CEIL(bbpll_freq, target));

    /* Set TX baseband filter divide value */
    ad9361_spi_write(REG_TX_BBF_TUNE_DIVIDER, txbbf_div);
    ad9361_spi_writef(REG_TX_BBF_TUNE_MODE, TX_BBF_TUNE_DIVIDER, txbbf_div >> 8);

    /* Enable the TX baseband filter tune circuit by setting 0x0CA=0x22. */
    ad9361_spi_write(REG_TX_TUNE_CTRL, TUNER_RESAMPLE | TUNE_CTRL(1));

    /* Start the TX Baseband Filter calibration in register 0x016[6] */
    /* Calibration is complete when register 0x016[] self clears */
    ret = ad9361_run_calibration(TX_BB_TUNE_CAL);

    /* Disable the TX baseband filter tune circuit by writing 0x0CA=0x26. */
    ad9361_spi_write(REG_TX_TUNE_CTRL, TUNER_RESAMPLE | TUNE_CTRL(1) | PD_TUNE);

    return ret;
}

/**
 * Perform a baseband TX secondary filter calibration.
 * @param phy The AD9361 state structure.
 * @param tx_rf_bw The RF bandwidth [Hz].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_tx_bb_second_filter_calib(uint32_t tx_bb_bw)
{
    uint64_t cap;
    uint32_t corner, res = 1, div;
    uint32_t reg_conf, reg_res;
    int32_t ret;

    DBGPRINTLN_CTX("TX Baseband second filter calibration, tx_bb_bw: %"PRIu32" Hz", tx_bb_bw);

    tx_bb_bw = CLAMP(tx_bb_bw, 530000UL, 20000000UL);

    /* BBBW * 5PI */
    corner = 15708 * (tx_bb_bw / 10000UL);

    for(uint8_t i = 0; i < 4; i++)
    {
        div = corner * res;
        cap = (500000000ULL) + (div >> 1);
        utils_do_div(&cap, div);
        cap -= 12ULL;

        if(cap < 64ULL)
            break;

        res <<= 1;
    }

    if(cap > 63ULL)
        cap = 63ULL;

    if(tx_bb_bw <= 4500000UL)
        reg_conf = 0x59;
    else if(tx_bb_bw <= 12000000UL)
        reg_conf = 0x56;
    else
        reg_conf = 0x57;

    switch(res)
    {
        case 1:
            reg_res = 0x0C;
        break;
        case 2:
            reg_res = 0x04;
        break;
        case 4:
            reg_res = 0x03;
        break;
        case 8:
            reg_res = 0x01;
        break;
        default:
            reg_res = 0x01;
        break;
    }

    ret = ad9361_spi_write(REG_CONFIG0, reg_conf);
    ret |= ad9361_spi_write(REG_RESISTOR, reg_res);
    ret |= ad9361_spi_write(REG_CAPACITOR, (uint8_t)cap);

    return ret;
}

/**
 * Perform a RF synthesizer charge pump calibration.
 * @param phy The AD9361 state structure.
 * @param ref_clk_hz The reference clock rate [Hz].
 * @param tx The Synthesizer TX = 1, RX = 0.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_txrx_synth_cp_calib(uint32_t ref_clk_hz, bool tx)
{
    uint32_t offs = tx ? 0x40 : 0;
    uint32_t vco_cal_cnt;

    DBGPRINTLN_CTX("RF Synth charge pump calibration, ref_clk_hz: %"PRIu32" Hz, is_tx: %s", ref_clk_hz, tx ? "true" : "false");

    /* REVIST: */
    ad9361_spi_write(REG_RX_CP_LEVEL_DETECT + offs, 0x17);

    ad9361_spi_write(REG_RX_DSM_SETUP_1 + offs, 0x0);

    ad9361_spi_write(REG_RX_LO_GEN_POWER_MODE + offs, 0x00);
    ad9361_spi_write(REG_RX_VCO_LDO + offs, 0x0B);
    ad9361_spi_write(REG_RX_VCO_PD_OVERRIDES + offs, 0x02);
    ad9361_spi_write(REG_RX_CP_CURRENT + offs, 0x80);
    ad9361_spi_write(REG_RX_CP_CONFIG + offs, CP_OFFSET_OFF);

    /* see Table 70 Example Calibration Times for RF VCO Cal */
    if(g_pAD9361Phy->pdata->fdd)
    {
        vco_cal_cnt = VCO_CAL_EN | VCO_CAL_COUNT(3) | FB_CLOCK_ADV(2);
    }
    else
    {
        if(ref_clk_hz > 40000000UL)
            vco_cal_cnt = VCO_CAL_EN | VCO_CAL_COUNT(1) | FB_CLOCK_ADV(2);
        else
            vco_cal_cnt = VCO_CAL_EN | VCO_CAL_COUNT(0) | FB_CLOCK_ADV(2);
    }

    ad9361_spi_write(REG_RX_VCO_CAL + offs, vco_cal_cnt);

    /* Enable FDD mode during calibrations */

    if(!g_pAD9361Phy->pdata->fdd)
        ad9361_spi_writef(REG_PARALLEL_PORT_CONF_3, HALF_DUPLEX_MODE, 0);

    ad9361_spi_write(REG_ENSM_CONFIG_2, DUAL_SYNTH_MODE);
    ad9361_spi_write(REG_ENSM_CONFIG_1, FORCE_ALERT_STATE | TO_ALERT);
    ad9361_spi_write(REG_ENSM_MODE, FDD_MODE);

    ad9361_spi_write(REG_RX_CP_CONFIG + offs, CP_OFFSET_OFF | CP_CAL_ENABLE);

    return ad9361_check_cal_done(REG_RX_CAL_STATUS + offs, CP_CAL_VALID, 1);
}

/**
 * Perform a baseband DC offset calibration.
 * @param phy The AD9361 state structure.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_bb_dc_offset_calib()
{
    DBGPRINTLN_CTX("Baseband DC Offset calibration");

    ad9361_spi_write(REG_BB_DC_OFFSET_COUNT, 0x3F);
    ad9361_spi_write(REG_BB_DC_OFFSET_SHIFT, BB_DC_M_SHIFT(0xF));
    ad9361_spi_write(REG_BB_DC_OFFSET_ATTEN, BB_DC_OFFSET_ATTEN(1));

    return ad9361_run_calibration(BBDC_CAL);
}

/**
 * Perform a RF DC offset calibration.
 * @param phy The AD9361 state structure.
 * @param ref_clk_hz The RX LO frequency [Hz].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_rf_dc_offset_calib(uint64_t rx_freq)
{
    DBGPRINTLN_CTX("RF DC Offset calibration, rx_freq: %"PRIu64" Hz", rx_freq);

    ad9361_spi_write(REG_WAIT_COUNT, 0x20);

    if(rx_freq <= 4000000000ULL)
    {
        ad9361_spi_write(REG_RF_DC_OFFSET_COUNT, g_pAD9361Phy->pdata->rf_dc_offset_count_low);
        ad9361_spi_write(REG_RF_DC_OFFSET_CONFIG_1, RF_DC_CALIBRATION_COUNT(4) | DAC_FS(2));
        ad9361_spi_write(REG_RF_DC_OFFSET_ATTEN, RF_DC_OFFSET_ATTEN(g_pAD9361Phy->pdata->dc_offset_attenuation_low));
    }
    else
    {
        ad9361_spi_write(REG_RF_DC_OFFSET_COUNT, g_pAD9361Phy->pdata->rf_dc_offset_count_high);
        ad9361_spi_write(REG_RF_DC_OFFSET_CONFIG_1, RF_DC_CALIBRATION_COUNT(4) | DAC_FS(3));
        ad9361_spi_write(REG_RF_DC_OFFSET_ATTEN, RF_DC_OFFSET_ATTEN(g_pAD9361Phy->pdata->dc_offset_attenuation_high));
    }

    ad9361_spi_write(REG_DC_OFFSET_CONFIG2, USE_WAIT_COUNTER_FOR_RF_DC_INIT_CAL | DC_OFFSET_UPDATE(3));

    if(g_pAD9361Phy->pdata->rx1rx2_phase_inversion_en || (g_pAD9361Phy->pdata->port_ctrl.pp_conf[1] & INVERT_RX2))
        ad9361_spi_write(REG_INVERT_BITS, INVERT_RX1_RF_DC_CGOUT_WORD);
    else
        ad9361_spi_write(REG_INVERT_BITS, INVERT_RX1_RF_DC_CGOUT_WORD | INVERT_RX2_RF_DC_CGOUT_WORD);

    return ad9361_run_calibration(RFDC_CAL);
}

/**
 * Update RF bandwidth.
 * @param phy The AD9361 state structure.
 * @param rf_rx_bw RF RX bandwidth [Hz].
 * @param rf_tx_bw RF TX bandwidth [Hz].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t __ad9361_update_rf_bandwidth(uint32_t rf_rx_bw, uint32_t rf_tx_bw)
{
    uint32_t real_rx_bandwidth = rf_rx_bw / 2;
    uint32_t real_tx_bandwidth = rf_tx_bw / 2;
    uint32_t bbpll_freq;
    int32_t ret;

    DBGPRINTLN_CTX("rf_rx_bw: %"PRIu32" Hz, rf_tx_bw %"PRIu32" Hz", rf_rx_bw, rf_tx_bw);

    bbpll_freq = ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[BBPLL_CLK]);

    ret = ad9361_rx_bb_analog_filter_calib(real_rx_bandwidth, bbpll_freq);

    if(ret < 0)
        return ret;

    ret = ad9361_tx_bb_analog_filter_calib(real_tx_bandwidth, bbpll_freq);

    if(ret < 0)
        return ret;

    ret = ad9361_rx_tia_calib(real_rx_bandwidth);

    if(ret < 0)
        return ret;

    ret = ad9361_tx_bb_second_filter_calib(real_tx_bandwidth);

    if(ret < 0)
        return ret;

    ret = ad9361_rx_adc_setup(bbpll_freq, ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[ADC_CLK]));

    if(ret < 0)
        return ret;

    return 0;
}

/**
 * TX Quad Calib.
 * @param phy The AD9361 state structure.
 * @param phase phase
 * @param rxnco_word Rx NCO word.
 * @param decim decim
 * @param res res
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t __ad9361_tx_quad_calib(uint32_t phase, uint32_t rxnco_word, uint32_t decim, uint8_t* res)
{
    int32_t ret;

    ad9361_spi_write(REG_QUAD_CAL_NCO_FREQ_PHASE_OFFSET, RX_NCO_FREQ(rxnco_word) | RX_NCO_PHASE_OFFSET(phase));
    ad9361_spi_write(REG_QUAD_CAL_CTRL, SETTLE_MAIN_ENABLE | DC_OFFSET_ENABLE | QUAD_CAL_SOFT_RESET | GAIN_ENABLE | PHASE_ENABLE | M_DECIM(decim));
    ad9361_spi_write(REG_QUAD_CAL_CTRL, SETTLE_MAIN_ENABLE | DC_OFFSET_ENABLE | GAIN_ENABLE | PHASE_ENABLE | M_DECIM(decim));

    ret = ad9361_run_calibration(TX_QUAD_CAL);

    if(ret < 0)
        return ret;

    if(res)
    {
        *res = ad9361_spi_read( (g_pAD9361Phy->pdata->rx1tx1_mode_use_tx_num == 2) ? REG_QUAD_CAL_STATUS_TX2 : REG_QUAD_CAL_STATUS_TX1) & (TX1_LO_CONV | TX1_SSB_CONV);

        if(g_pAD9361Phy->pdata->rx2tx2)
            *res &= ad9361_spi_read(REG_QUAD_CAL_STATUS_TX2) & (TX2_LO_CONV | TX2_SSB_CONV);
    }

    return 0;
}

static uint32_t ad9361_find_opt(uint8_t* field, uint32_t size, uint32_t* ret_start)
{
    uint32_t cnt = 0;
    uint32_t max_cnt = 0;
    int32_t start = -1;
    uint32_t max_start = 0;

    for(uint32_t i = 0; i < size; i++)
    {
        if(field[i] == 0)
        {
            if(start == -1)
                start = i;

            cnt++;
        }
        else
        {
            if(cnt > max_cnt)
            {
                max_cnt = cnt;
                max_start = start;
            }

            start = -1;
            cnt = 0;
        }
    }

    if(cnt > max_cnt)
    {
        max_cnt = cnt;
        max_start = start;
    }

    *ret_start = max_start;

    return max_cnt;
}

/**
 * Loop through all possible phase offsets in case the QUAD CAL doesn't converge.
 * @param phy The AD9361 state structure.
 * @param rxnco_word Rx NCO word.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_tx_quad_phase_search(uint32_t rxnco_word, uint8_t decim)
{
    int32_t ret;
    uint8_t field[64], val;
    uint32_t start, cnt;

    DBGPRINTLN_CTX("rxnco_word: %"PRIu32", decim: %"PRIu8"", rxnco_word, decim);

    for(uint32_t i = 0; i < ARRAY_SIZE(field) / 2; i++)
    {
        ret = __ad9361_tx_quad_calib(i, rxnco_word, decim, &val);

        if(ret < 0)
            return ret;

        /* Handle 360/0 wrap around */
        field[i] = field[i + 32] = !((val & TX1_LO_CONV) && (val & TX1_SSB_CONV));
    }

    cnt = ad9361_find_opt(field, ARRAY_SIZE(field), &start);

    g_pAD9361Phy->last_tx_quad_cal_phase = (start + cnt / 2) & 0x1F;

    ret = __ad9361_tx_quad_calib(g_pAD9361Phy->last_tx_quad_cal_phase, rxnco_word, decim, NULL);

    if(ret < 0)
        return ret;

    return 0;
}

/**
 * Perform a TX quadrature calibration.
 * @param phy The AD9361 state structure.
 * @param bw The bandwidth [Hz].
 * @param rx_phase The optional RX phase value overwrite (set to zero).
 * @return 0 in case of success, negative error code otherwise.
 */

static int ad9361_tx_quad_calib(uint32_t bw_rx, uint32_t bw_tx, int32_t rx_phase)
{
    uint32_t clktf, clkrf;
    int32_t txnco_word, rxnco_word, txnco_freq, ret;
    uint8_t __rx_phase = 0, reg_inv_bits = 0, val, decim;
    bool phase_inversion_en;

    ret = 0;

    if(g_pAD9361Phy->cached_synth_pd[0] & TX_LO_POWER_DOWN)
    {
        if(g_pAD9361Phy->pdata->lo_powerdown_managed_en)
        {
            ad9361_spi_writef(REG_TX_SYNTH_POWER_DOWN_OVERRIDE, TX_LO_POWER_DOWN, 0);
        }
        else
        {
            DBGPRINTLN_CTX("Tx QUAD Cal abort due to TX LO in powerdown");

            return -EFAULT;
        }
    }
    /*
    * Find NCO frequency that matches this equation:
    * BW / 4 = Rx NCO freq = Tx NCO freq:
    * Rx NCO = ClkRF * (rxNCO <1:0> + 1) / 32
    * Tx NCO = ClkTF * (txNCO <1:0> + 1) / 32
    */

    clkrf = ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[CLKRF_CLK]);
    clktf = ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[CLKTF_CLK]);

    DBGPRINTLN_CTX("bw_tx: %"PRIu32" Hz, clkrf: %"PRIu32" Hz, clktf: %"PRIu32" Hz", bw_tx, clkrf, clktf);

    txnco_word = DIV_ROUND(bw_tx * 8, clktf) - 1;
    txnco_word = CLAMP_T(int, txnco_word, 0, 3);
    rxnco_word = txnco_word;

    DBGPRINTLN_CTX("Tx NCO frequency: %"PRIu32" Hz (BW/4: %"PRIu32" Hz), txnco_word %"PRId32, clktf * (txnco_word + 1) / 32, bw_tx / 4, txnco_word);

    if(clktf <= 4000000UL)
        decim = 2;
    else
        decim = 3;

    if(clkrf == (2 * clktf))
    {
        __rx_phase = 0x0E;

        switch(txnco_word)
        {
            case 0:
                txnco_word++;
            break;
            case 1:
                rxnco_word--;
            break;
            case 2:
                rxnco_word -= 2;
                txnco_word--;
            break;
            case 3:
                rxnco_word -= 2;    /* REVISIT */
                __rx_phase = 0x08;
            break;
        }
    }
    else if(clkrf == clktf)
    {
        switch(txnco_word)
        {
            case 0:
            case 3:
                __rx_phase = 0x15;
            break;
            case 2:
                __rx_phase = 0x1F;
            break;
            case 1:
                if(ad9361_spi_readf(REG_TX_ENABLE_FILTER_CTRL, 0x3F) == 0x22)
                    __rx_phase = 0x15;     /* REVISIT */
                else
                    __rx_phase = 0x1A;
            break;
        }
    }
    else
    {
        DBGPRINTLN_CTX("Unhandled case in line %d, clkrf: %"PRIu32" Hz, clktf: %"PRIu32" Hz", __LINE__, clkrf, clktf);
    }

    if(rx_phase >= 0)
        __rx_phase = rx_phase;

    txnco_freq = clktf * (txnco_word + 1) / 32;

    if(txnco_freq > (int64_t)(bw_rx / 4) || txnco_freq > (int64_t)(bw_tx / 4))
    {
        /* Make sure the BW during calibration is wide enough */
        ret = __ad9361_update_rf_bandwidth(txnco_freq * 8, txnco_freq * 8);

        if(ret < 0)
            goto out_restore;
    }

    phase_inversion_en = g_pAD9361Phy->pdata->rx1rx2_phase_inversion_en || (g_pAD9361Phy->pdata->port_ctrl.pp_conf[1] & INVERT_RX2);

    if(phase_inversion_en)
    {
        ad9361_spi_writef(REG_PARALLEL_PORT_CONF_2, INVERT_RX2, 0);

        reg_inv_bits = ad9361_spi_read(REG_INVERT_BITS);

        ad9361_spi_write(REG_INVERT_BITS, INVERT_RX1_RF_DC_CGOUT_WORD | INVERT_RX2_RF_DC_CGOUT_WORD);
    }

    ad9361_spi_writef(REG_KEXP_2, TX_NCO_FREQ(~0), txnco_word);
    ad9361_spi_write(REG_QUAD_CAL_COUNT, 0xFF);
    ad9361_spi_write(REG_KEXP_1, KEXP_TX(1) | KEXP_TX_COMP(3) | KEXP_DC_I(3) | KEXP_DC_Q(3));
    ad9361_spi_write(REG_MAG_FTEST_THRESH, 0x03);
    ad9361_spi_write(REG_MAG_FTEST_THRESH_2, 0x03);

    if(g_pAD9361Phy->tx_quad_lpf_tia_match < 0) /* set in ad9361_load_gt() */
        DBGPRINTLN_CTX("failed to find suitable LPF TIA value in gain table");
    else
        ad9361_spi_write(REG_TX_QUAD_FULL_LMT_GAIN, g_pAD9361Phy->tx_quad_lpf_tia_match);

    ad9361_spi_write(REG_QUAD_SETTLE_COUNT, 0xF0);
    ad9361_spi_write(REG_TX_QUAD_LPF_GAIN, 0x00);

    if(rx_phase != -2)
    {
        ret = __ad9361_tx_quad_calib(__rx_phase, rxnco_word, decim, &val);

        DBGPRINTLN_CTX("LO leakage: %d, Quadrature Calibration: %d, rx_phase %d", !!(val & TX1_LO_CONV), !!(val & TX1_SSB_CONV), __rx_phase);

        /* Calibration failed -> try last phase offset */
        if(val != (TX1_LO_CONV | TX1_SSB_CONV))
            if(g_pAD9361Phy->last_tx_quad_cal_phase < 31)
                ret = __ad9361_tx_quad_calib(g_pAD9361Phy->last_tx_quad_cal_phase, rxnco_word, decim, &val);
        else
            g_pAD9361Phy->last_tx_quad_cal_phase = __rx_phase;
    }
    else
    {
        /* force phase search */
        val = 0;
    }

    /* Calibration failed -> loop through all 32 phase offsets */
    if(val != (TX1_LO_CONV | TX1_SSB_CONV))
        ret = ad9361_tx_quad_phase_search(rxnco_word, decim);

    if(phase_inversion_en)
    {
        ad9361_spi_writef(REG_PARALLEL_PORT_CONF_2, INVERT_RX2, 1);
        ad9361_spi_write(REG_INVERT_BITS, reg_inv_bits);
    }

    if(txnco_freq > (int64_t)(bw_rx / 4) || txnco_freq > (int64_t)(bw_tx / 4))
        __ad9361_update_rf_bandwidth(g_pAD9361Phy->current_rx_bw_Hz, g_pAD9361Phy->current_tx_bw_Hz);

out_restore:
    /* Restore synthesizer powerdown configuration */
    if(g_pAD9361Phy->pdata->lo_powerdown_managed_en && (g_pAD9361Phy->cached_synth_pd[0] & TX_LO_POWER_DOWN))
        ad9361_synth_lo_powerdown(LO_DONTCARE, LO_DONTCARE);

    return ret;
}

/**
 * Setup RX tracking calibrations.
 * @param phy The AD9361 state structure.
 * @param bbdc_track Set true, will enable the BBDC tracking.
 * @param rfdc_track Set true, will enable the RFDC tracking.
 * @param rxquad_track Set true, will enable the RXQUAD tracking.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_tracking_control(bool bbdc_track, bool rfdc_track, bool rxquad_track)
{
    uint32_t qtrack = 0;

    DBGPRINTLN_CTX("bbdc_track: %s, rfdc_track: %s, rxquad_track: %s", bbdc_track ? "true" : "false", rfdc_track ? "true" : "false", rxquad_track ? "true" : "false");

    ad9361_spi_write(REG_CALIBRATION_CONFIG_2, CALIBRATION_CONFIG2_DFLT | K_EXP_PHASE(0x15));
    ad9361_spi_write(REG_CALIBRATION_CONFIG_3, PREVENT_POS_LOOP_GAIN | K_EXP_AMPLITUDE(0x15));

    ad9361_spi_write(REG_DC_OFFSET_CONFIG2, USE_WAIT_COUNTER_FOR_RF_DC_INIT_CAL | DC_OFFSET_UPDATE(g_pAD9361Phy->pdata->dc_offset_update_events) | (bbdc_track ? ENABLE_BB_DC_OFFSET_TRACKING : 0) | (rfdc_track ? ENABLE_RF_OFFSET_TRACKING : 0));

    ad9361_spi_writef(REG_RX_QUAD_GAIN2, CORRECTION_WORD_DECIMATION_M(~0), g_pAD9361Phy->pdata->qec_tracking_slow_mode_en ? 4 : 0);

    if(rxquad_track)
        if(g_pAD9361Phy->pdata->rx2tx2)
            qtrack = ENABLE_TRACKING_MODE_CH1 | ENABLE_TRACKING_MODE_CH2;
        else
            qtrack = (g_pAD9361Phy->pdata->rx1tx1_mode_use_rx_num == 1) ? ENABLE_TRACKING_MODE_CH1 : ENABLE_TRACKING_MODE_CH2;

    ad9361_spi_write(REG_CALIBRATION_CONFIG_1, ENABLE_PHASE_CORR | ENABLE_GAIN_CORR | FREE_RUN_MODE | ENABLE_CORR_WORD_DECIMATION | qtrack);

    return 0;
}

/**
 * Enable/disable the VCO cal.
 * @param phy The AD9361 state structure.
 * @param rx Set true for rx.
 * @param enable Set true to enable.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_trx_vco_cal_control(bool tx, bool enable)
{
    DBGPRINTLN_CTX("enable: %s", enable ? "true" : "false");

    return ad9361_spi_writef( tx ? REG_TX_PFD_CONFIG : REG_RX_PFD_CONFIG, BYPASS_LD_SYNTH, !enable);
}

/**
 * Enable/disable the ext. LO.
 * @param phy The AD9361 state structure.
 * @param rx Set true for rx.
 * @param enable Set true to enable.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_trx_ext_lo_control(bool tx, bool enable)
{
    uint32_t val = enable ? ~0 : 0;
    int32_t ret;

    /* REVIST:
     * POWER_DOWN_TRX_SYNTH and MCS_RF_ENABLE somehow conflict
     */

    bool mcs_rf_enable = ad9361_spi_readf( REG_MULTICHIP_SYNC_AND_TX_MON_CTRL, MCS_RF_ENABLE);

    DBGPRINTLN_CTX("%s enable: %s", tx ? "TX" : "RX", enable ? "true" : "false");

    if(tx)
    {
        ret = ad9361_spi_writef(REG_ENSM_CONFIG_2, POWER_DOWN_TX_SYNTH, mcs_rf_enable ? 0 : enable);
        ret = ad9361_spi_writef(REG_ENSM_CONFIG_2, TX_SYNTH_READY_MASK, enable);
        ret |= ad9361_spi_writef(REG_RFPLL_DIVIDERS, TX_VCO_DIVIDER(~0), enable ? 7 : g_pAD9361Phy->cached_tx_rfpll_div);

        if(enable)
            g_pAD9361Phy->cached_synth_pd[0] |= TX_SYNTH_VCO_ALC_POWER_DOWN | TX_SYNTH_PTAT_POWER_DOWN | TX_SYNTH_VCO_POWER_DOWN;
        else
            g_pAD9361Phy->cached_synth_pd[0] &= ~(TX_SYNTH_VCO_ALC_POWER_DOWN | TX_SYNTH_PTAT_POWER_DOWN | TX_SYNTH_VCO_POWER_DOWN);

        ret |= ad9361_spi_write(REG_TX_SYNTH_POWER_DOWN_OVERRIDE, g_pAD9361Phy->cached_synth_pd[0]);
        ret |= ad9361_spi_writef(REG_ANALOG_POWER_DOWN_OVERRIDE, TX_EXT_VCO_BUFFER_POWER_DOWN, !enable);
        ret |= ad9361_spi_write(REG_TX_LO_GEN_POWER_MODE, TX_LO_GEN_POWER_MODE(val));
    }
    else
    {
        ret = ad9361_spi_writef(REG_ENSM_CONFIG_2, POWER_DOWN_RX_SYNTH, mcs_rf_enable ? 0 : enable);
        ret = ad9361_spi_writef(REG_ENSM_CONFIG_2, RX_SYNTH_READY_MASK, enable);
        ret |= ad9361_spi_writef(REG_RFPLL_DIVIDERS, RX_VCO_DIVIDER(~0), enable ? 7 : g_pAD9361Phy->cached_rx_rfpll_div);

        if(enable)
            g_pAD9361Phy->cached_synth_pd[1] |= RX_SYNTH_VCO_ALC_POWER_DOWN | RX_SYNTH_PTAT_POWER_DOWN | RX_SYNTH_VCO_POWER_DOWN;
        else
            g_pAD9361Phy->cached_synth_pd[1] &= ~(TX_SYNTH_VCO_ALC_POWER_DOWN | RX_SYNTH_PTAT_POWER_DOWN | RX_SYNTH_VCO_POWER_DOWN);

        ret |= ad9361_spi_write(REG_RX_SYNTH_POWER_DOWN_OVERRIDE, g_pAD9361Phy->cached_synth_pd[1]);
        ret |= ad9361_spi_writef(REG_ANALOG_POWER_DOWN_OVERRIDE, RX_EXT_VCO_BUFFER_POWER_DOWN, !enable);
        ret |= ad9361_spi_write(REG_RX_LO_GEN_POWER_MODE, RX_LO_GEN_POWER_MODE(val));
    }

    return ret;
}

/**
 * Power down the TX and/or RX Local Oscillators.
 * @param phy The AD9361 state structure.
 * @param rx The RX LO setting.
 * @param tx The TX LO setting.
 * @return 0 in case of success, negative error code otherwise.
 */
int ad9361_synth_lo_powerdown(enum ad9361_synth_pd_ctrl rx, enum ad9361_synth_pd_ctrl tx)
{
    DBGPRINTLN_CTX("RX(%d) TX(%d)", rx, tx);

    switch(rx)
    {
        case LO_OFF:
            g_pAD9361Phy->cached_synth_pd[1] |= RX_LO_POWER_DOWN;
        break;
        case LO_ON:
            g_pAD9361Phy->cached_synth_pd[1] &= ~RX_LO_POWER_DOWN;
        break;
        case LO_DONTCARE:
        break;
    }

    switch(tx)
    {
        case LO_OFF:
            g_pAD9361Phy->cached_synth_pd[0] |= TX_LO_POWER_DOWN;
        break;
        case LO_ON:
            g_pAD9361Phy->cached_synth_pd[0] &= ~TX_LO_POWER_DOWN;
        break;
        case LO_DONTCARE:
        break;
    }

    return ad9361_spi_writem(REG_TX_SYNTH_POWER_DOWN_OVERRIDE, g_pAD9361Phy->cached_synth_pd, 2);
}

/**
 * Setup the reference clock delay unit counter register.
 * @param phy The AD9361 state structure.
 * @param ref_clk_hz The reference clock frequency [Hz].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_set_ref_clk_cycles(uint32_t ref_clk_hz)
{
    DBGPRINTLN_CTX("ref_clk_hz: %"PRIu32" Hz", ref_clk_hz);

    return ad9361_spi_write(REG_REFERENCE_CLOCK_CYCLES, REFERENCE_CLOCK_CYCLES_PER_US((ref_clk_hz / 1000000UL) - 1));
}

/**
 * Setup the DCXO tune.
 * @param phy The AD9361 state structure.
 * @param coarse The DCXO tune coarse.
 * @param fine The DCXO tune fine.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_set_dcxo_tune(uint32_t coarse, uint32_t fine)
{
    DBGPRINTLN_CTX("coarse: %"PRIu32", fine: %"PRIu32, coarse, fine);

    if(g_pAD9361Phy->pdata->use_extclk)
        return -ENODEV;

    ad9361_spi_write(REG_DCXO_COARSE_TUNE, DCXO_TUNE_COARSE(coarse));
    ad9361_spi_write(REG_DCXO_FINE_TUNE_LOW, DCXO_TUNE_FINE_LOW(fine));

    return ad9361_spi_write(REG_DCXO_FINE_TUNE_HIGH, DCXO_TUNE_FINE_HIGH(fine));
}

/**
 * Setup TXMON.
 * @param phy The AD9361 state structure.
 * @param ctrl The TXMON settings.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_txmon_setup(struct ad9361_tx_mon_control* ctrl)
{
    ad9361_spi_write(REG_TPM_MODE_ENABLE, (ctrl->one_shot_mode_en ? ONE_SHOT_MODE : 0) | TX_MON_DURATION(utils_ilog2(ctrl->tx_mon_duration / 16)));
    ad9361_spi_write(REG_TX_MON_DELAY, ctrl->tx_mon_delay & 0xFF);
    ad9361_spi_writef(REG_TX_LEVEL_THRESH, TX_MON_DELAY_COUNTER(~0), ctrl->tx_mon_delay >> 8);
    ad9361_spi_write(REG_TX_MON_1_CONFIG, TX_MON_1_LO_CM(ctrl->tx1_mon_lo_cm) | TX_MON_1_GAIN(ctrl->tx1_mon_front_end_gain));
    ad9361_spi_write(REG_TX_MON_2_CONFIG, TX_MON_2_LO_CM(ctrl->tx2_mon_lo_cm) | TX_MON_2_GAIN(ctrl->tx2_mon_front_end_gain));
    ad9361_spi_write(REG_TX_ATTEN_THRESH, ctrl->low_high_gain_threshold_mdB / 250);
    ad9361_spi_write(REG_TX_MON_HIGH_GAIN, TX_MON_HIGH_GAIN(ctrl->high_gain_dB));
    ad9361_spi_write(REG_TX_MON_LOW_GAIN, (ctrl->tx_mon_track_en ? TX_MON_TRACK : 0) | TX_MON_LOW_GAIN(ctrl->low_gain_dB));

    return 0;
}

/**
 * Enable TXMON.
 * @param phy The AD9361 state structure.
 * @param en_mask The enable mask.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_txmon_control(int32_t en_mask)
{
    DBGPRINTLN_CTX("mask: 0x%"PRIx32, en_mask);

    ad9361_spi_writef(REG_ANALOG_POWER_DOWN_OVERRIDE, TX_MONITOR_POWER_DOWN(~0), ~en_mask);
    ad9361_spi_writef(REG_TPM_MODE_ENABLE, TX1_MON_ENABLE, !!(en_mask & TX_1));

    return ad9361_spi_writef(REG_TPM_MODE_ENABLE, TX2_MON_ENABLE, !!(en_mask & TX_2));
}

/**
* Setup the RF port.
* Note:
* val
* 0    (RX1A_N &  RX1A_P) and (RX2A_N & RX2A_P) enabled; balanced
* 1    (RX1B_N &  RX1B_P) and (RX2B_N & RX2B_P) enabled; balanced
* 2    (RX1C_N &  RX1C_P) and (RX2C_N & RX2C_P) enabled; balanced
*
* 3    RX1A_N and RX2A_N enabled; unbalanced
* 4    RX1A_P and RX2A_P enabled; unbalanced
* 5    RX1B_N and RX2B_N enabled; unbalanced
* 6    RX1B_P and RX2B_P enabled; unbalanced
* 7    RX1C_N and RX2C_N enabled; unbalanced
* 8    RX1C_P and RX2C_P enabled; unbalanced
* 9 TX_MON1
* 10 TX_MON2
* 11 TX_MON1 & TX_MON2
* @param phy The AD9361 state structure.
* @param is_out TX RF output port enabled.
* @param rx_inputs RX input option identifier
* @param txb TX output option identifier
* @return 0 in case of success, negative error code otherwise.
*/
int32_t ad9361_rf_port_setup(bool is_out, uint32_t rx_inputs, uint32_t txb)
{
    uint32_t val;

    if(rx_inputs > 11)
        return -EINVAL;

    if(!is_out)
    {
        if(rx_inputs > 8)
            return ad9361_txmon_control(rx_inputs & (TX_1 | TX_2));
        else
            ad9361_txmon_control(0);
    }

    if(rx_inputs < 3)
        val = 3 << (rx_inputs * 2);
    else
        val = 1 << (rx_inputs - 3);

    if(txb)
        val |= TX_OUTPUT; /* Select TX1B, TX2B */

    DBGPRINTLN_CTX("INPUT_SELECT: 0x%"PRIX32, val);

    return ad9361_spi_write(REG_INPUT_SELECT, val);
}

/**
 * Setup the Parallel Port (Digital Data Interface).
 * @param phy The AD9361 state structure.
 * @param restore_c3 Set true, will restore the Parallel Port Configuration 3
 *                   register.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_pp_port_setup(bool restore_c3)
{
    struct ad9361_phy_platform_data* pd = g_pAD9361Phy->pdata;

    if(restore_c3)
        return ad9361_spi_write(REG_PARALLEL_PORT_CONF_3, pd->port_ctrl.pp_conf[2]);

    /* Sanity check */
    if(pd->port_ctrl.pp_conf[2] & LVDS_MODE)
        pd->port_ctrl.pp_conf[2] &= ~(HALF_DUPLEX_MODE | SINGLE_DATA_RATE | SINGLE_PORT_MODE);

    if(pd->port_ctrl.pp_conf[2] & FULL_PORT)
        pd->port_ctrl.pp_conf[2] &= ~(HALF_DUPLEX_MODE | SINGLE_PORT_MODE);

    ad9361_spi_write(REG_PARALLEL_PORT_CONF_1, pd->port_ctrl.pp_conf[0]);
    ad9361_spi_write(REG_PARALLEL_PORT_CONF_2, pd->port_ctrl.pp_conf[1]);
    ad9361_spi_write(REG_PARALLEL_PORT_CONF_3, pd->port_ctrl.pp_conf[2]);
    ad9361_spi_write(REG_RX_CLOCK_DATA_DELAY, pd->port_ctrl.rx_clk_data_delay);
    ad9361_spi_write(REG_TX_CLOCK_DATA_DELAY, pd->port_ctrl.tx_clk_data_delay);

    ad9361_spi_write(REG_LVDS_BIAS_CTRL, pd->port_ctrl.lvds_bias_ctrl);
    //ad9361_spi_write(REG_DIGITAL_IO_CTRL, pd->port_ctrl.digital_io_ctrl);
    ad9361_spi_write(REG_LVDS_INVERT_CTRL1, pd->port_ctrl.lvds_invert[0]);
    ad9361_spi_write(REG_LVDS_INVERT_CTRL2, pd->port_ctrl.lvds_invert[1]);

    if(pd->rx1rx2_phase_inversion_en || (pd->port_ctrl.pp_conf[1] & INVERT_RX2))
    {
        ad9361_spi_writef(REG_PARALLEL_PORT_CONF_2, INVERT_RX2, 1);
        ad9361_spi_writef(REG_INVERT_BITS, INVERT_RX2_RF_DC_CGOUT_WORD, 0);
    }

    return 0;
}

/**
 * Setup the Gain Control Blocks (common function for MGC, AGC modes)
 * @param phy The AD9361 state structure.
 * @param ctrl The gain control settings.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_gc_setup(struct ad9361_gain_control* ctrl)
{
    uint32_t reg, tmp1, tmp2;

    reg = DEC_PWR_FOR_GAIN_LOCK_EXIT | DEC_PWR_FOR_LOCK_LEVEL | DEC_PWR_FOR_LOW_PWR;

    if(ctrl->rx1_mode == RF_GAIN_HYBRID_AGC || ctrl->rx2_mode == RF_GAIN_HYBRID_AGC)
        reg |= SLOW_ATTACK_HYBRID_MODE;

    reg |= RX1_GAIN_CTRL_SETUP(ctrl->rx1_mode) | RX2_GAIN_CTRL_SETUP(ctrl->rx2_mode);

    g_pAD9361Phy->agc_mode[0] = ctrl->rx1_mode;
    g_pAD9361Phy->agc_mode[1] = ctrl->rx2_mode;

    ad9361_spi_write(REG_AGC_CONFIG_1, reg); // Gain Control Mode Select

    /* AGC_USE_FULL_GAIN_TABLE handled in ad9361_load_gt() */
    ad9361_spi_writef(REG_AGC_CONFIG_2, MAN_GAIN_CTRL_RX1, ctrl->mgc_rx1_ctrl_inp_en);
    ad9361_spi_writef(REG_AGC_CONFIG_2, MAN_GAIN_CTRL_RX2, ctrl->mgc_rx2_ctrl_inp_en);
    ad9361_spi_writef(REG_AGC_CONFIG_2, DIG_GAIN_EN, ctrl->dig_gain_en);

    ctrl->adc_ovr_sample_size = CLAMP_T(uint8_t, ctrl->adc_ovr_sample_size, 1U, 8U);
    reg = ADC_OVERRANGE_SAMPLE_SIZE(ctrl->adc_ovr_sample_size - 1);

    if(g_pAD9361Phy->pdata->split_gt && (ctrl->mgc_rx1_ctrl_inp_en || ctrl->mgc_rx2_ctrl_inp_en))
    {
        switch(ctrl->mgc_split_table_ctrl_inp_gain_mode)
        {
            case 1:
                reg &= ~INCDEC_LMT_GAIN;
            break;
            case 2:
                reg |= INCDEC_LMT_GAIN;
            break;
            default:
                reg |= USE_AGC_FOR_LMTLPF_GAIN;
            break;
        }
    }

    ctrl->mgc_inc_gain_step = CLAMP_T(uint8_t, ctrl->mgc_inc_gain_step, 1U, 8U);
    reg |= MANUAL_INCR_STEP_SIZE(ctrl->mgc_inc_gain_step - 1);
    ad9361_spi_write(REG_AGC_CONFIG_3, reg); // Incr Step Size, ADC Overrange Size

    ctrl->mgc_dec_gain_step = CLAMP_T(uint8_t, ctrl->mgc_dec_gain_step, 1U, 8U);
    reg = MANUAL_CTRL_IN_DECR_GAIN_STP_SIZE(ctrl->mgc_dec_gain_step - 1);
    ad9361_spi_write(REG_PEAK_WAIT_TIME, reg); // Decr Step Size, Peak Overload Time

    if(ctrl->dig_gain_en)
        ad9361_spi_write(REG_DIGITAL_GAIN, MAXIMUM_DIGITAL_GAIN(ctrl->max_dig_gain) | DIG_GAIN_STP_SIZE(ctrl->dig_gain_step_size));

    if(ctrl->adc_large_overload_thresh >= ctrl->adc_small_overload_thresh)
    {
        ad9361_spi_write(REG_ADC_SMALL_OVERLOAD_THRESH, ctrl->adc_small_overload_thresh); // ADC Small Overload Threshold
        ad9361_spi_write(REG_ADC_LARGE_OVERLOAD_THRESH, ctrl->adc_large_overload_thresh); // ADC Large Overload Threshold
    }
    else
    {
        ad9361_spi_write(REG_ADC_SMALL_OVERLOAD_THRESH, ctrl->adc_large_overload_thresh); // ADC Small Overload Threshold
        ad9361_spi_write(REG_ADC_LARGE_OVERLOAD_THRESH, ctrl->adc_small_overload_thresh); // ADC Large Overload Threshold
    }

    reg = (ctrl->lmt_overload_high_thresh / 16) - 1;
    reg = CLAMP(reg, 0U, 63U);
    ad9361_spi_write(REG_LARGE_LMT_OVERLOAD_THRESH, reg);
    reg = (ctrl->lmt_overload_low_thresh / 16) - 1;
    reg = CLAMP(reg, 0U, 63U);
    ad9361_spi_writef(REG_SMALL_LMT_OVERLOAD_THRESH, SMALL_LMT_OVERLOAD_THRESH(~0), reg);

    if(g_pAD9361Phy->pdata->split_gt)
    {
        /* REVIST */
        ad9361_spi_write(REG_RX1_MANUAL_LPF_GAIN, 0x58); // Rx1 LPF Gain Index
        ad9361_spi_write(REG_RX2_MANUAL_LPF_GAIN, 0x18); // Rx2 LPF Gain Index
        ad9361_spi_write(REG_FAST_INITIAL_LMT_GAIN_LIMIT, 0x27); // Initial LMT Gain Limit
    }

    ad9361_spi_write(REG_RX1_MANUAL_DIGITALFORCED_GAIN, 0x00); // Rx1 Digital Gain Index
    ad9361_spi_write(REG_RX2_MANUAL_DIGITALFORCED_GAIN, 0x00); // Rx2 Digital Gain Index

    reg = CLAMP_T(uint8_t, ctrl->low_power_thresh, 0U, 64U) * 2;
    ad9361_spi_write(REG_FAST_LOW_POWER_THRESH, reg); // Low Power Threshold
    ad9361_spi_write(REG_TX_SYMBOL_ATTEN_CONFIG, 0x00); // Tx Symbol Gain Control

    ad9361_spi_writef(REG_DEC_POWER_MEASURE_DURATION_0, USE_HB1_OUT_FOR_DEC_PWR_MEAS, !ctrl->use_rx_fir_out_for_dec_pwr_meas); // USE HB1 or FIR output for power measurements

    ad9361_spi_writef(REG_DEC_POWER_MEASURE_DURATION_0, ENABLE_DEC_PWR_MEAS, 1); // Power Measurement Duration

    if(ctrl->rx1_mode == RF_GAIN_FASTATTACK_AGC || ctrl->rx2_mode == RF_GAIN_FASTATTACK_AGC)
        reg = utils_ilog2(ctrl->f_agc_dec_pow_measuremnt_duration / 16);
    else
        reg = utils_ilog2(ctrl->dec_pow_measuremnt_duration / 16);

    ad9361_spi_writef(REG_DEC_POWER_MEASURE_DURATION_0, DEC_POWER_MEASUREMENT_DURATION(~0), reg); // Power Measurement Duration

    /* AGC */

    tmp1 = reg = CLAMP_T(uint8_t, ctrl->agc_inner_thresh_high, 0U, 127U);
    ad9361_spi_writef(REG_AGC_LOCK_LEVEL, AGC_LOCK_LEVEL_FAST_AGC_INNER_HIGH_THRESH_SLOW(~0), reg);

    tmp2 = reg = CLAMP_T(uint8_t, ctrl->agc_inner_thresh_low, 0U, 127U);
    reg |= (ctrl->adc_lmt_small_overload_prevent_gain_inc ? PREVENT_GAIN_INC : 0);
    ad9361_spi_write(REG_AGC_INNER_LOW_THRESH, reg);

    reg = AGC_OUTER_HIGH_THRESH(tmp1 - ctrl->agc_outer_thresh_high) | AGC_OUTER_LOW_THRESH(ctrl->agc_outer_thresh_low - tmp2);
    ad9361_spi_write(REG_OUTER_POWER_THRESHS, reg);

    reg = AGC_OUTER_HIGH_THRESH_EXED_STP_SIZE(ctrl->agc_outer_thresh_high_dec_steps) | AGC_OUTER_LOW_THRESH_EXED_STP_SIZE(ctrl->agc_outer_thresh_low_inc_steps);
    ad9361_spi_write(REG_GAIN_STP_2, reg);

    reg = ((ctrl->immed_gain_change_if_large_adc_overload) ? IMMED_GAIN_CHANGE_IF_LG_ADC_OVERLOAD : 0) | ((ctrl->immed_gain_change_if_large_lmt_overload) ? IMMED_GAIN_CHANGE_IF_LG_LMT_OVERLOAD : 0) | AGC_INNER_HIGH_THRESH_EXED_STP_SIZE(ctrl->agc_inner_thresh_high_dec_steps) | AGC_INNER_LOW_THRESH_EXED_STP_SIZE(ctrl->agc_inner_thresh_low_inc_steps);
    ad9361_spi_write(REG_GAIN_STP1, reg);

    reg = LARGE_ADC_OVERLOAD_EXED_COUNTER(ctrl->adc_large_overload_exceed_counter) | SMALL_ADC_OVERLOAD_EXED_COUNTER(ctrl->adc_small_overload_exceed_counter);
    ad9361_spi_write(REG_ADC_OVERLOAD_COUNTERS, reg);

    reg = DECREMENT_STP_SIZE_FOR_SMALL_LPF_GAIN_CHANGE(ctrl->f_agc_large_overload_inc_steps) | LARGE_LPF_GAIN_STEP(ctrl->adc_large_overload_inc_steps);
    ad9361_spi_write(REG_GAIN_STP_CONFIG_2, reg);

    reg = LARGE_LMT_OVERLOAD_EXED_COUNTER(ctrl->lmt_overload_large_exceed_counter) | SMALL_LMT_OVERLOAD_EXED_COUNTER(ctrl->lmt_overload_small_exceed_counter);
    ad9361_spi_write(REG_LMT_OVERLOAD_COUNTERS, reg);

    ad9361_spi_writef(REG_GAIN_STP_CONFIG1, DEC_STP_SIZE_FOR_LARGE_LMT_OVERLOAD(~0), ctrl->lmt_overload_large_inc_steps);

    reg = DIG_SATURATION_EXED_COUNTER(ctrl->dig_saturation_exceed_counter) | (ctrl->sync_for_gain_counter_en ? ENABLE_SYNC_FOR_GAIN_COUNTER : 0);
    ad9361_spi_write(REG_DIGITAL_SAT_COUNTER, reg);

    /*
    * Fast AGC
    */

    /* Fast AGC - Low Power */
    ad9361_spi_writef(REG_FAST_CONFIG_1, ENABLE_INCR_GAIN, ctrl->f_agc_allow_agc_gain_increase);

    ad9361_spi_write(REG_FAST_INCREMENT_TIME, ctrl->f_agc_lp_thresh_increment_time);

    reg = ctrl->f_agc_lp_thresh_increment_steps - 1;
    reg = CLAMP_T(uint32_t, reg, 0U, 7U);
    ad9361_spi_writef(REG_FAST_ENERGY_DETECT_COUNT, INCREMENT_GAIN_STP_LPFLMT(~0), reg);

    /* Fast AGC - Lock Level */
    /* Dual use see also agc_inner_thresh_high */
    ad9361_spi_writef(REG_FAST_CONFIG_2_SETTLING_DELAY, ENABLE_LMT_GAIN_INC_FOR_LOCK_LEVEL, ctrl->f_agc_lock_level_lmt_gain_increase_en);

    reg = ctrl->f_agc_lock_level_gain_increase_upper_limit;
    reg = CLAMP_T(uint32_t, reg, 0U, 63U);
    ad9361_spi_writef(REG_FAST_AGCLL_UPPER_LIMIT, AGCLL_MAX_INCREASE(~0), reg);

    /* Fast AGC - Peak Detectors and Final Settling */
    reg = ctrl->f_agc_lpf_final_settling_steps;
    reg = CLAMP_T(uint32_t, reg, 0U, 3U);
    ad9361_spi_writef(REG_FAST_ENERGY_LOST_THRESH, POST_LOCK_LEVEL_STP_SIZE_FOR_LPF_TABLE_FULL_TABLE(~0), reg);

    reg = ctrl->f_agc_lmt_final_settling_steps;
    reg = CLAMP_T(uint32_t, reg, 0U, 3U);
    ad9361_spi_writef(REG_FAST_STRONGER_SIGNAL_THRESH, POST_LOCK_LEVEL_STP_FOR_LMT_TABLE(~0), reg);

    reg = ctrl->f_agc_final_overrange_count;
    reg = CLAMP_T(uint32_t, reg, 0U, 7U);
    ad9361_spi_writef(REG_FAST_FINAL_OVER_RANGE_AND_OPT_GAIN, FINAL_OVER_RANGE_COUNT(~0), reg);

    /* Fast AGC - Final Power Test */
    ad9361_spi_writef(REG_FAST_CONFIG_1, ENABLE_GAIN_INC_AFTER_GAIN_LOCK, ctrl->f_agc_gain_increase_after_gain_lock_en);

    /* Fast AGC - Unlocking the Gain */
    /* 0 = MAX Gain, 1 = Optimized Gain, 2 = Set Gain */

    reg = ctrl->f_agc_gain_index_type_after_exit_rx_mode;
    ad9361_spi_writef(REG_FAST_CONFIG_1, GOTO_SET_GAIN_IF_EXIT_RX_STATE, reg == SET_GAIN);
    ad9361_spi_writef(REG_FAST_CONFIG_1, GOTO_OPTIMIZED_GAIN_IF_EXIT_RX_STATE, reg == OPTIMIZED_GAIN);

    ad9361_spi_writef(REG_FAST_CONFIG_2_SETTLING_DELAY, USE_LAST_LOCK_LEVEL_FOR_SET_GAIN, ctrl->f_agc_use_last_lock_level_for_set_gain_en);

    reg = ctrl->f_agc_optimized_gain_offset;
    reg = CLAMP_T(uint32_t, reg, 0U, 15U);
    ad9361_spi_writef(REG_FAST_FINAL_OVER_RANGE_AND_OPT_GAIN, OPTIMIZE_GAIN_OFFSET(~0), reg);

    tmp1 = !ctrl->f_agc_rst_gla_stronger_sig_thresh_exceeded_en || !ctrl->f_agc_rst_gla_engergy_lost_sig_thresh_exceeded_en || !ctrl->f_agc_rst_gla_large_adc_overload_en || !ctrl->f_agc_rst_gla_large_lmt_overload_en || ctrl->f_agc_rst_gla_en_agc_pulled_high_en;

    ad9361_spi_writef(REG_AGC_CONFIG_2, AGC_GAIN_UNLOCK_CTRL, tmp1);

    reg = !ctrl->f_agc_rst_gla_stronger_sig_thresh_exceeded_en;
    ad9361_spi_writef(REG_FAST_STRONG_SIGNAL_FREEZE, DONT_UNLOCK_GAIN_IF_STRONGER_SIGNAL, reg);

    reg = ctrl->f_agc_rst_gla_stronger_sig_thresh_above_ll;
    reg = CLAMP_T(uint32_t, reg, 0U, 63U);
    ad9361_spi_writef(REG_FAST_STRONGER_SIGNAL_THRESH, STRONGER_SIGNAL_THRESH(~0), reg);

    reg = ctrl->f_agc_rst_gla_engergy_lost_sig_thresh_below_ll;
    reg = CLAMP_T(uint32_t, reg, 0U, 63U);
    ad9361_spi_writef(REG_FAST_ENERGY_LOST_THRESH, ENERGY_LOST_THRESH(~0), reg);

    reg = ctrl->f_agc_rst_gla_engergy_lost_goto_optim_gain_en;
    ad9361_spi_writef(REG_FAST_CONFIG_1, GOTO_OPT_GAIN_IF_ENERGY_LOST_OR_EN_AGC_HIGH, reg);

    reg = !ctrl->f_agc_rst_gla_engergy_lost_sig_thresh_exceeded_en;
    ad9361_spi_writef(REG_FAST_CONFIG_1, DONT_UNLOCK_GAIN_IF_ENERGY_LOST, reg);

    reg = ctrl->f_agc_energy_lost_stronger_sig_gain_lock_exit_cnt;
    reg = CLAMP_T(uint32_t, reg, 0U, 63U);
    ad9361_spi_writef(REG_FAST_GAIN_LOCK_EXIT_COUNT, GAIN_LOCK_EXIT_COUNT(~0), reg);

    reg = !ctrl->f_agc_rst_gla_large_adc_overload_en || !ctrl->f_agc_rst_gla_large_lmt_overload_en;
    ad9361_spi_writef(REG_FAST_CONFIG_1, DONT_UNLOCK_GAIN_IF_LG_ADC_OR_LMT_OVRG, reg);

    reg = !ctrl->f_agc_rst_gla_large_adc_overload_en;
    ad9361_spi_writef(REG_FAST_LOW_POWER_THRESH, DONT_UNLOCK_GAIN_IF_ADC_OVRG, reg);

    /* 0 = Max Gain, 1 = Set Gain, 2 = Optimized Gain, 3 = No Gain Change */

    if(ctrl->f_agc_rst_gla_en_agc_pulled_high_en)
    {
        switch(ctrl->f_agc_rst_gla_if_en_agc_pulled_high_mode)
        {
            case MAX_GAIN:
                ad9361_spi_writef(REG_FAST_CONFIG_2_SETTLING_DELAY, GOTO_MAX_GAIN_OR_OPT_GAIN_IF_EN_AGC_HIGH, 1);
                ad9361_spi_writef(REG_FAST_CONFIG_1, GOTO_SET_GAIN_IF_EN_AGC_HIGH, 0);
                ad9361_spi_writef(REG_FAST_CONFIG_1, GOTO_OPT_GAIN_IF_ENERGY_LOST_OR_EN_AGC_HIGH, 0);
            break;
            case SET_GAIN:
                ad9361_spi_writef(REG_FAST_CONFIG_2_SETTLING_DELAY, GOTO_MAX_GAIN_OR_OPT_GAIN_IF_EN_AGC_HIGH, 0);
                ad9361_spi_writef(REG_FAST_CONFIG_1, GOTO_SET_GAIN_IF_EN_AGC_HIGH, 1);
            break;
            case OPTIMIZED_GAIN:
                ad9361_spi_writef(REG_FAST_CONFIG_2_SETTLING_DELAY, GOTO_MAX_GAIN_OR_OPT_GAIN_IF_EN_AGC_HIGH, 1);
                ad9361_spi_writef(REG_FAST_CONFIG_1, GOTO_SET_GAIN_IF_EN_AGC_HIGH, 0);
                ad9361_spi_writef(REG_FAST_CONFIG_1, GOTO_OPT_GAIN_IF_ENERGY_LOST_OR_EN_AGC_HIGH, 1);
            break;
            case NO_GAIN_CHANGE:
                ad9361_spi_writef(REG_FAST_CONFIG_1, GOTO_SET_GAIN_IF_EN_AGC_HIGH, 0);
                ad9361_spi_writef(REG_FAST_CONFIG_2_SETTLING_DELAY, GOTO_MAX_GAIN_OR_OPT_GAIN_IF_EN_AGC_HIGH, 0);
            break;
        }
    }
    else
    {
        ad9361_spi_writef(REG_FAST_CONFIG_1, GOTO_SET_GAIN_IF_EN_AGC_HIGH, 0);
        ad9361_spi_writef(REG_FAST_CONFIG_2_SETTLING_DELAY, GOTO_MAX_GAIN_OR_OPT_GAIN_IF_EN_AGC_HIGH, 0);
    }

    reg = utils_ilog2(ctrl->f_agc_power_measurement_duration_in_state5 / 16);
    reg = CLAMP_T(uint32_t, reg, 0U, 15U);
    ad9361_spi_writef(REG_RX1_MANUAL_LPF_GAIN, POWER_MEAS_IN_STATE_5(~0), reg);
    ad9361_spi_writef(REG_RX1_MANUAL_LMT_FULL_GAIN, POWER_MEAS_IN_STATE_5_MSB, reg >> 3);

    return ad9361_gc_update();
}

/**
 * Set the GPO value.
 * @param phy The AD9361 state structure.
 * @param dac The GPO.
 * @param val_mV The value.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_gpo_set(uint8_t gpo, uint8_t val)
{
    if(gpo > 3)
        return -EINVAL;

    if(ad9361_spi_readf(REG_EXTERNAL_LNA_CTRL, GPO_MANUAL_SELECT) <= 0)
        return -ENODEV;

    ad9361_spi_writef(REG_GPO_FORCE_AND_INIT, BIT(4 + gpo), !!val);

    if(val)
        g_pAD9361Phy->pdata->gpo_ctrl.gpo_manual_mode_enable_mask |= BIT(gpo);
    else
        g_pAD9361Phy->pdata->gpo_ctrl.gpo_manual_mode_enable_mask &= ~BIT(gpo);

    return 0;
}

/**
 * Get the GPO value set manually.
 * @param phy The AD9361 state structure.
 * @param dac The GPO.
 * @return The value in case of success, negative error code otherwise.
 */
int32_t ad9361_gpo_get(uint8_t gpo)
{
    if(gpo > 3)
        return -EINVAL;

    if(ad9361_spi_readf(REG_EXTERNAL_LNA_CTRL, GPO_MANUAL_SELECT) <= 0)
        return -ENODEV;

    return ad9361_spi_readf(REG_GPO_FORCE_AND_INIT, BIT(4 + gpo));
}


/**
 * Set the Aux DAC.
 * @param phy The AD9361 state structure.
 * @param dac The DAC.
 * @param val_mV The value.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_auxdac_set(int32_t dac, int32_t val_mV)
{
    uint32_t val, tmp;

    DBGPRINTLN_CTX("DAC%"PRId32" = %"PRId32" mV", dac, val_mV);

    /* Disable DAC if val == 0, Ignored in ENSM Auto Mode */
    ad9361_spi_writef(REG_AUXDAC_ENABLE_CTRL, AUXDAC_MANUAL_BAR(dac), val_mV ? 0 : 1);

    if(val_mV < 306)
        val_mV = 306;

    if(val_mV < 1888)
    {
        val = ((val_mV - 306) * 1000) / 1469; /* Vref = 1V, Step = 2 */
        tmp = AUXDAC_1_VREF(0);
    }
    else
    {
        val = ((val_mV - 1761) * 1000) / 1512; /* Vref = 2.5V, Step = 2 */
        tmp = AUXDAC_1_VREF(3);
    }

    val = CLAMP_T(uint32_t, val, 0, 1023);

    switch(dac)
    {
        case 1:
            ad9361_spi_write(REG_AUXDAC_1_WORD, val >> 2);
            ad9361_spi_write(REG_AUXDAC_1_CONFIG, AUXDAC_1_WORD_LSB(val) | tmp);
            g_pAD9361Phy->auxdac1_value = val_mV;
        break;
        case 2:
            ad9361_spi_write(REG_AUXDAC_2_WORD, val >> 2);
            ad9361_spi_write(REG_AUXDAC_2_CONFIG, AUXDAC_2_WORD_LSB(val) | tmp);
            g_pAD9361Phy->auxdac2_value = val_mV;
        break;
        default:
            return -EINVAL;
        break;
    }

    return 0;
}

/**
 * Get the Aux DAC value.
 * @param phy The AD9361 state structure.
 * @param dac The DAC.
 * @return The value in case of success, negative error code otherwise.
 */
int32_t ad9361_auxdac_get(int32_t dac)
{
    switch(dac)
    {
        case 1:
            return g_pAD9361Phy->auxdac1_value;
        case 2:
            return g_pAD9361Phy->auxdac2_value;
        default:
            return -EINVAL;
    }

    return 0;
}

/**
 * Setup the AuxDAC.
 * @param phy The AD9361 state structure.
 * @param ctrl Pointer to ad9361_auxdac_control structure.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_auxdac_setup(struct ad9361_auxdac_control* ctrl)
{
    uint8_t tmp;

    ad9361_auxdac_set(1, ctrl->dac1_default_value);
    ad9361_auxdac_set(2, ctrl->dac2_default_value);

    tmp = ~(AUXDAC_AUTO_TX_BAR(ctrl->dac2_in_tx_en << 1 | ctrl->dac1_in_tx_en) | AUXDAC_AUTO_RX_BAR(ctrl->dac2_in_rx_en << 1 | ctrl->dac1_in_rx_en) | AUXDAC_INIT_BAR(ctrl->dac2_in_alert_en << 1 | ctrl->dac1_in_alert_en));

    ad9361_spi_writef(REG_AUXDAC_ENABLE_CTRL, AUXDAC_AUTO_TX_BAR(~0) | AUXDAC_AUTO_RX_BAR(~0) | AUXDAC_INIT_BAR(~0), tmp); /* Auto Control */

    ad9361_spi_writef(REG_EXTERNAL_LNA_CTRL, AUXDAC_MANUAL_SELECT, ctrl->auxdac_manual_mode_en);
    ad9361_spi_write(REG_AUXDAC1_RX_DELAY, ctrl->dac1_rx_delay_us);
    ad9361_spi_write(REG_AUXDAC1_TX_DELAY, ctrl->dac1_tx_delay_us);
    ad9361_spi_write(REG_AUXDAC2_RX_DELAY, ctrl->dac2_rx_delay_us);
    ad9361_spi_write(REG_AUXDAC2_TX_DELAY, ctrl->dac2_tx_delay_us);

    return 0;
}

/**
 * Setup the AuxADC.
 * @param phy The AD9361 state structure.
 * @param ctrl The AuxADC settings.
 * @param bbpll_freq The BBPLL frequency [Hz].
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_auxadc_setup(struct ad9361_auxadc_control* ctrl, uint32_t bbpll_freq)
{
    uint32_t val;

    val = DIV_ROUND(ctrl->temp_time_inteval_ms * (bbpll_freq / 1000UL), (1 << 29));

    ad9361_spi_write(REG_TEMP_OFFSET, ctrl->offset);
    ad9361_spi_write(REG_START_TEMP_READING, 0x00);
    ad9361_spi_write(REG_TEMP_SENSE2, MEASUREMENT_TIME_INTERVAL(val) | (ctrl->periodic_temp_measuremnt ? TEMP_SENSE_PERIODIC_ENABLE : 0));
    ad9361_spi_write(REG_TEMP_SENSOR_CONFIG, TEMP_SENSOR_DECIMATION( utils_ilog2(ctrl->temp_sensor_decimation) - 8));
    ad9361_spi_write(REG_AUXADC_CLOCK_DIVIDER, bbpll_freq / ctrl->auxadc_clock_rate);
    ad9361_spi_write(REG_AUXADC_CONFIG, AUX_ADC_DECIMATION( utils_ilog2(ctrl->auxadc_decimation) - 8));

    return 0;
}

/**
 * Get the measured temperature of the device.
 * @param phy The AD9361 state structure.
 * @return The measured temperature of the device.
 */
int32_t ad9361_get_temp()
{
    uint32_t val;

    ad9361_spi_writef(REG_AUXADC_CONFIG, AUXADC_POWER_DOWN, 1);
    val = ad9361_spi_read(REG_TEMPERATURE);
    ad9361_spi_writef(REG_AUXADC_CONFIG, AUXADC_POWER_DOWN, 0);

    return DIV_ROUND(val * 1000000, 1140);
}

/**
 * Get the Aux ADC value.
 * @param phy The AD9361 state structure.
 * @return The value in case of success, negative error code otherwise.
 */
int32_t ad9361_get_auxadc()
{
    uint8_t buf[2];

    ad9361_spi_writef(REG_AUXADC_CONFIG, AUXADC_POWER_DOWN, 1);
    ad9361_spi_readm(REG_AUXADC_LSB, buf, 2);
    ad9361_spi_writef(REG_AUXADC_CONFIG, AUXADC_POWER_DOWN, 0);

    return (buf[1] << 4) | AUXADC_WORD_LSB(buf[0]);
}

/**
 * Setup the Control Output pins.
 * @param phy The AD9361 state structure.
 * @param ctrl The Control Output pins settings.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_ctrl_outs_setup(struct ad9361_ctrl_out_control* ctrl)
{
    ad9361_spi_write(REG_CTRL_OUTPUT_POINTER, ctrl->index); // Ctrl Out index
    return ad9361_spi_write(REG_CTRL_OUTPUT_ENABLE, ctrl->en_mask); // Ctrl Out [7:0] output enable
}

/**
 * Setup the GPO pins.
 * @param phy The AD9361 state structure.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_gpo_setup(struct ad9361_gpo_control* ctrl)
{
    ad9361_spi_write(REG_AUTO_GPO, GPO_ENABLE_AUTO_RX(ctrl->gpo0_slave_rx_en | (ctrl->gpo1_slave_rx_en << 1) | (ctrl->gpo2_slave_rx_en << 2) | (ctrl->gpo3_slave_rx_en << 3)) | GPO_ENABLE_AUTO_TX(ctrl->gpo0_slave_tx_en | (ctrl->gpo1_slave_tx_en << 1) | (ctrl->gpo2_slave_tx_en << 2) | (ctrl->gpo3_slave_tx_en << 3)));

    ad9361_spi_write(REG_GPO_FORCE_AND_INIT, GPO_MANUAL_CTRL(ctrl->gpo_manual_mode_enable_mask) | GPO_INIT_STATE(ctrl->gpo0_inactive_state_high_en | (ctrl->gpo1_inactive_state_high_en << 1) | (ctrl->gpo2_inactive_state_high_en << 2) | (ctrl->gpo3_inactive_state_high_en << 3)));

    ad9361_spi_write(REG_GPO0_RX_DELAY, ctrl->gpo0_rx_delay_us);
    ad9361_spi_write(REG_GPO0_TX_DELAY, ctrl->gpo0_tx_delay_us);
    ad9361_spi_write(REG_GPO1_RX_DELAY, ctrl->gpo1_rx_delay_us);
    ad9361_spi_write(REG_GPO1_TX_DELAY, ctrl->gpo1_tx_delay_us);
    ad9361_spi_write(REG_GPO2_RX_DELAY, ctrl->gpo2_rx_delay_us);
    ad9361_spi_write(REG_GPO2_TX_DELAY, ctrl->gpo2_tx_delay_us);
    ad9361_spi_write(REG_GPO3_RX_DELAY, ctrl->gpo3_rx_delay_us);
    ad9361_spi_write(REG_GPO3_TX_DELAY, ctrl->gpo3_tx_delay_us);

    /*
     * GPO manual mode conflicts with automatic ENSM slave and eLNA mode
     */
    ad9361_spi_writef(REG_EXTERNAL_LNA_CTRL, GPO_MANUAL_SELECT, ctrl->gpo_manual_mode_en);

    return 0;
}

/**
 * Setup the RSSI.
 * @param phy The AD9361 state structure.
 * @param ctrl The RSSI settings.
 * @param is_update True if update
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_rssi_setup(struct ad9361_rssi_control* ctrl, bool is_update)
{
    uint32_t total_weight = 0, weight[4], total_dur = 0, temp;
    uint8_t dur_buf[4] = { 0 };
    int32_t val, ret;
    uint32_t rssi_delay;
    uint32_t rssi_wait;
    int32_t rssi_duration;
    uint32_t rate;

    if(ctrl->rssi_unit_is_rx_samples)
    {
        if(is_update)
            return 0; /* no update required */

        rssi_delay = ctrl->rssi_delay;
        rssi_wait = ctrl->rssi_wait;
        rssi_duration = ctrl->rssi_duration;
    }
    else
    {
        /* update sample based on RX rate */
        rate = DIV_ROUND(ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[RX_SAMPL_CLK]), 1000);
        /* units are in us */
        rssi_delay = DIV_ROUND(ctrl->rssi_delay * rate, 1000);
        rssi_wait = DIV_ROUND(ctrl->rssi_wait * rate, 1000);
        rssi_duration = DIV_ROUND(ctrl->rssi_duration * rate, 1000);
    }

    if(ctrl->restart_mode == EN_AGC_PIN_IS_PULLED_HIGH)
        rssi_delay = 0;

    rssi_delay = CLAMP(rssi_delay / 8, 0U, 255U);
    rssi_wait = CLAMP(rssi_wait / 4, 0U, 255U);

    uint8_t j = 0;

    do
    {
        for(int8_t i = 14; rssi_duration > 0 && i >= 0; i--)
        {
            val = 1 << i;

            if((int64_t)rssi_duration >= val)
            {
                dur_buf[j++] = i;
                total_dur += val;
                rssi_duration -= val;
                break;
            }
        }

    }
    while(j < 4 && rssi_duration > 0);

    for(uint8_t i = 0; i < 4; i++)
        if(i < j)
            total_weight += weight[i] = DIV_ROUND(RSSI_MAX_WEIGHT * (1 << dur_buf[i]), total_dur);
        else
            total_weight += weight[i] = 0;

    /* total of all weights must be 0xFF */
    val = total_weight - 0xFF;
    weight[j - 1] -= val;

    ad9361_spi_write(REG_MEASURE_DURATION_01, (dur_buf[1] << 4) | dur_buf[0]); // RSSI Measurement Duration 0, 1
    ad9361_spi_write(REG_MEASURE_DURATION_23, (dur_buf[3] << 4) | dur_buf[2]); // RSSI Measurement Duration 2, 3
    ad9361_spi_write(REG_RSSI_WEIGHT_0, weight[0]); // RSSI Weighted Multiplier 0
    ad9361_spi_write(REG_RSSI_WEIGHT_1, weight[1]); // RSSI Weighted Multiplier 1
    ad9361_spi_write(REG_RSSI_WEIGHT_2, weight[2]); // RSSI Weighted Multiplier 2
    ad9361_spi_write(REG_RSSI_WEIGHT_3, weight[3]); // RSSI Weighted Multiplier 3
    ad9361_spi_write(REG_RSSI_DELAY, rssi_delay); // RSSI Delay
    ad9361_spi_write(REG_RSSI_WAIT_TIME, rssi_wait); // RSSI Wait

    temp = RSSI_MODE_SELECT(ctrl->restart_mode);

    if(ctrl->restart_mode == SPI_WRITE_TO_REGISTER)
        temp |= START_RSSI_MEAS;

    if(rssi_duration == 0 && j == 1) /* Power of two */
        temp |= DEFAULT_RSSI_MEAS_MODE;

    ret = ad9361_spi_write(REG_RSSI_CONFIG, temp); // RSSI Mode Select

    if(ret < 0)
        DBGPRINTLN_CTX("Unable to write RSSI config");

    return 0;
}

/**
 * This function needs to be called whenever BBPLL changes.
 * @param phy The AD9361 state structure.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_bb_clk_change_handler()
{
    int32_t ret;

    ret = ad9361_gc_update();
    ret |= ad9361_rssi_setup(&g_pAD9361Phy->pdata->rssi_ctrl, true);
    ret |= ad9361_auxadc_setup(&g_pAD9361Phy->pdata->auxadc_ctrl, ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[BBPLL_CLK]));

    return ret;
}

/**
 * Set the desired Enable State Machine (ENSM) state.
 * @param phy The AD9361 state structure.
 * @param ensm_state The ENSM state [ENSM_STATE_SLEEP_WAIT, ENSM_STATE_ALERT,
 *                   ENSM_STATE_TX, ENSM_STATE_TX_FLUSH, ENSM_STATE_RX,
 *                   ENSM_STATE_RX_FLUSH, ENSM_STATE_FDD, ENSM_STATE_FDD_FLUSH].
 * @param pinctrl Set true, will enable the ENSM pin control.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_ensm_set_state(uint8_t ensm_state, bool pinctrl)
{
    int32_t rc = 0;
    uint32_t val;
    uint32_t tmp;

    DBGPRINTLN_CTX("Move device ENSM from %s (0x%X) to %s (0x%X)", ad9361_ensm_states[g_pAD9361Phy->curr_ensm_state], g_pAD9361Phy->curr_ensm_state, ad9361_ensm_states[ensm_state], ensm_state);

    if(g_pAD9361Phy->curr_ensm_state == ENSM_STATE_SLEEP)
    {
        ad9361_spi_write(REG_CLOCK_ENABLE, DIGITAL_POWER_UP | CLOCK_ENABLE_DFLT | BBPLL_ENABLE | (g_pAD9361Phy->pdata->use_extclk ? XO_BYPASS : 0)); /* Enable Clocks */

        usleep(20);

        ad9361_spi_write(REG_ENSM_CONFIG_1, TO_ALERT | FORCE_ALERT_STATE);
        ad9361_trx_vco_cal_control(false, true); /* Enable VCO Cal */
        ad9361_trx_vco_cal_control(true, true);
    }

    val = (g_pAD9361Phy->pdata->ensm_pin_pulse_mode ? 0 : LEVEL_MODE) | (pinctrl ? ENABLE_ENSM_PIN_CTRL : 0) | (g_pAD9361Phy->txmon_tdd_en ? ENABLE_RX_DATA_PORT_FOR_CAL : 0) | TO_ALERT;

    switch(ensm_state)
    {
        case ENSM_STATE_TX:
            val |= FORCE_TX_ON;

            if(g_pAD9361Phy->pdata->fdd)
                rc = -EINVAL;
            else if(g_pAD9361Phy->curr_ensm_state != ENSM_STATE_ALERT)
                rc = -EINVAL;
        break;
        case ENSM_STATE_RX:
            val |= FORCE_RX_ON;

            if(g_pAD9361Phy->pdata->fdd)
                rc = -EINVAL;
            else if(g_pAD9361Phy->curr_ensm_state != ENSM_STATE_ALERT)
                rc = -EINVAL;
        break;
        case ENSM_STATE_FDD:
            val |= FORCE_TX_ON;

            if(!g_pAD9361Phy->pdata->fdd)
                rc = -EINVAL;
        break;
        case ENSM_STATE_ALERT:
            val &= ~(FORCE_TX_ON | FORCE_RX_ON);
            val |= TO_ALERT | FORCE_ALERT_STATE;
        break;
        case ENSM_STATE_SLEEP_WAIT:
        break;
        case ENSM_STATE_SLEEP:
            ad9361_trx_vco_cal_control(false, false); /* Disable VCO Cal */
            ad9361_trx_vco_cal_control(true, false);
            ad9361_spi_write(REG_ENSM_CONFIG_1, 0); /* Clear To Alert */
            ad9361_spi_write(REG_ENSM_CONFIG_1, g_pAD9361Phy->pdata->fdd ? FORCE_TX_ON : FORCE_RX_ON);
            /* Delay Flush Time 384 ADC clock cycles */

            usleep(384000000UL / ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[ADC_CLK]));

            ad9361_spi_write(REG_ENSM_CONFIG_1, 0); /* Move to Wait*/

            usleep(1); /* Wait for ENSM settle */

            ad9361_spi_write(REG_CLOCK_ENABLE, (g_pAD9361Phy->pdata->use_extclk ? XO_BYPASS : 0)); /* Turn off all clocks */

            g_pAD9361Phy->curr_ensm_state = ensm_state;
            return 0;
        break;
        default:
            DBGPRINTLN_CTX("No handling for moving to ENSM state %s (0x%X)", ad9361_ensm_states[ensm_state], ensm_state);

            return rc;
        break;
    }

    if(rc < 0)
    {
        if((g_pAD9361Phy->curr_ensm_state != ENSM_STATE_ALERT) && (val & (FORCE_RX_ON | FORCE_TX_ON)))
        {
            uint32_t val2 = val;

            val2 &= ~(FORCE_TX_ON | FORCE_RX_ON);
            val2 |= TO_ALERT | FORCE_ALERT_STATE;

            ad9361_spi_write(REG_ENSM_CONFIG_1, val2);

            ad9361_check_cal_done(REG_STATE, ENSM_STATE(~0), ENSM_STATE_ALERT);
        }
        else
        {
            DBGPRINTLN_CTX("Invalid ENSM state transition in %s mode", g_pAD9361Phy->pdata->fdd ? "FDD" : "TDD");

            return rc;
        }
    }

    if(!g_pAD9361Phy->pdata->fdd && !pinctrl && !g_pAD9361Phy->pdata->tdd_use_dual_synth && (ensm_state == ENSM_STATE_TX || ensm_state == ENSM_STATE_RX))
    {
        uint32_t reg, check;

        if(ensm_state == ENSM_STATE_TX)
        {
            reg = REG_TX_CP_OVERRANGE_VCO_LOCK;
            check = !(g_pAD9361Phy->cached_synth_pd[0] & TX_SYNTH_VCO_POWER_DOWN);
        }
        else
        {
            reg = REG_RX_CP_OVERRANGE_VCO_LOCK;
            check = !(g_pAD9361Phy->cached_synth_pd[1] & RX_SYNTH_VCO_POWER_DOWN);
        }

        ad9361_spi_writef(REG_ENSM_CONFIG_2, TXNRX_SPI_CTRL, ensm_state == ENSM_STATE_TX);

        if(check)
            ad9361_check_cal_done(reg, VCO_LOCK, 1);
    }

    rc = ad9361_spi_write(REG_ENSM_CONFIG_1, val);

    if(rc)
        DBGPRINTLN_CTX("Failed to restore state");

    if((val & FORCE_RX_ON) && (g_pAD9361Phy->agc_mode[0] == RF_GAIN_MGC || g_pAD9361Phy->agc_mode[1] == RF_GAIN_MGC))
    {
        tmp = ad9361_spi_read(REG_SMALL_LMT_OVERLOAD_THRESH);

        ad9361_spi_write(REG_SMALL_LMT_OVERLOAD_THRESH, (tmp & SMALL_LMT_OVERLOAD_THRESH(~0)) | (g_pAD9361Phy->agc_mode[0] == RF_GAIN_MGC ? FORCE_PD_RESET_RX1 : 0) | (g_pAD9361Phy->agc_mode[1] == RF_GAIN_MGC ? FORCE_PD_RESET_RX2 : 0));
        ad9361_spi_write(REG_SMALL_LMT_OVERLOAD_THRESH, tmp & SMALL_LMT_OVERLOAD_THRESH(~0));
    }

    g_pAD9361Phy->curr_ensm_state = ensm_state;

    return rc;
}

/**
 * Check if at least one of the clock rates is equal to the DATA_CLK (lvds) rate.
 * @param phy The AD9361 state structure.
 * @param rx_path_clks RX path rates buffer.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_validate_trx_clock_chain(uint32_t* rx_path_clks, uint32_t* tx_path_clks)
{
    static const uint32_t max_rx_rates[] = {MAX_BBPLL_FREQ, MAX_ADC_CLK, MAX_RX_HB3, MAX_RX_HB2, MAX_RX_HB1, MAX_BASEBAND_RATE};
    static const uint32_t max_tx_rates[] = {MAX_BBPLL_FREQ, MAX_DAC_CLK, MAX_TX_HB3, MAX_TX_HB2, MAX_TX_HB1, MAX_BASEBAND_RATE};

    uint32_t data_clk = (g_pAD9361Phy->pdata->rx2tx2 ? 4 : 2) / ((g_pAD9361Phy->pdata->port_ctrl.pp_conf[2] & LVDS_MODE) ? 1 : 2) * rx_path_clks[RX_SAMPL_FREQ];

    /* CMOS Mode */
    if(!(g_pAD9361Phy->pdata->port_ctrl.pp_conf[2] & LVDS_MODE) && (data_clk > MAX_BASEBAND_RATE))
    {
        DBGPRINTLN_CTX("CMOS MODE DATA_CLK > %"PRIu64" SPS", MAX_BASEBAND_RATE);

        return -EINVAL;
    }

    /* Validate MAX PLL, ADC, DAC and HB filter rates */
    for(uint8_t i = 0; i < ARRAY_SIZE(max_rx_rates); i++)
    {
        if(rx_path_clks[i] > max_rx_rates[i])
        {
            DBGPRINTLN_CTX("Failed RX max rate check at %"PRIu8" (%"PRIu32" > %"PRIu32")", i, rx_path_clks[i], max_rx_rates[i]);

            return -EINVAL;
        }

        if(tx_path_clks[i] > max_tx_rates[i])
        {
            DBGPRINTLN_CTX("Failed TX max rate check at %"PRIu8" (%"PRIu32" > %"PRIu32")", i, tx_path_clks[i], max_tx_rates[i]);

            return -EINVAL;
        }
    }

    /* Validate that DATA_CLK exist within the clock chain */
    for(uint8_t i = 1; i <= 3; i++)
        if(D_ABS(rx_path_clks[ADC_FREQ] / i, data_clk) < 4)
            return 0;

    for(uint8_t i = 1; i <= 4; i++)
        if(D_ABS((rx_path_clks[R2_FREQ] >> i), data_clk) < 4)
            return 0;

    DBGPRINTLN_CTX("Failed - at least one of the clock rates must be equal to the DATA_CLK (LVDS) rate");

    return -EINVAL;
}

/**
 * Set the RX and TX path rates.
 * @param phy The AD9361 state structure.
 * @param rx_path_clks RX path rates buffer.
 * @param tx_path_clks TX path rates buffer.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_set_trx_clock_chain(uint32_t* rx_path_clks, uint32_t* tx_path_clks)
{
    int32_t ret;

    if(!rx_path_clks || !tx_path_clks)
        return -EINVAL;

    DBGPRINTLN_CTX("RX Rates - BBPLL: %"PRIu32" Hz, ADC: %"PRIu32" Hz, R2CLK: %"PRIu32" Hz, R1CLK: %"PRIu32" Hz, CLKRF: %"PRIu32" Hz, RSAMPL: %"PRIu32" Hz", rx_path_clks[BBPLL_FREQ], rx_path_clks[ADC_FREQ], rx_path_clks[R2_FREQ], rx_path_clks[R1_FREQ], rx_path_clks[CLKRF_FREQ], rx_path_clks[RX_SAMPL_FREQ]);
    DBGPRINTLN_CTX("TX Rates - BBPLL: %"PRIu32" Hz, DAC: %"PRIu32" Hz, T2CLK: %"PRIu32" Hz, T1CLK: %"PRIu32" Hz, CLKTF: %"PRIu32" Hz, TSAMPL: %"PRIu32" Hz", tx_path_clks[BBPLL_FREQ], tx_path_clks[DAC_FREQ], tx_path_clks[T2_FREQ], tx_path_clks[T1_FREQ], tx_path_clks[CLKTF_FREQ], tx_path_clks[TX_SAMPL_FREQ]);

    ret = ad9361_validate_trx_clock_chain(rx_path_clks, tx_path_clks);

    if(ret < 0)
        return ret;

    ret = ad9361_clk_set_rate(g_pAD9361Phy->ref_clk_scale[BBPLL_CLK], rx_path_clks[BBPLL_FREQ]);

    if(ret < 0)
        return ret;

    g_pAD9361Phy->current_rx_path_clks[BBPLL_FREQ] = rx_path_clks[BBPLL_FREQ];

    for(uint8_t i = ADC_CLK, j = DAC_CLK, n = ADC_FREQ; i <= RX_SAMPL_CLK; i++, j++, n++)
    {
        ret = ad9361_clk_set_rate(g_pAD9361Phy->ref_clk_scale[i], rx_path_clks[n]);

        if(ret < 0)
        {
            DBGPRINTLN_CTX("Failed to set RX BB ref clock rate (%"PRId32")", ret);

            return ret;
        }

        g_pAD9361Phy->current_rx_path_clks[n] = rx_path_clks[n];

        ret = ad9361_clk_set_rate(g_pAD9361Phy->ref_clk_scale[j], tx_path_clks[n]);

        if(ret < 0)
        {
            DBGPRINTLN_CTX("Failed to set TX BB ref clock rate (%"PRId32")", ret);

            return ret;
        }

        g_pAD9361Phy->current_tx_path_clks[n] = tx_path_clks[n];
    }

    /*
     * Workaround for clock framework since clocks don't change we
     * manually need to enable the filter
     */

    if(g_pAD9361Phy->rx_fir_dec == 1 || g_pAD9361Phy->bypass_rx_fir)
        ad9361_spi_writef(REG_RX_ENABLE_FILTER_CTRL, RX_FIR_ENABLE_DECIMATION(~0), !g_pAD9361Phy->bypass_rx_fir);

    if(g_pAD9361Phy->tx_fir_int == 1 || g_pAD9361Phy->bypass_tx_fir)
        ad9361_spi_writef(REG_TX_ENABLE_FILTER_CTRL, TX_FIR_ENABLE_INTERPOLATION(~0), !g_pAD9361Phy->bypass_tx_fir);

    /* The FIR filter once enabled causes the interface timing to change.
     * It's typically not a problem if the timing margin is big enough.
     * However at 61.44 MSPS it causes problems on some systems.
     * So we always run the digital tune in case the filter is enabled.
     * If it is disabled we restore the values from the initial calibration.
     */

    if(!g_pAD9361Phy->pdata->dig_interface_tune_fir_disable && !(g_pAD9361Phy->bypass_tx_fir && g_pAD9361Phy->bypass_rx_fir))
        ad9361_util_dig_tune(0, SKIP_STORE_RESULT);

    return ad9361_bb_clk_change_handler();
}

/**
 * Get the RX and TX path rates.
 * @param phy The AD9361 state structure.
 * @param rx_path_clks RX path rates buffer.
 * @param tx_path_clks TX path rates buffer.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_get_trx_clock_chain(uint32_t* rx_path_clks, uint32_t* tx_path_clks)
{
    uint32_t bbpll_freq;

    if(!rx_path_clks && !tx_path_clks)
        return -EINVAL;

    bbpll_freq = ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[BBPLL_CLK]);

    if(rx_path_clks)
        rx_path_clks[BBPLL_FREQ] = bbpll_freq;

    if(tx_path_clks)
        tx_path_clks[BBPLL_FREQ] = bbpll_freq;

    for(uint8_t i = ADC_CLK, j = DAC_CLK, n = ADC_FREQ; i <= RX_SAMPL_CLK; i++, j++, n++)
    {
        if(rx_path_clks)
            rx_path_clks[n] = ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[i]);

        if(tx_path_clks)
            tx_path_clks[n] = ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[j]);
    }

    return 0;
}

/**
 * Calculate the RX and TX path rates to obtain the desired sample rate.
 * @param phy The AD9361 state structure.
 * @param tx_sample_rate The desired sample rate.
 * @param rate_gov The rate governor option.
 * @param rx_path_clks RX path rates buffer.
 * @param tx_path_clks TX path rates buffer.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_calculate_rf_clock_chain(uint32_t tx_sample_rate, uint32_t rate_gov, uint32_t* rx_path_clks, uint32_t* tx_path_clks)
{
    const uint8_t clk_dividers[][4] =
    {
        {12, 3, 2, 2},
        {8, 2, 2, 2},
        {6, 3, 1, 2},
        {4, 2, 2, 1},
        {3, 3, 1, 1},
        {2, 2, 1, 1},
        {1, 1, 1, 1},
    };

    uint32_t clktf, clkrf, adc_rate = 0, dac_rate = 0;
    uint64_t bbpll_rate;
    int32_t index_rx = -1, index_tx = -1, tmp;
    uint32_t div, tx_intdec, rx_intdec, recursion = 1;

    if(g_pAD9361Phy->bypass_rx_fir)
        rx_intdec = 1;
    else
        rx_intdec = g_pAD9361Phy->rx_fir_dec;

    if(g_pAD9361Phy->bypass_tx_fir)
        tx_intdec = 1;
    else
        tx_intdec = g_pAD9361Phy->tx_fir_int;

    if((rate_gov == 1) && ((rx_intdec * tx_sample_rate * 8) < MIN_ADC_CLK))
    {
        recursion = 0;
        rate_gov = 0;
    }

    DBGPRINTLN_CTX("Requested rate: %"PRIu32" Hz, TXFIR int: %"PRIu32", RXFIR dec: %"PRIu32", mode %s", tx_sample_rate, tx_intdec, rx_intdec, rate_gov ? "Nominal" : "Highest OSR");

    if(tx_sample_rate > MAX_BASEBAND_RATE)
        return -EINVAL;

    clktf = tx_sample_rate * tx_intdec;
    clkrf = tx_sample_rate * rx_intdec * (g_pAD9361Phy->rx_eq_2tx ? 2 : 1);

    for(uint32_t i = rate_gov; i < 7; i++)
    {
        adc_rate = clkrf * clk_dividers[i][0];
        dac_rate = clktf * clk_dividers[i][0];

        if((adc_rate <= MAX_ADC_CLK) && (adc_rate >= MIN_ADC_CLK))
        {
            if(dac_rate > adc_rate)
                tmp = (dac_rate / adc_rate) * -1;
            else
                tmp = adc_rate / dac_rate;

            if(adc_rate <= MAX_DAC_CLK)
            {
                index_rx = i;
                index_tx = i - ((tmp == 1) ? 0 : tmp);
                dac_rate = adc_rate; /* ADC_CLK */

                break;
            }
            else
            {
                dac_rate = adc_rate / 2;  /* ADC_CLK/2 */
                index_rx = i;

                if(i == 4 && tmp >= 0)
                    index_tx = 7; /* STOP: 3/2 != 1 */
                else
                    index_tx = i + ((i == 5 && tmp >= 0) ? 1 : 2) - ((tmp == 1) ? 0 : tmp);

                break;
            }
        }
    }

    if((index_tx < 0 || index_tx > 6 || index_rx < 0 || index_rx > 6) && rate_gov < 7 && recursion)
    {
        return ad9361_calculate_rf_clock_chain(tx_sample_rate, ++rate_gov, rx_path_clks, tx_path_clks);
    }
    else if((index_tx < 0 || index_tx > 6 || index_rx < 0 || index_rx > 6))
    {
        DBGPRINTLN_CTX("Failed to find suitable dividers: %s", (adc_rate < MIN_ADC_CLK) ? "ADC clock below limit" : "BBPLL rate above limit");

        return -EINVAL;
    }

    /* Calculate target BBPLL rate */
    div = MAX_BBPLL_DIV;

    do
    {
        bbpll_rate = (uint64_t)adc_rate * div;
        div >>= 1;

    }
    while((bbpll_rate > MAX_BBPLL_FREQ) && (div >= MIN_BBPLL_DIV));

    rx_path_clks[BBPLL_FREQ] = bbpll_rate;
    rx_path_clks[ADC_FREQ] = adc_rate;
    rx_path_clks[R2_FREQ] = rx_path_clks[ADC_FREQ] / clk_dividers[index_rx][1];
    rx_path_clks[R1_FREQ] = rx_path_clks[R2_FREQ] / clk_dividers[index_rx][2];
    rx_path_clks[CLKRF_FREQ] = rx_path_clks[R1_FREQ] / clk_dividers[index_rx][3];
    rx_path_clks[RX_SAMPL_FREQ] = rx_path_clks[CLKRF_FREQ] / rx_intdec;

    tx_path_clks[BBPLL_FREQ] = bbpll_rate;
    tx_path_clks[DAC_FREQ] = dac_rate;
    tx_path_clks[T2_FREQ] = tx_path_clks[DAC_FREQ] / clk_dividers[index_tx][1];
    tx_path_clks[T1_FREQ] = tx_path_clks[T2_FREQ] / clk_dividers[index_tx][2];
    tx_path_clks[CLKTF_FREQ] = tx_path_clks[T1_FREQ] / clk_dividers[index_tx][3];
    tx_path_clks[TX_SAMPL_FREQ] = tx_path_clks[CLKTF_FREQ] / tx_intdec;

    return 0;
}

/**
 * Set the desired sample rate.
 * @param phy The AD9361 state structure.
 * @param freq The desired sample rate.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_set_trx_clock_chain_freq(uint32_t freq)
{
    uint32_t rx[6], tx[6];
    int32_t ret;

    ret = ad9361_calculate_rf_clock_chain(freq, g_pAD9361Phy->rate_governor, rx, tx);

    if(ret < 0)
        return ret;

    return ad9361_set_trx_clock_chain(rx, tx);
}

/**
 * Internal ENSM mode options helper function.
 * @param phy The AD9361 state structure.
 * @param fdd
 * @param pinctrl
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_set_ensm_mode(bool fdd, bool pinctrl)
{
    struct ad9361_phy_platform_data* pd = g_pAD9361Phy->pdata;
    int32_t ret;
    uint32_t val = 0;

    ad9361_spi_write(REG_ENSM_MODE, fdd ? FDD_MODE : 0);

    val = ad9361_spi_read(REG_ENSM_CONFIG_2);
    val &= POWER_DOWN_RX_SYNTH | POWER_DOWN_TX_SYNTH | RX_SYNTH_READY_MASK | TX_SYNTH_READY_MASK;

    if(fdd)
        ret = ad9361_spi_write(REG_ENSM_CONFIG_2, val | DUAL_SYNTH_MODE | (pd->fdd_independent_mode ? FDD_EXTERNAL_CTRL_ENABLE : 0));
    else
        ret = ad9361_spi_write(REG_ENSM_CONFIG_2, val | (pd->tdd_use_dual_synth ? DUAL_SYNTH_MODE : 0) | (pd->tdd_use_dual_synth ? 0 : (pinctrl ? SYNTH_ENABLE_PIN_CTRL_MODE : 0)));

    return ret;
}

/**
 * Fastlock read value.
 * @param spi
 * @param tx
 * @param profile
 * @param word
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_fastlock_readval(bool tx, uint32_t profile, uint32_t word)
{
    uint32_t offs = 0;

    if(tx)
        offs = REG_TX_FAST_LOCK_SETUP - REG_RX_FAST_LOCK_SETUP;

    ad9361_spi_write(REG_RX_FAST_LOCK_PROGRAM_ADDR + offs, RX_FAST_LOCK_PROFILE_ADDR(profile) | RX_FAST_LOCK_PROFILE_WORD(word));

    return ad9361_spi_read(REG_RX_FAST_LOCK_PROGRAM_READ + offs);
}

/**
 * Fastlock write value.
 * @param tx
 * @param profile
 * @param word
 * @param val
 * @param last
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_fastlock_writeval(bool tx, uint32_t profile, uint32_t word, uint8_t val, bool last)
{
    uint32_t offs = 0;
    int32_t ret;

    if(tx)
        offs = REG_TX_FAST_LOCK_SETUP - REG_RX_FAST_LOCK_SETUP;

    ret = ad9361_spi_write(REG_RX_FAST_LOCK_PROGRAM_ADDR + offs, RX_FAST_LOCK_PROFILE_ADDR(profile) | RX_FAST_LOCK_PROFILE_WORD(word));
    ret |= ad9361_spi_write(REG_RX_FAST_LOCK_PROGRAM_DATA + offs, val);
    ret |= ad9361_spi_write(REG_RX_FAST_LOCK_PROGRAM_CTRL + offs, RX_FAST_LOCK_PROGRAM_WRITE | RX_FAST_LOCK_PROGRAM_CLOCK_ENABLE);

    if(last) /* Stop Clocks */
        ret |= ad9361_spi_write(REG_RX_FAST_LOCK_PROGRAM_CTRL + offs, 0);

    return ret;
}

/**
 * Fastlock load values.
 * @param phy The AD9361 state structure.
 * @param tx
 * @param profile
 * @param values
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_fastlock_load(bool tx, uint32_t profile, uint8_t* values)
{
    uint32_t offs = 0;
    int32_t ret = 0;
    uint8_t buf[4];

    DBGPRINTLN_CTX("%s Profile: %"PRIu32, tx ? "TX" : "RX", profile);

    if(tx)
        offs = REG_TX_FAST_LOCK_SETUP - REG_RX_FAST_LOCK_SETUP;

    buf[0] = values[0];
    buf[1] = RX_FAST_LOCK_PROFILE_ADDR(profile) | RX_FAST_LOCK_PROFILE_WORD(0);

    ad9361_spi_writem(REG_RX_FAST_LOCK_PROGRAM_DATA + offs, buf, 2);

    for(uint8_t i = 1; i < RX_FAST_LOCK_CONFIG_WORD_NUM; i++)
    {
        buf[0] = RX_FAST_LOCK_PROGRAM_WRITE | RX_FAST_LOCK_PROGRAM_CLOCK_ENABLE;
        buf[1] = 0;
        buf[2] = values[i];
        buf[3] = RX_FAST_LOCK_PROFILE_ADDR(profile) | RX_FAST_LOCK_PROFILE_WORD(i);

        ad9361_spi_writem(REG_RX_FAST_LOCK_PROGRAM_CTRL + offs, buf, 4);
    }

    ad9361_spi_write(REG_RX_FAST_LOCK_PROGRAM_CTRL + offs, RX_FAST_LOCK_PROGRAM_WRITE | RX_FAST_LOCK_PROGRAM_CLOCK_ENABLE);
    ad9361_spi_write(REG_RX_FAST_LOCK_PROGRAM_CTRL + offs, 0);

    g_pAD9361Phy->fastlock.entry[tx][profile].flags = FASTLOOK_INIT;
    g_pAD9361Phy->fastlock.entry[tx][profile].alc_orig = values[15];
    g_pAD9361Phy->fastlock.entry[tx][profile].alc_written = values[15];

    return ret;
}

/**
 * Fastlock store.
 * @param phy The AD9361 state structure.
 * @param tx
 * @param profile
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_fastlock_store(bool tx, uint32_t profile)
{
    uint8_t val[16];
    uint32_t offs = 0, x, y;

    DBGPRINTLN_CTX("%s Profile: %"PRIu32, tx ? "TX" : "RX", profile);

    if(tx)
        offs = REG_TX_FAST_LOCK_SETUP - REG_RX_FAST_LOCK_SETUP;

    val[0] = ad9361_spi_read(REG_RX_INTEGER_BYTE_0 + offs);
    val[1] = ad9361_spi_read(REG_RX_INTEGER_BYTE_1 + offs);
    val[2] = ad9361_spi_read(REG_RX_FRACT_BYTE_0 + offs);
    val[3] = ad9361_spi_read(REG_RX_FRACT_BYTE_1 + offs);
    val[4] = ad9361_spi_read(REG_RX_FRACT_BYTE_2 + offs);

    x = ad9361_spi_readf(REG_RX_VCO_BIAS_1 + offs, VCO_BIAS_REF(~0));
    y = ad9361_spi_readf(REG_RX_ALC_VARACTOR + offs, VCO_VARACTOR(~0));
    val[5] = (x << 4) | y;

    x = ad9361_spi_readf(REG_RX_VCO_BIAS_1 + offs, VCO_BIAS_TCF(~0));
    y = ad9361_spi_readf(REG_RX_CP_CURRENT + offs, CHARGE_PUMP_CURRENT(~0));
    /* Wide BW option: N = 1
    * Set init and steady state values to the same - let user space handle it
    */
    val[6] = (x << 6) | y;
    val[7] = y;

    x = ad9361_spi_readf(REG_RX_LOOP_FILTER_3 + offs, LOOP_FILTER_R3(~0));
    val[8] = (x << 4) | x;

    x = ad9361_spi_readf(REG_RX_LOOP_FILTER_2 + offs, LOOP_FILTER_C3(~0));
    val[9] = (x << 4) | x;

    x = ad9361_spi_readf(REG_RX_LOOP_FILTER_1 + offs, LOOP_FILTER_C1(~0));
    y = ad9361_spi_readf(REG_RX_LOOP_FILTER_1 + offs, LOOP_FILTER_C2(~0));
    val[10] = (x << 4) | y;

    x = ad9361_spi_readf(REG_RX_LOOP_FILTER_2 + offs, LOOP_FILTER_R1(~0));
    val[11] = (x << 4) | x;

    x = ad9361_spi_readf(REG_RX_VCO_VARACTOR_CTRL_0 + offs, VCO_VARACTOR_REFERENCE_TCF(~0));
    y = ad9361_spi_readf(REG_RFPLL_DIVIDERS, tx ? TX_VCO_DIVIDER(~0) : RX_VCO_DIVIDER(~0));
    val[12] = (x << 4) | y;

    x = ad9361_spi_readf(REG_RX_FORCE_VCO_TUNE_1 + offs, VCO_CAL_OFFSET(~0));
    y = ad9361_spi_readf(REG_RX_VCO_VARACTOR_CTRL_1 + offs, VCO_VARACTOR_REFERENCE(~0));
    val[13] = (x << 4) | y;

    val[14] = ad9361_spi_read(REG_RX_FORCE_VCO_TUNE_0 + offs);

    x = ad9361_spi_readf(REG_RX_FORCE_ALC + offs, FORCE_ALC_WORD(~0));
    y = ad9361_spi_readf(REG_RX_FORCE_VCO_TUNE_1 + offs, FORCE_VCO_TUNE);
    val[15] = (x << 1) | y;

    return ad9361_fastlock_load(tx, profile, val);
}

/**
 * Fastlock prepare.
 * @param phy The AD9361 state structure.
 * @param tx
 * @param profile
 * @param prepare
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_fastlock_prepare(bool tx, uint32_t profile, bool prepare)
{
    uint32_t offs, ready_mask;
    bool is_prepared;

    DBGPRINTLN_CTX("%s Profile: %"PRIu32", %s", tx ? "TX" : "RX", profile, prepare ? "Prepare" : "Un-Prepare");

    if(tx)
    {
        offs = REG_TX_FAST_LOCK_SETUP - REG_RX_FAST_LOCK_SETUP;
        ready_mask = TX_SYNTH_READY_MASK;
    }
    else
    {
        offs = 0;
        ready_mask = RX_SYNTH_READY_MASK;
    }

    is_prepared = !!g_pAD9361Phy->fastlock.current_profile[tx];

    if(prepare && !is_prepared)
    {
        ad9361_spi_write( REG_RX_FAST_LOCK_SETUP_INIT_DELAY + offs, (tx ? g_pAD9361Phy->pdata->tx_fastlock_delay_ns : g_pAD9361Phy->pdata->rx_fastlock_delay_ns) / 250);
        ad9361_spi_write(REG_RX_FAST_LOCK_SETUP + offs, RX_FAST_LOCK_PROFILE(profile) | RX_FAST_LOCK_MODE_ENABLE);
        ad9361_spi_write(REG_RX_FAST_LOCK_PROGRAM_CTRL + offs, 0);

        ad9361_spi_writef(REG_ENSM_CONFIG_2, ready_mask, 1);
        ad9361_trx_vco_cal_control(tx, false);
    }
    else if(!prepare && is_prepared)
    {
        ad9361_spi_write(REG_RX_FAST_LOCK_SETUP + offs, 0);

        /* Workaround: Exiting Fastlock Mode */
        ad9361_spi_writef(REG_RX_FORCE_ALC + offs, FORCE_ALC_ENABLE, 1);
        ad9361_spi_writef(REG_RX_FORCE_VCO_TUNE_1 + offs, FORCE_VCO_TUNE, 1);
        ad9361_spi_writef(REG_RX_FORCE_ALC + offs, FORCE_ALC_ENABLE, 0);
        ad9361_spi_writef(REG_RX_FORCE_VCO_TUNE_1 + offs, FORCE_VCO_TUNE, 0);

        ad9361_trx_vco_cal_control(tx, true);
        ad9361_spi_writef(REG_ENSM_CONFIG_2, ready_mask, 0);

        g_pAD9361Phy->fastlock.current_profile[tx] = 0;
    }

    return 0;
}

/**
 * Fastlock recall.
 * @param phy The AD9361 state structure.
 * @param tx
 * @param profile
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_fastlock_recall(bool tx, uint32_t profile)
{
    uint32_t offs = 0;
    uint8_t curr, _new, orig, current_profile;

    DBGPRINTLN_CTX("%s Profile: %"PRIu32, tx ? "TX" : "RX", profile);

    if(tx)
        offs = REG_TX_FAST_LOCK_SETUP - REG_RX_FAST_LOCK_SETUP;

    if(g_pAD9361Phy->fastlock.entry[tx][profile].flags != FASTLOOK_INIT)
        return -EINVAL;

    /* Workaround: Lock problem with same ALC word */

    current_profile = g_pAD9361Phy->fastlock.current_profile[tx];
    _new = g_pAD9361Phy->fastlock.entry[tx][profile].alc_written;

    if(current_profile == 0)
        curr = ad9361_spi_readf(REG_RX_FORCE_ALC + offs, FORCE_ALC_WORD(~0)) << 1;
    else
        curr = g_pAD9361Phy->fastlock.entry[tx][current_profile - 1].alc_written;

    if((curr >> 1) == (_new >> 1))
    {
        orig = g_pAD9361Phy->fastlock.entry[tx][profile].alc_orig;

        if((orig >> 1) == (_new >> 1))
            g_pAD9361Phy->fastlock.entry[tx][profile].alc_written += 2;
        else
            g_pAD9361Phy->fastlock.entry[tx][profile].alc_written = orig;

        ad9361_fastlock_writeval(tx, profile, 0xF, g_pAD9361Phy->fastlock.entry[tx][profile].alc_written, true);
    }

    ad9361_fastlock_prepare(tx, profile, true);

    g_pAD9361Phy->fastlock.current_profile[tx] = profile + 1;

    return ad9361_spi_write(REG_RX_FAST_LOCK_SETUP + offs, RX_FAST_LOCK_PROFILE(profile) | (g_pAD9361Phy->pdata->trx_fastlock_pinctrl_en[tx] ? RX_FAST_LOCK_PROFILE_PIN_SELECT : 0) | RX_FAST_LOCK_MODE_ENABLE);
}

/**
 * Fastlock save.
 * @param phy The AD9361 state structure.
 * @param tx
 * @param profile
 * @param values
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_fastlock_save(bool tx, uint32_t profile, uint8_t* values)
{
    int32_t i;

    DBGPRINTLN_CTX("%s Profile: %"PRIu32, tx ? "TX" : "RX", profile);

    for(i = 0; i < RX_FAST_LOCK_CONFIG_WORD_NUM; i++)
        values[i] = ad9361_fastlock_readval(tx, profile, i);

    return 0;
}

/**
 * Multi Chip Sync (MCS) config.
 * @param phy The AD9361 state structure.
 * @param step MCS step.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_mcs(int32_t step)
{
    int32_t mcs_mask = MCS_RF_ENABLE | MCS_BBPLL_ENABLE | MCS_DIGITAL_CLK_ENABLE | MCS_BB_ENABLE;

    DBGPRINTLN_CTX("MCS step: %"PRId32, step);

    switch(step)
    {
        case 1:
            /* REVIST:
            * POWER_DOWN_TRX_SYNTH and MCS_RF_ENABLE somehow conflict
            */
            ad9361_spi_writef(REG_ENSM_CONFIG_2, POWER_DOWN_TX_SYNTH | POWER_DOWN_RX_SYNTH, 0);

            ad9361_spi_writef(REG_MULTICHIP_SYNC_AND_TX_MON_CTRL, mcs_mask, MCS_BB_ENABLE | MCS_BBPLL_ENABLE | MCS_RF_ENABLE);
            ad9361_spi_writef(REG_CP_BLEED_CURRENT, MCS_REFCLK_SCALE_EN, 1);
        break;
        case 2:
            /*
             * NOTE: This is not a regular GPIO -
             * HDL ensures Multi-chip Synchronization SYNC_IN Pulse Timing
             * relative to rising and falling edge of REF_CLK
             */

            axi_gpio_set_value(AXI_GPIO_TRX_INST, AXI_GPIO0_TRX_SYNC_IN_BIT, 1);
            axi_gpio_set_value(AXI_GPIO_TRX_INST, AXI_GPIO0_TRX_SYNC_IN_BIT, 0);
        break;
        case 3:
            ad9361_spi_writef(REG_MULTICHIP_SYNC_AND_TX_MON_CTRL, mcs_mask, MCS_BB_ENABLE | MCS_DIGITAL_CLK_ENABLE | MCS_RF_ENABLE);
        break;
        case 4:
            axi_gpio_set_value(AXI_GPIO_TRX_INST, AXI_GPIO0_TRX_SYNC_IN_BIT, 1);
            axi_gpio_set_value(AXI_GPIO_TRX_INST, AXI_GPIO0_TRX_SYNC_IN_BIT, 0);
        break;
        case 5:
            ad9361_spi_writef(REG_MULTICHIP_SYNC_AND_TX_MON_CTRL, mcs_mask, MCS_RF_ENABLE);
        break;
    }

    return 0;
}

/**
 * Clear state.
 * @param phy The AD9361 state structure.
 * @return None.
 */
void ad9361_clear_state()
{
    g_pAD9361Phy->current_table = NO_GAIN_TABLE;
    g_pAD9361Phy->bypass_tx_fir = true;
    g_pAD9361Phy->bypass_rx_fir = true;
    g_pAD9361Phy->rate_governor = 1;
    g_pAD9361Phy->rfdc_track_en = true;
    g_pAD9361Phy->bbdc_track_en = true;
    g_pAD9361Phy->quad_track_en = true;
    g_pAD9361Phy->prev_ensm_state = 0;
    g_pAD9361Phy->curr_ensm_state = 0;
    g_pAD9361Phy->auto_cal_en = false;
    g_pAD9361Phy->manual_tx_quad_cal_en = false;
    g_pAD9361Phy->last_tx_quad_cal_freq = 0;
    g_pAD9361Phy->flags = 0;
    g_pAD9361Phy->current_rx_bw_Hz = 0;
    g_pAD9361Phy->current_tx_bw_Hz = 0;
    g_pAD9361Phy->rxbbf_div = 0;
    g_pAD9361Phy->tx_fir_int = 0;
    g_pAD9361Phy->tx_fir_ntaps = 0;
    g_pAD9361Phy->rx_fir_dec = 0;
    g_pAD9361Phy->rx_fir_ntaps = 0;
    g_pAD9361Phy->ensm_pin_ctl_en = false;
    g_pAD9361Phy->txmon_tdd_en = 0;
    g_pAD9361Phy->current_tx_lo_freq = 0;
    g_pAD9361Phy->current_rx_lo_freq = 0;
    g_pAD9361Phy->current_tx_use_tdd_table = false;
    g_pAD9361Phy->current_rx_use_tdd_table = false;
    g_pAD9361Phy->cached_synth_pd[0] = 0;
    g_pAD9361Phy->cached_synth_pd[1] = 0;

    memset(&g_pAD9361Phy->fastlock, 0, sizeof(g_pAD9361Phy->fastlock));
}

/**
 * Determine the reference frequency value.
 * @param refin_Hz Maximum allowed frequency.
 * @param max Reference in frequency value.
 * @return Reference frequency value.
 */
static uint32_t ad9361_ref_div_sel(uint32_t refin_Hz, uint32_t max)
{
    if(refin_Hz <= (max / 2))
        return 2 * refin_Hz;
    else if(refin_Hz <= max)
        return refin_Hz;
    else if(refin_Hz <= (max * 2))
        return refin_Hz / 2;
    else if(refin_Hz <= (max * 4))
        return refin_Hz / 4;
    else
        return 0;
}

/**
 * Setup the AD9361 device.
 * @param phy The AD9361 state structure.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_setup()
{
    uint32_t refin_Hz, ref_freq, bbpll_freq;
    struct ad9361_phy_platform_data* pd = g_pAD9361Phy->pdata;
    int32_t ret;
    uint32_t real_rx_bandwidth, real_tx_bandwidth;
    bool tmp_use_ext_rx_lo = pd->use_ext_rx_lo;
    bool tmp_use_ext_tx_lo = pd->use_ext_tx_lo;

    pd->rf_rx_bandwidth_Hz = ad9361_validate_rf_bw(pd->rf_rx_bandwidth_Hz);
    pd->rf_tx_bandwidth_Hz = ad9361_validate_rf_bw(pd->rf_tx_bandwidth_Hz);

    real_rx_bandwidth = pd->rf_rx_bandwidth_Hz / 2;
    real_tx_bandwidth = pd->rf_tx_bandwidth_Hz / 2;

    if(pd->fdd)
    {
        pd->tdd_skip_vco_cal = false;

        if(pd->ensm_pin_ctrl && pd->fdd_independent_mode)
        {
            DBGPRINTLN_CTX("Either set ENSM PINCTRL or FDD Independent Mode");

            pd->ensm_pin_ctrl = false;
        }
    }

    ret = ad9361_auxdac_setup(&pd->auxdac_ctrl);

    if(ret < 0)
        return ret;

    ret = ad9361_gpo_setup(&pd->gpo_ctrl);

    if(ret < 0)
        return ret;

    if(pd->port_ctrl.pp_conf[2] & FDD_RX_RATE_2TX_RATE)
        g_pAD9361Phy->rx_eq_2tx = true;

    ad9361_spi_write(REG_CTRL, CTRL_ENABLE);
    ad9361_spi_write(REG_BANDGAP_CONFIG0, MASTER_BIAS_TRIM(0x0E)); /* Enable Master Bias */
    ad9361_spi_write(REG_BANDGAP_CONFIG1, BANDGAP_TEMP_TRIM(0x0E)); /* Set Bandgap Trim */

    ad9361_set_dcxo_tune(pd->dcxo_coarse, pd->dcxo_fine);

    refin_Hz = g_pAD9361Phy->clk_refin->rate;

    ref_freq = ad9361_ref_div_sel(refin_Hz, MAX_BBPLL_FREF);

    if(!ref_freq)
        return -EINVAL;

    ad9361_spi_writef(REG_REF_DIVIDE_CONFIG_1, RX_REF_RESET_BAR, 1);
    ad9361_spi_writef(REG_REF_DIVIDE_CONFIG_2, TX_REF_RESET_BAR, 1);
    ad9361_spi_writef(REG_REF_DIVIDE_CONFIG_2, TX_REF_DOUBLER_FB_DELAY(~0), 3); /* FB DELAY */
    ad9361_spi_writef(REG_REF_DIVIDE_CONFIG_2, RX_REF_DOUBLER_FB_DELAY(~0), 3); /* FB DELAY */

    ad9361_spi_write(REG_CLOCK_ENABLE, DIGITAL_POWER_UP | CLOCK_ENABLE_DFLT | BBPLL_ENABLE | (pd->use_extclk ? XO_BYPASS : 0)); /* Enable Clocks */

    ret = ad9361_clk_set_rate(g_pAD9361Phy->ref_clk_scale[BB_REFCLK], ref_freq);

    if(ret < 0)
    {
        DBGPRINTLN_CTX("Failed to set BB ref clock rate (%"PRId32")", ret);

        return ret;
    }

    ad9361_spi_write(REG_FRACT_BB_FREQ_WORD_2, 0x12);
    ad9361_spi_write(REG_FRACT_BB_FREQ_WORD_3, 0x34);

    ret = ad9361_set_trx_clock_chain(pd->rx_path_clks, pd->tx_path_clks);

    if(ret < 0)
        return ret;

    if(!pd->rx2tx2)
    {
        pd->rx1tx1_mode_use_tx_num = CLAMP_T(uint32_t, pd->rx1tx1_mode_use_tx_num, TX_1, TX_2);
        pd->rx1tx1_mode_use_rx_num = CLAMP_T(uint32_t, pd->rx1tx1_mode_use_rx_num, RX_1, RX_2);

        ad9361_en_dis_tx(TX_1 | TX_2, pd->rx1tx1_mode_use_tx_num);
        ad9361_en_dis_rx(TX_1 | TX_2, pd->rx1tx1_mode_use_rx_num);
    }
    else
    {
        ad9361_en_dis_tx(TX_1 | TX_2, TX_1 | TX_2);
        ad9361_en_dis_rx(RX_1 | RX_2, RX_1 | RX_2);
    }

    ret = ad9361_rf_port_setup(true, pd->rf_rx_input_sel, pd->rf_tx_output_sel);

    if(ret < 0)
        return ret;

    ret = ad9361_pp_port_setup(false);

    if(ret < 0)
        return ret;

    bbpll_freq = ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[BBPLL_CLK]);
    ret = ad9361_auxadc_setup(&pd->auxadc_ctrl, bbpll_freq);

    if(ret < 0)
        return ret;

    ret = ad9361_ctrl_outs_setup(&pd->ctrl_outs_ctrl);

    if(ret < 0)
        return ret;

    ret = ad9361_set_ref_clk_cycles(refin_Hz);

    if(ret < 0)
        return ret;

    ret = ad9361_setup_ext_lna(&pd->elna_ctrl);

    if(ret < 0)
        return ret;

    /*
     * This allows forcing a lower F_REF window
     * (worse phase noise, better fractional spurs)
     */
    pd->trx_synth_max_fref = CLAMP_T(uint32_t, pd->trx_synth_max_fref, MIN_SYNTH_FREF, MAX_SYNTH_FREF);

    ref_freq = ad9361_ref_div_sel(refin_Hz, pd->trx_synth_max_fref);

    if(!ref_freq)
        return -EINVAL;

    ret = ad9361_clk_set_rate(g_pAD9361Phy->ref_clk_scale[RX_REFCLK], ref_freq);

    if(ret < 0)
    {
        DBGPRINTLN_CTX("Failed to set RX Synth ref clock rate (%"PRId32")", ret);

        return ret;
    }

    ret = ad9361_clk_set_rate(g_pAD9361Phy->ref_clk_scale[TX_REFCLK], ref_freq);

    if(ret < 0)
    {
        DBGPRINTLN_CTX("Failed to set TX Synth ref clock rate (%"PRId32")", ret);

        return ret;
    }

    ret = ad9361_txrx_synth_cp_calib(ref_freq, false); /* RXCP */

    if(ret < 0)
        return ret;

    ret = ad9361_txrx_synth_cp_calib(ref_freq, true); /* TXCP */

    if(ret < 0)
        return ret;

    g_pAD9361Phy->pdata->use_ext_rx_lo = 0;
    g_pAD9361Phy->pdata->use_ext_tx_lo = 0;

    ret = ad9361_clk_set_rate(g_pAD9361Phy->ref_clk_scale[RX_RFPLL], ad9361_to_clk(pd->rx_synth_freq));

    if(ret < 0)
    {
        DBGPRINTLN_CTX("Failed to set RX Synth rate (%"PRId32")", ret);

        return ret;
    }

    /* Skip quad cal here we do it later again */
    g_pAD9361Phy->last_tx_quad_cal_freq = pd->tx_synth_freq;
    ret = ad9361_clk_set_rate(g_pAD9361Phy->ref_clk_scale[TX_RFPLL], ad9361_to_clk(pd->tx_synth_freq));

    if(ret < 0)
    {
        DBGPRINTLN_CTX("Failed to set TX Synth rate (%"PRId32")", ret);

        return ret;
    }

    g_pAD9361Phy->pdata->use_ext_rx_lo = tmp_use_ext_rx_lo;
    g_pAD9361Phy->pdata->use_ext_tx_lo = tmp_use_ext_tx_lo;

    ad9361_clk_mux_set_parent(g_pAD9361Phy->ref_clk_scale[RX_RFPLL], pd->use_ext_rx_lo);

    ad9361_clk_mux_set_parent(g_pAD9361Phy->ref_clk_scale[TX_RFPLL], pd->use_ext_tx_lo);

    ret = ad9361_load_mixer_gm_subtable();

    if(ret < 0)
        return ret;

    ret = ad9361_gc_setup(&pd->gain_ctrl);

    if(ret < 0)
        return ret;

    ret = ad9361_rx_bb_analog_filter_calib(real_rx_bandwidth, bbpll_freq);

    if(ret < 0)
        return ret;

    ret = ad9361_tx_bb_analog_filter_calib(real_tx_bandwidth, bbpll_freq);

    if(ret < 0)
        return ret;

    ret = ad9361_rx_tia_calib(real_rx_bandwidth);

    if(ret < 0)
        return ret;

    ret = ad9361_tx_bb_second_filter_calib(real_tx_bandwidth);

    if(ret < 0)
        return ret;

    ret = ad9361_rx_adc_setup(bbpll_freq, ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[ADC_CLK]));

    if(ret < 0)
        return ret;

    ret = ad9361_bb_dc_offset_calib();

    if(ret < 0)
        return ret;

    ret = ad9361_rf_dc_offset_calib(ad9361_from_clk(ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[RX_RFPLL])));

    if(ret < 0)
        return ret;

    g_pAD9361Phy->current_rx_bw_Hz = pd->rf_rx_bandwidth_Hz;
    g_pAD9361Phy->current_tx_bw_Hz = pd->rf_tx_bandwidth_Hz;
    g_pAD9361Phy->last_tx_quad_cal_phase = ~0;

    ret = ad9361_tx_quad_calib(real_rx_bandwidth, real_tx_bandwidth, -1);

    if(ret < 0)
        return ret;

    ret = ad9361_tracking_control(g_pAD9361Phy->bbdc_track_en, g_pAD9361Phy->rfdc_track_en, g_pAD9361Phy->quad_track_en);

    if(ret < 0)
        return ret;

    ad9361_pp_port_setup(true);

    ret = ad9361_set_ensm_mode(pd->fdd, pd->ensm_pin_ctrl);

    if(ret < 0)
        return ret;

    ad9361_spi_writef(REG_TX_ATTEN_OFFSET, MASK_CLR_ATTEN_UPDATE, 0);

    ret = ad9361_set_tx_atten(pd->tx_atten, pd->rx2tx2 ? true : pd->rx1tx1_mode_use_tx_num == 1, pd->rx2tx2 ? true : pd->rx1tx1_mode_use_tx_num == 2, true);

    if(ret < 0)
        return ret;

    if(!pd->rx2tx2)
    {
        ret = ad9361_set_tx_atten(MAX_TX_ATTENUATION_DB, pd->rx1tx1_mode_use_tx_num == 2, pd->rx1tx1_mode_use_tx_num == 1, true);

        if(ret < 0)
            return ret;
    }

    ret = ad9361_rssi_setup(&pd->rssi_ctrl, false);

    if(ret < 0)
        return ret;

    ret = ad9361_clkout_control(pd->ad9361_clkout_mode);

    if(ret < 0)
        return ret;

    ret = ad9361_txmon_setup(&pd->txmon_ctrl);

    if(ret < 0)
        return ret;

    g_pAD9361Phy->curr_ensm_state = ad9361_spi_readf(REG_STATE, ENSM_STATE(~0));

    ad9361_ensm_set_state(pd->fdd ? ENSM_STATE_FDD : ENSM_STATE_RX, pd->ensm_pin_ctrl);

    g_pAD9361Phy->auto_cal_en = true;
    g_pAD9361Phy->cal_threshold_freq = 100000000ULL; /* 100 MHz */

    return 0;
}

/**
 * Perform the selected calibration
 * @param phy The AD9361 state structure.
 * @param cal The selected calibration.
 * @param arg The argument of the calibration.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_do_calib_run(uint32_t cal, int32_t arg)
{
    int32_t ret;

    DBGPRINTLN_CTX("cal: %"PRIu32", arg: %"PRId32, cal, arg);

    ret = ad9361_tracking_control(false, false, false);

    if(ret < 0)
        return ret;

    ad9361_ensm_force_state(ENSM_STATE_ALERT);

    switch(cal)
    {
        case TX_QUAD_CAL:
            ret = ad9361_tx_quad_calib(g_pAD9361Phy->current_rx_bw_Hz / 2, g_pAD9361Phy->current_tx_bw_Hz / 2, arg);
        break;
        case RFDC_CAL:
            ret = ad9361_rf_dc_offset_calib(ad9361_from_clk(ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[RX_RFPLL])));
        break;
        default:
            ret = -EINVAL;
        break;
    }

    ret = ad9361_tracking_control(g_pAD9361Phy->bbdc_track_en, g_pAD9361Phy->rfdc_track_en, g_pAD9361Phy->quad_track_en);

    ad9361_ensm_restore_prev_state();

    return ret;
}

/**
 * Set the RF bandwidth.
 * @param phy The AD9361 state structure.
 * @param rf_rx_bw The desired RX bandwidth [Hz].
 * @param rf_tx_bw The desired TX bandwidth [Hz].
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_update_rf_bandwidth(uint32_t rf_rx_bw, uint32_t rf_tx_bw)
{
    int32_t ret;

    ret = ad9361_tracking_control(false, false, false);

    if(ret < 0)
        return ret;

    ad9361_ensm_force_state(ENSM_STATE_ALERT);

    ret = __ad9361_update_rf_bandwidth(rf_rx_bw, rf_tx_bw);

    if(ret < 0)
        return ret;

    g_pAD9361Phy->current_rx_bw_Hz = rf_rx_bw;
    g_pAD9361Phy->current_tx_bw_Hz = rf_tx_bw;

    if(g_pAD9361Phy->manual_tx_quad_cal_en == false)
    {
        ret = ad9361_tx_quad_calib(rf_rx_bw / 2, rf_tx_bw / 2, -1);

        if(ret < 0)
            return ret;
    }

    ret = ad9361_tracking_control(g_pAD9361Phy->bbdc_track_en, g_pAD9361Phy->rfdc_track_en, g_pAD9361Phy->quad_track_en);

    if(ret < 0)
        return ret;

    ad9361_ensm_restore_prev_state();

    return 0;
}

/**
 * Verify the FIR filter coefficients.
 * @param phy The AD9361 state structure.
 * @param dest Destination identifier (RX1,2 / TX1,2).
 * @param ntaps Number of filter Taps.
 * @param coef Pointer to filter coefficients.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_verify_fir_filter_coef(enum ad9361_fir_dest dest, uint32_t ntaps, short* coef)
{
    uint32_t val, offs = 0, gain = 0, conf, sel, cnt;
    int32_t ret = 0;

    //return 0;

    DBGPRINTLN_CTX("ntaps %"PRIu32", dest %d", ntaps, dest);

    if(dest & FIR_IS_RX)
    {
        gain = ad9361_spi_read(REG_RX_FILTER_GAIN);

        offs = REG_RX_FILTER_COEF_ADDR - REG_TX_FILTER_COEF_ADDR;

        ad9361_spi_write(REG_RX_FILTER_GAIN, 0);
    }

    conf = ad9361_spi_read(REG_TX_FILTER_CONF + offs);

    if((dest & 3) == 3)
    {
        sel = 1;
        cnt = 2;
    }
    else
    {
        sel = (dest & 3);
        cnt = 1;
    }

    for(; cnt > 0; cnt--, sel++)
    {
        ad9361_spi_write(REG_TX_FILTER_CONF + offs, FIR_NUM_TAPS(ntaps / 16 - 1) | FIR_SELECT(sel) | FIR_START_CLK);

        for(val = 0; val < ntaps; val++)
        {
            int16_t tmp;

            ad9361_spi_write(REG_TX_FILTER_COEF_ADDR + offs, val);

            tmp = (ad9361_spi_read(REG_TX_FILTER_COEF_READ_DATA_1 + offs) & 0xFF) | (ad9361_spi_read(REG_TX_FILTER_COEF_READ_DATA_2 + offs) << 8);

            if(tmp != coef[val])
            {
                DBGPRINTLN_CTX("%s%"PRIu32" readback mismatch at tap %"PRIu32" (%d != %d)", (dest & FIR_IS_RX) ? "RX" : "TX", sel, val, tmp, coef[val]);

                ret = -EIO;
            }
        }
    }

    if(dest & FIR_IS_RX)
        ad9361_spi_write(REG_RX_FILTER_GAIN, gain);

    ad9361_spi_write(REG_TX_FILTER_CONF + offs, conf);

    return ret;
}

/**
 * Load the FIR filter coefficients.
 * @param phy The AD9361 state structure.
 * @param dest Destination identifier (RX1,2 / TX1,2).
 * @param gain_dB Gain option.
 * @param ntaps Number of filter Taps.
 * @param coef Pointer to filter coefficients.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_load_fir_filter_coef(enum ad9361_fir_dest dest, int32_t gain_dB, uint32_t ntaps, int16_t* coef)
{
    uint32_t val, offs = 0, fir_conf = 0, fir_enable = 0;
    int32_t ret;

    DBGPRINTLN_CTX("ntaps %"PRIu32", gain %"PRId32" dB, dest %d", ntaps, gain_dB, dest);

    if(coef == NULL || !ntaps || ntaps > 128 || ntaps % 16)
    {
        DBGPRINTLN_CTX("Invalid parameters");

        return -EINVAL;
    }

    ad9361_ensm_force_state(ENSM_STATE_ALERT);

    if(dest & FIR_IS_RX)
    {
        val = 3 - (gain_dB + 12) / 6;

        ad9361_spi_write(REG_RX_FILTER_GAIN, val & 0x3);

        offs = REG_RX_FILTER_COEF_ADDR - REG_TX_FILTER_COEF_ADDR;
        g_pAD9361Phy->rx_fir_ntaps = ntaps;
        fir_enable = ad9361_spi_readf(REG_RX_ENABLE_FILTER_CTRL, RX_FIR_ENABLE_DECIMATION(~0));

        ad9361_spi_writef(REG_RX_ENABLE_FILTER_CTRL, RX_FIR_ENABLE_DECIMATION(~0), (g_pAD9361Phy->rx_fir_dec == 4) ? 3 : g_pAD9361Phy->rx_fir_dec);
    }
    else
    {
        if(gain_dB == -6)
            fir_conf = TX_FIR_GAIN_6DB;

        g_pAD9361Phy->tx_fir_ntaps = ntaps;

        fir_enable = ad9361_spi_readf(REG_TX_ENABLE_FILTER_CTRL, TX_FIR_ENABLE_INTERPOLATION(~0));
        ad9361_spi_writef(REG_TX_ENABLE_FILTER_CTRL, TX_FIR_ENABLE_INTERPOLATION(~0), (g_pAD9361Phy->tx_fir_int == 4) ? 3 : g_pAD9361Phy->tx_fir_int);
    }

    val = ntaps / 16 - 1;

    fir_conf |= FIR_NUM_TAPS(val) | FIR_SELECT(dest) | FIR_START_CLK;

    ad9361_spi_write(REG_TX_FILTER_CONF + offs, fir_conf);

    for(val = 0; val < ntaps; val++)
    {
        ad9361_spi_write(REG_TX_FILTER_COEF_ADDR + offs, val);
        ad9361_spi_write(REG_TX_FILTER_COEF_WRITE_DATA_1 + offs, coef[val] & 0xFF);
        ad9361_spi_write(REG_TX_FILTER_COEF_WRITE_DATA_2 + offs, coef[val] >> 8);
        ad9361_spi_write(REG_TX_FILTER_CONF + offs, fir_conf | FIR_WRITE);
        ad9361_spi_write(REG_TX_FILTER_COEF_READ_DATA_2 + offs, 0);
        ad9361_spi_write(REG_TX_FILTER_COEF_READ_DATA_2 + offs, 0);
    }

    ad9361_spi_write(REG_TX_FILTER_CONF + offs, fir_conf);

    fir_conf &= ~FIR_START_CLK;

    ad9361_spi_write(REG_TX_FILTER_CONF + offs, fir_conf);

    ret = ad9361_verify_fir_filter_coef(dest, ntaps, coef);

    if(dest & FIR_IS_RX)
        ad9361_spi_writef(REG_RX_ENABLE_FILTER_CTRL, RX_FIR_ENABLE_DECIMATION(~0), fir_enable);
    else
        ad9361_spi_writef(REG_TX_ENABLE_FILTER_CTRL, TX_FIR_ENABLE_INTERPOLATION(~0), fir_enable);

    ad9361_ensm_restore_prev_state();

    return ret;
}

/**
 * Parse the FIR filter file/buffer.
 * @param phy The AD9361 state structure.
 * @param data Pointer to buffer.
 * @param size Buffer size.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_parse_fir(char* data, uint32_t size)
{
    char* line;
    int32_t i = 0, ret, txc, rxc;
    int32_t tx = -1, tx_gain = 0, tx_int = 0;
    int32_t rx = -1, rx_gain = 0, rx_dec = 0;
    int32_t rtx = -1, rrx = -1;
    int16_t coef_tx[128];
    int16_t coef_rx[128];
    char* ptr = data;

    g_pAD9361Phy->filt_rx_bw_Hz = 0;
    g_pAD9361Phy->filt_tx_bw_Hz = 0;
    g_pAD9361Phy->filt_valid = false;

    while((line = strsep(&ptr, "\n")))
    {
        if(line >= data + size)
        {
            break;
        }

        if(line[0] == '#')
            continue;

        if(tx < 0)
        {
            ret = sscanf(line, "TX %"PRId32" GAIN %"PRId32" INT %"PRId32, &tx, &tx_gain, &tx_int);

            if(ret == 3)
                continue;
            else
                tx = -1;
        }
        if(rx < 0)
        {
            ret = sscanf(line, "RX %"PRId32" GAIN %"PRId32" DEC %"PRId32, &rx, &rx_gain, &rx_dec);

            if(ret == 3)
                continue;
            else
                tx = -1;
        }

        if(rtx < 0)
        {
            ret = sscanf(line, "RTX %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32, &g_pAD9361Phy->filt_tx_path_clks[0], &g_pAD9361Phy->filt_tx_path_clks[1], &g_pAD9361Phy->filt_tx_path_clks[2], &g_pAD9361Phy->filt_tx_path_clks[3], &g_pAD9361Phy->filt_tx_path_clks[4], &g_pAD9361Phy->filt_tx_path_clks[5]);

            if(ret == 6)
            {
                rtx = 0;

                continue;
            }
            else
            {
                rtx = -1;
            }
        }

        if(rrx < 0)
        {
            ret = sscanf(line, "RRX %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32" %"PRIu32, &g_pAD9361Phy->filt_rx_path_clks[0], &g_pAD9361Phy->filt_rx_path_clks[1], &g_pAD9361Phy->filt_rx_path_clks[2], &g_pAD9361Phy->filt_rx_path_clks[3], &g_pAD9361Phy->filt_rx_path_clks[4], &g_pAD9361Phy->filt_rx_path_clks[5]);

            if(ret == 6)
            {
                rrx = 0;
                continue;
            }
            else
            {
                rrx = -1;
            }
        }

        if(!g_pAD9361Phy->filt_rx_bw_Hz)
        {
            ret = sscanf(line, "BWRX %"PRId32, &g_pAD9361Phy->filt_rx_bw_Hz);

            if(ret == 1)
                continue;
            else
                g_pAD9361Phy->filt_rx_bw_Hz = 0;
        }

        if(!g_pAD9361Phy->filt_tx_bw_Hz)
        {
            ret = sscanf(line, "BWTX %"PRId32, &g_pAD9361Phy->filt_tx_bw_Hz);

            if(ret == 1)
                continue;
            else
                g_pAD9361Phy->filt_tx_bw_Hz = 0;
        }

        ret = sscanf(line, "%"PRId32",%"PRId32, &txc, &rxc);

        if(ret == 1)
        {
            coef_tx[i] = coef_rx[i] = (int16_t)txc;

            i++;

            continue;
        }
        else if(ret == 2)
        {
            coef_tx[i] = (int16_t)txc;
            coef_rx[i] = (int16_t)rxc;

            i++;

            continue;
        }
    }

    switch(tx)
    {
        case FIR_TX1:
        case FIR_TX2:
        case FIR_TX1_TX2:
            g_pAD9361Phy->tx_fir_int = tx_int;
            ret = ad9361_load_fir_filter_coef((enum ad9361_fir_dest)tx, tx_gain, i, coef_tx);
        break;
        default:
            ret = -EINVAL;
    }

    switch(rx | FIR_IS_RX)
    {
        case FIR_RX1:
        case FIR_RX2:
        case FIR_RX1_RX2:
            g_pAD9361Phy->rx_fir_dec = rx_dec;
            ret = ad9361_load_fir_filter_coef((enum ad9361_fir_dest)(rx | FIR_IS_RX), rx_gain, i, coef_rx);
        break;
        default:
            ret = -EINVAL;
    }

    if(ret < 0)
        return ret;

    if(!(rrx | rtx))
        g_pAD9361Phy->filt_valid = true;

    return size;
}

/**
 * Validate FIR filter configuration - on pass enable.
 * @param phy The AD9361 state structure.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_validate_enable_fir()
{
    int32_t ret;
    uint32_t rx[6], tx[6];
    uint32_t max, min, valid;

    DBGPRINTLN_CTX("TX FIR - enable: %d, ntaps: %d, int: %d", !g_pAD9361Phy->bypass_tx_fir, g_pAD9361Phy->tx_fir_ntaps, g_pAD9361Phy->tx_fir_int);
    DBGPRINTLN_CTX("RX FIR - enable: %d, ntaps: %d, dec: %d", !g_pAD9361Phy->bypass_rx_fir, g_pAD9361Phy->rx_fir_ntaps, g_pAD9361Phy->rx_fir_dec);

    if(!g_pAD9361Phy->bypass_tx_fir)
    {
        if(!(g_pAD9361Phy->tx_fir_int == 1 || g_pAD9361Phy->tx_fir_int == 2 || g_pAD9361Phy->tx_fir_int == 4))
        {
            DBGPRINTLN_CTX("Invalid interpolation %d in filter config", g_pAD9361Phy->tx_fir_int);

            return -EINVAL;
        }


        if(g_pAD9361Phy->tx_fir_int == 1 && g_pAD9361Phy->tx_fir_ntaps > 64)
        {
            DBGPRINTLN_CTX("Invalid: ntaps > 64 and interpolation = 1");

            return -EINVAL;
        }
    }

    if(!g_pAD9361Phy->bypass_rx_fir)
    {
        if(!(g_pAD9361Phy->rx_fir_dec == 1 || g_pAD9361Phy->rx_fir_dec == 2 || g_pAD9361Phy->rx_fir_dec == 4))
        {
            DBGPRINTLN_CTX("Invalid decimation %d in filter config", g_pAD9361Phy->rx_fir_dec);

            return -EINVAL;
        }
    }

    if(!g_pAD9361Phy->filt_valid || g_pAD9361Phy->bypass_rx_fir || g_pAD9361Phy->bypass_tx_fir)
    {
        ret = ad9361_calculate_rf_clock_chain(ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[TX_SAMPL_CLK]), g_pAD9361Phy->rate_governor, rx, tx);

        if(ret < 0)
        {
            min = g_pAD9361Phy->rate_governor ? 1500000U : 1000000U;

            DBGPRINTLN_CTX("Calculating filter rates failed (%"PRId32"), using min frequency", ret);

            ret = ad9361_calculate_rf_clock_chain(min, g_pAD9361Phy->rate_governor, rx, tx);

            if(ret < 0)
                return ret;
        }

        valid = false;
    }
    else
    {
        memcpy(rx, g_pAD9361Phy->filt_rx_path_clks, sizeof(rx));
        memcpy(tx, g_pAD9361Phy->filt_tx_path_clks, sizeof(tx));

        valid = true;
    }

    DBGPRINTLN_CTX("RX Rates - BBPLL: %"PRIu32" Hz, ADC: %"PRIu32" Hz, R2CLK: %"PRIu32" Hz, R1CLK: %"PRIu32" Hz, CLKRF: %"PRIu32" Hz, RSAMPL: %"PRIu32" Hz", rx[BBPLL_FREQ], rx[ADC_FREQ], rx[R2_FREQ], rx[R1_FREQ], rx[CLKRF_FREQ], rx[RX_SAMPL_FREQ]);
    DBGPRINTLN_CTX("TX Rates - BBPLL: %"PRIu32" Hz, DAC: %"PRIu32" Hz, T2CLK: %"PRIu32" Hz, T1CLK: %"PRIu32" Hz, CLKTF: %"PRIu32" Hz, TSAMPL: %"PRIu32" Hz", tx[BBPLL_FREQ], tx[DAC_FREQ], tx[T2_FREQ], tx[T1_FREQ], tx[CLKTF_FREQ], tx[TX_SAMPL_FREQ]);

    if(!g_pAD9361Phy->bypass_tx_fir)
    {
        max = (tx[DAC_FREQ] / tx[TX_SAMPL_FREQ]) * 16;

        if(g_pAD9361Phy->tx_fir_ntaps > max)
        {
            DBGPRINTLN_CTX("Invalid: ratio DAC / TX_SAMPL * 16 > ntaps (max %"PRIu32", adc %"PRIu32", tx %"PRIu32")", max, tx[DAC_FREQ], tx[TX_SAMPL_FREQ]);

            return -EINVAL;
        }
    }

    if(!g_pAD9361Phy->bypass_rx_fir)
    {
        max = ((rx[ADC_FREQ] / ((rx[ADC_FREQ] == rx[R2_FREQ]) ? 1 : 2)) / rx[RX_SAMPL_FREQ]) * 16;

        if(g_pAD9361Phy->rx_fir_ntaps > max)
        {
            DBGPRINTLN_CTX("Invalid: ratio ADC/2 / RX_SAMPL * 16 > ntaps (max %"PRIu32")", max);

            return -EINVAL;
        }
    }

    ret = ad9361_set_trx_clock_chain(rx, tx);

    if(ret < 0)
        return ret;

    /* See also: ad9361_set_trx_clock_chain() */
    if(!g_pAD9361Phy->pdata->dig_interface_tune_fir_disable && g_pAD9361Phy->bypass_tx_fir && g_pAD9361Phy->bypass_rx_fir)
        ad9361_util_dig_tune(0, RESTORE_PREVIOUS);

    return ad9361_update_rf_bandwidth(valid ? g_pAD9361Phy->filt_rx_bw_Hz : g_pAD9361Phy->current_rx_bw_Hz, valid ? g_pAD9361Phy->filt_tx_bw_Hz : g_pAD9361Phy->current_tx_bw_Hz);
}

/*
* AD9361 Clocks
*/

/**
* Set the multiplier and the divider for the selected ad9361_clk_scale structure.
* @param priv The selected ad9361_clk_scale structure.
* @param mul The multiplier value.
* @param div The divider value.
* @return 0 in case of success, negative error code otherwise.
*/
static inline int32_t ad9361_set_muldiv(struct ad9361_clk_scale* priv, uint32_t mul, uint32_t div)
{
    priv->mult = mul;
    priv->div = div;

    return 0;
}

/**
 * Get the clk scaler for the selected ad9361_clk_scale structure.
 * @param priv The selected ad9361_clk_scale structure.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_get_clk_scaler(struct ad9361_clk_scale* clk_priv)
{
    uint32_t tmp, tmp1;

    switch(clk_priv->source)
    {
        case BB_REFCLK:
            tmp = ad9361_spi_read(REG_CLOCK_CTRL);
            tmp &= 0x3;
        break;
        case RX_REFCLK:
            tmp = ad9361_spi_readf(REG_REF_DIVIDE_CONFIG_1, RX_REF_DIVIDER_MSB);
            tmp1 = ad9361_spi_readf(REG_REF_DIVIDE_CONFIG_2, RX_REF_DIVIDER_LSB);
            tmp = (tmp << 1) | tmp1;
        break;
        case TX_REFCLK:
            tmp = ad9361_spi_readf(REG_REF_DIVIDE_CONFIG_2, TX_REF_DIVIDER(~0));
        break;
        case ADC_CLK:
            tmp = ad9361_spi_read(REG_BBPLL);

            return ad9361_set_muldiv(clk_priv, 1, 1 << (tmp & 0x7));
        break;
        case R2_CLK:
            tmp = ad9361_spi_readf(REG_RX_ENABLE_FILTER_CTRL, DEC3_ENABLE_DECIMATION(~0));

            return ad9361_set_muldiv(clk_priv, 1, tmp + 1);
        break;
        case R1_CLK:
            tmp = ad9361_spi_readf(REG_RX_ENABLE_FILTER_CTRL, RHB2_EN);

            return ad9361_set_muldiv(clk_priv, 1, tmp + 1);
        case CLKRF_CLK:
            tmp = ad9361_spi_readf(REG_RX_ENABLE_FILTER_CTRL, RHB1_EN);

            return ad9361_set_muldiv(clk_priv, 1, tmp + 1);
        case RX_SAMPL_CLK:
            tmp = ad9361_spi_readf(REG_RX_ENABLE_FILTER_CTRL, RX_FIR_ENABLE_DECIMATION(~0));

            if(!tmp)
                tmp = 1; /* bypass filter */
            else
                tmp = (1 << (tmp - 1));

            return ad9361_set_muldiv(clk_priv, 1, tmp);
        break;
        case DAC_CLK:
            tmp = ad9361_spi_readf(REG_BBPLL, BIT(3));

            return ad9361_set_muldiv(clk_priv, 1, tmp + 1);
        break;
        case T2_CLK:
            tmp = ad9361_spi_readf(REG_TX_ENABLE_FILTER_CTRL, THB3_ENABLE_INTERP(~0));

            return ad9361_set_muldiv(clk_priv, 1, tmp + 1);
        break;
        case T1_CLK:
            tmp = ad9361_spi_readf(REG_TX_ENABLE_FILTER_CTRL, THB2_EN);

            return ad9361_set_muldiv(clk_priv, 1, tmp + 1);
        break;
        case CLKTF_CLK:
            tmp = ad9361_spi_readf(REG_TX_ENABLE_FILTER_CTRL, THB1_EN);

            return ad9361_set_muldiv(clk_priv, 1, tmp + 1);
        break;
        case TX_SAMPL_CLK:
            tmp = ad9361_spi_readf(REG_TX_ENABLE_FILTER_CTRL, TX_FIR_ENABLE_INTERPOLATION(~0));

            if(!tmp)
                tmp = 1; /* bypass filter */
            else
                tmp = (1 << (tmp - 1));

            return ad9361_set_muldiv(clk_priv, 1, tmp);
        break;
        default:
            return -EINVAL;
        break;
    }

    /* REFCLK Scaler */
    switch(tmp)
    {
        case 0:
            ad9361_set_muldiv(clk_priv, 1, 1);
        break;
        case 1:
            ad9361_set_muldiv(clk_priv, 1, 2);
        break;
        case 2:
            ad9361_set_muldiv(clk_priv, 1, 4);
        break;
        case 3:
            ad9361_set_muldiv(clk_priv, 2, 1);
        break;
        default:
            return -EINVAL;
        break;

    }

    return 0;
}

/**
 * Calculate the REFCLK Scaler for the selected ad9361_clk_scale structure.
 * Note: REFCLK Scaler values - 00: x1; 01: x½; 10: x¼; 11: x2.
 * @param clk_priv The selected ad9361_clk_scale structure.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_to_refclk_scaler(struct ad9361_clk_scale* clk_priv)
{
    /* REFCLK Scaler */
    switch(((clk_priv->mult & 0xF) << 4) | (clk_priv->div & 0xF))
    {
        case 0x11:
            return 0;
        case 0x12:
            return 1;
        case 0x14:
            return 2;
        case 0x21:
            return 3;
        default:
            return -EINVAL;
    }
};

/**
 * Set clk scaler for the selected ad9361_clk_scale structure.
 * @param clk_priv The selected ad9361_clk_scale structure.
 * @param set Set true, the reference clock frequency will be scaled before
 *            it enters the BBPLL.
 * @return 0 in case of success, negative error code otherwise.
 */
static int32_t ad9361_set_clk_scaler(struct ad9361_clk_scale* clk_priv, bool set)
{
    uint32_t tmp;
    int32_t ret;

    switch(clk_priv->source)
    {
        case BB_REFCLK:
            ret = ad9361_to_refclk_scaler(clk_priv);

            if(ret < 0)
                return ret;
            if(set)
                return ad9361_spi_writef(REG_CLOCK_CTRL, REF_FREQ_SCALER(~0), ret);
        break;
        case RX_REFCLK:
            ret = ad9361_to_refclk_scaler(clk_priv);

            if(ret < 0)
                return ret;

            if(set)
            {
                tmp = ret;
                ret = ad9361_spi_writef(REG_REF_DIVIDE_CONFIG_1, RX_REF_DIVIDER_MSB, tmp >> 1);
                ret |= ad9361_spi_writef(REG_REF_DIVIDE_CONFIG_2, RX_REF_DIVIDER_LSB, tmp & 1);

                return ret;
            }
        break;
        case TX_REFCLK:
            ret = ad9361_to_refclk_scaler(clk_priv);

            if(ret < 0)
                return ret;

            if(set)
                return ad9361_spi_writef(REG_REF_DIVIDE_CONFIG_2, TX_REF_DIVIDER(~0), ret);
        break;
        case ADC_CLK:
            tmp = utils_ilog2((uint8_t)clk_priv->div);

            if(clk_priv->mult != 1 || tmp > 6 || tmp < 1)
                return -EINVAL;

            if(set)
                return ad9361_spi_writef(REG_BBPLL, 0x7, tmp);
        break;
        case R2_CLK:
            if(clk_priv->mult != 1 || clk_priv->div > 3 || clk_priv->div < 1)
                return -EINVAL;

            if(set)
                return ad9361_spi_writef(REG_RX_ENABLE_FILTER_CTRL, DEC3_ENABLE_DECIMATION(~0), clk_priv->div - 1);
        break;
        case R1_CLK:
            if(clk_priv->mult != 1 || clk_priv->div > 2 || clk_priv->div < 1)
                return -EINVAL;

            if(set)
                return ad9361_spi_writef(REG_RX_ENABLE_FILTER_CTRL, RHB2_EN, clk_priv->div - 1);
        break;
        case CLKRF_CLK:
            if(clk_priv->mult != 1 || clk_priv->div > 2 || clk_priv->div < 1)
                return -EINVAL;

            if(set)
                return ad9361_spi_writef(REG_RX_ENABLE_FILTER_CTRL, RHB1_EN, clk_priv->div - 1);
        break;
        case RX_SAMPL_CLK:
            if(clk_priv->mult != 1 || clk_priv->div > 4 || clk_priv->div < 1 || clk_priv->div == 3)
                return -EINVAL;

            if(g_pAD9361Phy->bypass_rx_fir)
                tmp = 0;
            else
                tmp = utils_ilog2(clk_priv->div) + 1;

            if(set)
                return ad9361_spi_writef(REG_RX_ENABLE_FILTER_CTRL, RX_FIR_ENABLE_DECIMATION(~0), tmp);
        break;
        case DAC_CLK:
            if(clk_priv->mult != 1 || clk_priv->div > 2 || clk_priv->div < 1)
                return -EINVAL;

            if(set)
                return ad9361_spi_writef(REG_BBPLL, BIT(3), clk_priv->div - 1);
        break;
        case T2_CLK:
            if(clk_priv->mult != 1 || clk_priv->div > 3 || clk_priv->div < 1)
                return -EINVAL;

            if(set)
                return ad9361_spi_writef(REG_TX_ENABLE_FILTER_CTRL, THB3_ENABLE_INTERP(~0), clk_priv->div - 1);
        break;
        case T1_CLK:
            if(clk_priv->mult != 1 || clk_priv->div > 2 || clk_priv->div < 1)
                return -EINVAL;

            if(set)
                return ad9361_spi_writef(REG_TX_ENABLE_FILTER_CTRL, THB2_EN, clk_priv->div - 1);
        break;
        case CLKTF_CLK:
            if(clk_priv->mult != 1 || clk_priv->div > 2 || clk_priv->div < 1)
                return -EINVAL;

            if(set)
                return ad9361_spi_writef(REG_TX_ENABLE_FILTER_CTRL, THB1_EN, clk_priv->div - 1);
        break;
        case TX_SAMPL_CLK:
            if(clk_priv->mult != 1 || clk_priv->div > 4 || clk_priv->div < 1 || clk_priv->div == 3)
                return -EINVAL;

            if(g_pAD9361Phy->bypass_tx_fir)
                tmp = 0;
            else
                tmp = utils_ilog2(clk_priv->div) + 1;

            if(set)
                return ad9361_spi_writef(REG_TX_ENABLE_FILTER_CTRL, TX_FIR_ENABLE_INTERPOLATION(~0), tmp);
        break;
        default:
            return -EINVAL;
        break;
    }

    return 0;
}

/**
 * Recalculate the clock rate.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param parent_rate The parent clock rate.
 * @return The clock rate.
 */
uint32_t ad9361_clk_factor_recalc_rate(struct ad9361_clk_scale* clk_priv, uint32_t parent_rate)
{
    uint64_t rate;

    ad9361_get_clk_scaler(clk_priv);
    rate = (parent_rate * clk_priv->mult) / clk_priv->div;

    return (uint32_t)rate;
}

/**
 * Calculate the closest possible clock rate that can be set.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param rate The clock rate.
 * @param prate The parent clock rate.
 * @return The closest possible clock rate that can be set.
 */
int32_t ad9361_clk_factor_round_rate(struct ad9361_clk_scale* clk_priv, uint32_t rate, uint32_t* prate)
{
    int32_t ret;

    if(rate >= *prate)
    {
        clk_priv->mult = DIV_ROUND(rate, *prate);
        clk_priv->div = 1;

    }
    else
    {
        clk_priv->div = DIV_ROUND(*prate, rate);
        clk_priv->mult = 1;

        if(!clk_priv->div)
        {
            DBGPRINTLN_CTX("divide by zero");

            clk_priv->div = 1;
        }
    }

    ret = ad9361_set_clk_scaler(clk_priv, false);

    if(ret < 0)
        return ret;

    return (*prate / clk_priv->div) * clk_priv->mult;
}

/**
 * Set the clock rate.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param rate The clock rate.
 * @param parent_rate The parent clock rate.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_clk_factor_set_rate(struct ad9361_clk_scale* clk_priv, uint32_t rate, uint32_t parent_rate)
{
    DBGPRINTLN_CTX("Rate: %"PRIu32" Hz, Parent Rate: %"PRIu32" Hz", rate, parent_rate);

    if(rate >= parent_rate)
    {
        clk_priv->mult = DIV_ROUND(rate, parent_rate);
        clk_priv->div = 1;
    }
    else
    {
        clk_priv->div = DIV_ROUND(parent_rate, rate);
        clk_priv->mult = 1;

        if(!clk_priv->div)
        {
            DBGPRINTLN_CTX("divide by zero");

            clk_priv->div = 1;
        }
    }

    return ad9361_set_clk_scaler(clk_priv, true);
}

/*
 * BBPLL
 */
 /**
  * Recalculate the clock rate.
  * @param clk_priv The ad9361_clk_scale structure.
  * @param parent_rate The parent clock rate.
  * @return The clock rate.
  */
uint32_t ad9361_bbpll_recalc_rate(struct ad9361_clk_scale* clk_priv, uint32_t parent_rate)
{
    uint64_t rate;
    uint32_t fract, integer;
    uint8_t buf[4];

    ad9361_spi_readm(REG_INTEGER_BB_FREQ_WORD, &buf[0], REG_INTEGER_BB_FREQ_WORD - REG_FRACT_BB_FREQ_WORD_1 + 1);

    fract = (buf[3] << 16) | (buf[2] << 8) | buf[1];
    integer = buf[0];

    rate = ((uint64_t)parent_rate * fract);
    utils_do_div(&rate, BBPLL_MODULUS);
    rate += (uint64_t)parent_rate * integer;

    return (uint32_t)rate;
}

/**
 * Calculate the closest possible clock rate that can be set.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param rate The clock rate.
 * @param prate The parent clock rate.
 * @return The closest possible clock rate that can be set.
 */
int32_t ad9361_bbpll_round_rate(struct ad9361_clk_scale* clk_priv, uint32_t rate, uint32_t* prate)
{
    uint64_t tmp;
    uint32_t fract, integer;
    uint64_t temp;

    (void)clk_priv;

    if(rate > MAX_BBPLL_FREQ)
        return MAX_BBPLL_FREQ;

    if(rate < MIN_BBPLL_FREQ)
        return MIN_BBPLL_FREQ;

    temp = rate;
    tmp = utils_do_div(&temp, *prate);
    rate = temp;
    tmp = tmp * BBPLL_MODULUS + (*prate >> 1);
    utils_do_div(&tmp, *prate);

    integer = rate;
    fract = tmp;

    tmp = *prate * (uint64_t)fract;
    utils_do_div(&tmp, BBPLL_MODULUS);
    tmp += *prate * integer;

    return tmp;
}

/**
 * Set the clock rate.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param rate The clock rate.
 * @param parent_rate The parent clock rate.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_bbpll_set_rate(struct ad9361_clk_scale* clk_priv, uint32_t rate, uint32_t parent_rate)
{
    uint64_t tmp;
    uint32_t fract, integer;
    int32_t icp_val;
    uint8_t lf_defaults[3] = { 0x35, 0x5B, 0xE8 };
    uint64_t temp;

    DBGPRINTLN_CTX("Rate: %"PRIu32" Hz, Parent Rate: %"PRIu32" Hz", rate, parent_rate);

    /*
    * Setup Loop Filter and CP Current
    * Scale is 150uA @ (1280MHz BBPLL, 40MHz REFCLK)
    */
    tmp = (rate >> 7) * 150ULL;
    utils_do_div(&tmp, (parent_rate >> 7) * 32UL);

    /* 25uA/LSB, Offset 25uA */
    icp_val = DIV_ROUND((uint32_t)tmp, 25U) - 1;
    icp_val = CLAMP(icp_val, 1, 64);

    ad9361_spi_write(REG_CP_CURRENT, icp_val);
    ad9361_spi_writem(REG_LOOP_FILTER_3, lf_defaults, ARRAY_SIZE(lf_defaults));

    /* Allow calibration to occur and set cal count to 1024 for max accuracy */
    ad9361_spi_write(REG_VCO_CTRL, FREQ_CAL_ENABLE | FREQ_CAL_COUNT_LENGTH(3));
    /* Set calibration clock to REFCLK/4 for more accuracy */
    ad9361_spi_write(REG_SDM_CTRL, 0x10);

    /* Calculate and set BBPLL frequency word */
    temp = rate;
    tmp = utils_do_div(&temp, parent_rate);
    rate = temp;
    tmp = tmp * (uint64_t)BBPLL_MODULUS + (parent_rate >> 1);
    utils_do_div(&tmp, parent_rate);

    integer = rate;
    fract = tmp;

    ad9361_spi_write(REG_INTEGER_BB_FREQ_WORD, integer);
    ad9361_spi_write(REG_FRACT_BB_FREQ_WORD_3, fract);
    ad9361_spi_write(REG_FRACT_BB_FREQ_WORD_2, fract >> 8);
    ad9361_spi_write(REG_FRACT_BB_FREQ_WORD_1, fract >> 16);

    ad9361_spi_write(REG_SDM_CTRL_1, INIT_BB_FO_CAL | BBPLL_RESET_BAR); /* Start BBPLL Calibration */
    ad9361_spi_write(REG_SDM_CTRL_1, BBPLL_RESET_BAR); /* Clear BBPLL start calibration bit */

    ad9361_spi_write(REG_VCO_PROGRAM_1, 0x86); /* Increase BBPLL KV and phase margin */
    ad9361_spi_write(REG_VCO_PROGRAM_2, 0x01); /* Increase BBPLL KV and phase margin */
    ad9361_spi_write(REG_VCO_PROGRAM_2, 0x05); /* Increase BBPLL KV and phase margin */

    return ad9361_check_cal_done(REG_CH_1_OVERFLOW, BBPLL_LOCK, 1);
}

/*
 * RFPLL
 */

 /**
  * Calculate the RFPLL frequency.
  * @param parent_rate The parent clock rate.
  * @param integer The integer value.
  * @param fract The fractional value.
  * @param vco_div The VCO divider.
  * @return The RFPLL frequency.
  */
static uint64_t ad9361_calc_rfpll_int_freq(uint64_t parent_rate, uint64_t integer, uint64_t fract, uint32_t vco_div)
{
    uint64_t rate;

    rate = parent_rate * fract;
    utils_do_div(&rate, RFPLL_MODULUS);
    rate += parent_rate * integer;

    return rate >> (vco_div + 1);
}

/**
 * Calculate the RFPLL dividers.
 * @param phy The AD9361 state structure.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param freq The RFPLL frequency.
 * @param parent_rate The parent clock rate.
 * @param integer The integer value.
 * @param fract The fractional value.
 * @param vco_div The VCO divider.
 * @param vco_freq The VCO frequency.
 * @return The RFPLL frequency.
 */
static int32_t ad9361_calc_rfpll_int_divder(struct ad9361_clk_scale* clk_priv, uint64_t freq, uint64_t parent_rate, uint32_t* integer, uint32_t* fract, int32_t* vco_div, uint64_t* vco_freq)
{
    uint64_t tmp;
    int32_t div, ret;

    ret = ad9361_validate_rfpll(clk_priv->source == TX_RFPLL_INT, freq);

    if(ret)
        return ret;

    div = -1;

    while(freq <= MIN_VCO_FREQ_HZ)
    {
        freq <<= 1;
        div++;
    }

    *vco_div = div;
    *vco_freq = freq;
    tmp = utils_do_div(&freq, parent_rate);
    tmp = tmp * RFPLL_MODULUS + (parent_rate >> 1);
    utils_do_div(&tmp, parent_rate);
    *integer = freq;
    *fract = tmp;

    return 0;
}

/**
 * Recalculate the clock rate.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param parent_rate The parent clock rate.
 * @return The clock rate.
 */
uint32_t ad9361_rfpll_int_recalc_rate(struct ad9361_clk_scale* clk_priv, uint32_t parent_rate)
{
    uint32_t fract, integer;
    uint8_t buf[5];
    uint32_t reg, div_mask, vco_div, profile;

    // DBGPRINTLN_CTX("Parent Rate: %"PRIu32" Hz", parent_rate);

    switch(clk_priv->source)
    {
        case RX_RFPLL_INT:
            reg = REG_RX_FRACT_BYTE_2;
            div_mask = RX_VCO_DIVIDER(~0);
            profile = g_pAD9361Phy->fastlock.current_profile[0];
        break;
        case TX_RFPLL_INT:
            reg = REG_TX_FRACT_BYTE_2;
            div_mask = TX_VCO_DIVIDER(~0);
            profile = g_pAD9361Phy->fastlock.current_profile[1];
        break;
        default:
            return -EINVAL;
        break;
    }

    if(profile)
    {
        bool tx = clk_priv->source == TX_RFPLL_INT;
        profile = profile - 1;

        buf[0] = ad9361_fastlock_readval(tx, profile, 4);
        buf[1] = ad9361_fastlock_readval(tx, profile, 3);
        buf[2] = ad9361_fastlock_readval(tx, profile, 2);
        buf[3] = ad9361_fastlock_readval(tx, profile, 1);
        buf[4] = ad9361_fastlock_readval(tx, profile, 0);
        vco_div = ad9361_fastlock_readval(tx, profile, 12) & 0xF;

    }
    else
    {
        ad9361_spi_readm(reg, &buf[0], ARRAY_SIZE(buf));
        vco_div = ad9361_spi_readf(REG_RFPLL_DIVIDERS, div_mask);
    }

    fract = (SYNTH_FRACT_WORD(buf[0]) << 16) | (buf[1] << 8) | buf[2];
    integer = (SYNTH_INTEGER_WORD(buf[3]) << 8) | buf[4];

    return ad9361_to_clk(ad9361_calc_rfpll_int_freq(parent_rate, integer, fract, vco_div));
}

/**
 * Calculate the closest possible clock rate that can be set.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param rate The clock rate.
 * @param prate The parent clock rate.
 * @return The closest possible clock rate that can be set.
 */
int32_t ad9361_rfpll_int_round_rate(struct ad9361_clk_scale* clk_priv, uint32_t rate, uint32_t* prate)
{
    // DBGPRINTLN_CTX("Rate: %"PRIu32" Hz", rate);

    (void)prate;
    (void)clk_priv;

    if(ad9361_from_clk(rate) > MAX_CARRIER_FREQ_HZ || ad9361_from_clk(rate) < ((clk_priv->source == TX_RFPLL_INT) ? MIN_TX_CARRIER_FREQ_HZ : MIN_RX_CARRIER_FREQ_HZ))
        return -EINVAL;

    return rate;
}

/**
 * Set the clock rate.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param rate The clock rate.
 * @param parent_rate The parent clock rate.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_rfpll_int_set_rate(struct ad9361_clk_scale* clk_priv, uint32_t rate, uint32_t parent_rate)
{
    uint64_t vco = 0;
    uint8_t buf[5];
    uint32_t reg, div_mask, lock_reg, fract = 0, integer = 0;
    int32_t vco_div, ret, fixup_other;

    // DBGPRINTLN_CTX("%s Rate: %"PRIu32" Hz Parent Rate: %"PRIu32" Hz", clk_priv->source == TX_RFPLL_INT ? "TX" : "RX", rate, parent_rate);

    ad9361_fastlock_prepare(clk_priv->source == TX_RFPLL_INT, 0, false);

    ret = ad9361_calc_rfpll_int_divder(clk_priv, ad9361_from_clk(rate), parent_rate, &integer, &fract, &vco_div, &vco);

    if(ret < 0)
        return ret;

    switch(clk_priv->source)
    {
        case RX_RFPLL_INT:
            reg = REG_RX_FRACT_BYTE_2;
            lock_reg = REG_RX_CP_OVERRANGE_VCO_LOCK;
            div_mask = RX_VCO_DIVIDER(~0);
            g_pAD9361Phy->cached_rx_rfpll_div = vco_div;
            g_pAD9361Phy->current_rx_lo_freq = rate;
        break;
        case TX_RFPLL_INT:
            reg = REG_TX_FRACT_BYTE_2;
            lock_reg = REG_TX_CP_OVERRANGE_VCO_LOCK;
            div_mask = TX_VCO_DIVIDER(~0);
            g_pAD9361Phy->cached_tx_rfpll_div = vco_div;
            g_pAD9361Phy->current_tx_lo_freq = rate;
        break;
        default:
            return -EINVAL;
        break;
    }

    /* Option to skip VCO cal in TDD mode when moving from TX/RX to Alert */
    if(g_pAD9361Phy->pdata->tdd_skip_vco_cal)
        ad9361_trx_vco_cal_control(clk_priv->source == TX_RFPLL_INT, true);

    do
    {
        fixup_other = 0;

        ad9361_rfpll_vco_init(div_mask == TX_VCO_DIVIDER(~0), vco, parent_rate);

        buf[0] = SYNTH_FRACT_WORD(fract >> 16);
        buf[1] = fract >> 8;
        buf[2] = fract & 0xFF;
        buf[3] = SYNTH_INTEGER_WORD(integer >> 8) | (~SYNTH_INTEGER_WORD(~0) & ad9361_spi_read(reg - 3));
        buf[4] = integer & 0xFF;

        ad9361_spi_writem(reg, buf, 5);
        ad9361_spi_writef(REG_RFPLL_DIVIDERS, div_mask, vco_div);

        ret = ad9361_check_cal_done(lock_reg, VCO_LOCK, 1);

        /* In FDD mode with RX LO == TX LO frequency we use TDD tables to
         * reduce VCO pulling
         */

        if(((g_pAD9361Phy->pdata->fdd && !g_pAD9361Phy->pdata->fdd_independent_mode) && (g_pAD9361Phy->current_tx_lo_freq == g_pAD9361Phy->current_rx_lo_freq) && (g_pAD9361Phy->current_tx_use_tdd_table != g_pAD9361Phy->current_rx_use_tdd_table)) || ((g_pAD9361Phy->pdata->fdd && !g_pAD9361Phy->pdata->fdd_independent_mode) && (g_pAD9361Phy->current_tx_lo_freq != g_pAD9361Phy->current_rx_lo_freq) && (g_pAD9361Phy->current_tx_use_tdd_table || g_pAD9361Phy->current_rx_use_tdd_table)))
        {
            unsigned long _rate;

            switch(clk_priv->source)
            {
                case RX_RFPLL_INT:
                    reg = REG_TX_FRACT_BYTE_2;
                    lock_reg = REG_TX_CP_OVERRANGE_VCO_LOCK;
                    div_mask = TX_VCO_DIVIDER(~0);
                    _rate = g_pAD9361Phy->current_tx_lo_freq;
                break;
                case TX_RFPLL_INT:
                    reg = REG_RX_FRACT_BYTE_2;
                    lock_reg = REG_RX_CP_OVERRANGE_VCO_LOCK;
                    div_mask = RX_VCO_DIVIDER(~0);
                    _rate = g_pAD9361Phy->current_rx_lo_freq;
                break;
                default:
                    return -EINVAL;
                break;
            }

            if(g_pAD9361Phy->current_tx_lo_freq != g_pAD9361Phy->current_rx_lo_freq)
            {
                ad9361_calc_rfpll_int_divder(clk_priv, ad9361_from_clk(_rate), parent_rate, &integer, &fract, &vco_div, &vco);
                ad9361_fastlock_prepare(clk_priv->source == RX_RFPLL_INT, 0, false);
            }

            fixup_other = 1;
        }

    }
    while(fixup_other);

    if(g_pAD9361Phy->pdata->tdd_skip_vco_cal)
        ad9361_trx_vco_cal_control(clk_priv->source == TX_RFPLL_INT, false);

    return ret;
}

/**
 * Recalculate the clock rate.
 * @param clk_priv The ad9361_clk_scale structure.
 * @return The clock rate.
 */
uint32_t ad9361_rfpll_dummy_recalc_rate(struct ad9361_clk_scale* clk_priv)
{
    return g_pAD9361Phy->clks[clk_priv->source]->rate;
}

/**
 * Set the clock rate.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param rate The clock rate.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_rfpll_dummy_set_rate(struct ad9361_clk_scale* clk_priv, uint32_t rate)
{
    g_pAD9361Phy->clks[clk_priv->source]->rate = rate;

    return 0;
}

/**
 * Recalculate the clock rate.
 * @param clk_priv The ad9361_clk_scale structure.
 * @return The clock rate.
 */
uint32_t ad9361_rfpll_recalc_rate(struct ad9361_clk_scale* clk_priv)
{
    uint32_t rate;

    switch(clk_priv->source)
    {
        case RX_RFPLL:
            if(g_pAD9361Phy->pdata->use_ext_rx_lo)
                if(g_pAD9361Phy->ad9361_rfpll_ext_recalc_rate)
                    rate = g_pAD9361Phy->ad9361_rfpll_ext_recalc_rate(clk_priv);
                else
                    rate = ad9361_rfpll_dummy_recalc_rate(g_pAD9361Phy->ref_clk_scale[RX_RFPLL_DUMMY]);
            else
                rate = ad9361_rfpll_int_recalc_rate(g_pAD9361Phy->ref_clk_scale[RX_RFPLL_INT], g_pAD9361Phy->clks[RX_REFCLK]->rate);
        break;
        case TX_RFPLL:
            if(g_pAD9361Phy->pdata->use_ext_tx_lo)
                if(g_pAD9361Phy->ad9361_rfpll_ext_recalc_rate)
                    rate = g_pAD9361Phy->ad9361_rfpll_ext_recalc_rate(clk_priv);
                else
                    rate = ad9361_rfpll_dummy_recalc_rate(g_pAD9361Phy->ref_clk_scale[TX_RFPLL_DUMMY]);
            else
                rate = ad9361_rfpll_int_recalc_rate(g_pAD9361Phy->ref_clk_scale[TX_RFPLL_INT], g_pAD9361Phy->clks[TX_REFCLK]->rate);
        break;
        default:
            rate = 0;
        break;
    }

    return rate;
}

/**
 * Calculate the closest possible clock rate that can be set.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param rate The clock rate.
 * @return The closest possible clock rate that can be set.
 */
int32_t ad9361_rfpll_round_rate(struct ad9361_clk_scale* clk_priv, uint32_t rate)
{
    int32_t round_rate;

    switch(clk_priv->source)
    {
        case RX_RFPLL:
            if(g_pAD9361Phy->pdata->use_ext_rx_lo)
                if(g_pAD9361Phy->ad9361_rfpll_ext_round_rate)
                    round_rate = g_pAD9361Phy->ad9361_rfpll_ext_round_rate(clk_priv, rate);
                else
                    round_rate = rate;
            else
                round_rate = ad9361_rfpll_int_round_rate(g_pAD9361Phy->ref_clk_scale[RX_RFPLL_INT], rate, &g_pAD9361Phy->clks[g_pAD9361Phy->ref_clk_scale[RX_RFPLL_INT]->parent_source]->rate);
        break;
        case TX_RFPLL:
            if(g_pAD9361Phy->pdata->use_ext_tx_lo)
                if(g_pAD9361Phy->ad9361_rfpll_ext_round_rate)
                    round_rate = g_pAD9361Phy->ad9361_rfpll_ext_round_rate(clk_priv, rate);
                else
                    round_rate = rate;
            else
                round_rate = ad9361_rfpll_int_round_rate(g_pAD9361Phy->ref_clk_scale[TX_RFPLL_INT], rate, &g_pAD9361Phy->clks[g_pAD9361Phy->ref_clk_scale[TX_RFPLL_INT]->parent_source]->rate);
        break;
        default:
            round_rate = 0;
        break;
    }

    return round_rate;
}

/**
 * Set the clock rate.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param rate The clock rate.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_rfpll_set_rate(struct ad9361_clk_scale* clk_priv, uint32_t rate)
{
    int32_t ret;

    switch(clk_priv->source)
    {
        case RX_RFPLL:
            if(g_pAD9361Phy->pdata->use_ext_rx_lo)
                if(g_pAD9361Phy->ad9361_rfpll_ext_set_rate)
                    g_pAD9361Phy->ad9361_rfpll_ext_set_rate(clk_priv, rate);
                else
                    ad9361_rfpll_dummy_set_rate(g_pAD9361Phy->ref_clk_scale[RX_RFPLL_DUMMY], rate);
            else
                ad9361_rfpll_int_set_rate(g_pAD9361Phy->ref_clk_scale[RX_RFPLL_INT], rate, g_pAD9361Phy->clks[g_pAD9361Phy->ref_clk_scale[RX_RFPLL_INT]->parent_source]->rate);

            /* Load Gain Table */
            ret = ad9361_load_gt(ad9361_from_clk(rate), GT_RX1 + GT_RX2);

            if(ret < 0)
                return ret;
        break;
        case TX_RFPLL:
            if(g_pAD9361Phy->pdata->use_ext_tx_lo)
                if(g_pAD9361Phy->ad9361_rfpll_ext_set_rate)
                    g_pAD9361Phy->ad9361_rfpll_ext_set_rate(clk_priv, rate);
                else
                    ad9361_rfpll_dummy_set_rate(g_pAD9361Phy->ref_clk_scale[TX_RFPLL_DUMMY], rate);
            else
                ad9361_rfpll_int_set_rate(g_pAD9361Phy->ref_clk_scale[TX_RFPLL_INT], rate, g_pAD9361Phy->clks[g_pAD9361Phy->ref_clk_scale[TX_RFPLL_INT]->parent_source]->rate);

            /* For RX LO we typically have the tracking option enabled
            * so for now do nothing here.
            */
            if(g_pAD9361Phy->auto_cal_en && !g_pAD9361Phy->pdata->use_ext_tx_lo)
            {
                if((D_ABS(g_pAD9361Phy->last_tx_quad_cal_freq, ad9361_from_clk(rate))) > g_pAD9361Phy->cal_threshold_freq)
                {
                    ret = ad9361_do_calib_run(TX_QUAD_CAL, -1);

                    if(ret < 0)
                        DBGPRINTLN_CTX("TX QUAD cal failed");

                    g_pAD9361Phy->last_tx_quad_cal_freq = ad9361_from_clk(rate);
                }
            }
        break;
        default:
        break;
    }

    return 0;
}

/**
 * Set clock mux parent.
 * @param clk_priv The ad9361_clk_scale structure.
 * @param index Index - Enable (1), disable (0) ext lo.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_clk_mux_set_parent(struct ad9361_clk_scale* clk_priv, uint8_t index)
{
    int32_t ret;

    DBGPRINTLN_CTX("index %d", index);

    ad9361_ensm_force_state(ENSM_STATE_ALERT);

    ret = ad9361_trx_ext_lo_control(clk_priv->source == TX_RFPLL, index == 1);

    if(ret >= 0)
        clk_priv->mult = index;

    ad9361_ensm_restore_prev_state();

    return ret;
}

/**
 * Register and initialize a new clock.
 * @param phy The AD9361 state structure.
 * @param name The name of the new clock.
 * @param parent_name The name of the parent clock.
 * @param flags The flags.
 * @param source The source of the new clock.
 * @param parent_source The source of the parent clock.
 * @return A struct ad9361_clk for the new clock or a negative error code.
 */
static struct ad9361_clk* ad9361_clk_register(const char* name, const char* parent_name, uint32_t source, uint32_t parent_source)
{
    struct ad9361_clk_scale* clk_priv;
    struct ad9361_clk* clk;

    DBGPRINTLN_CTX("name: %s, parent_name: %s, source: %"PRIu32", parent_source: %"PRIu32"", name, parent_name, source, parent_source);

    (void)name;
    (void)parent_name;

    clk_priv = (struct ad9361_clk_scale*)malloc(sizeof(*clk_priv));

    if(!clk_priv)
    {
        DBGPRINTLN_CTX("Could not allocate fixed factor clk");

        return (struct ad9361_clk*)-ENOMEM;
    }

    /* struct ad9361_clk_scale assignments */
    clk_priv->source = (enum ad9361_clocks)source;
    clk_priv->parent_source = (enum ad9361_clocks)parent_source;

    g_pAD9361Phy->ref_clk_scale[source] = clk_priv;

    clk = (struct ad9361_clk*)malloc(sizeof(*clk));

    if(!clk)
    {
        free(clk_priv);

        return (struct ad9361_clk*)-ENOMEM;
    }

    switch(source)
    {
        case TX_REFCLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clk_refin->rate);
        break;
        case RX_REFCLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clk_refin->rate);
        break;
        case BB_REFCLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clk_refin->rate);
        break;
        case BBPLL_CLK:
            clk->rate = ad9361_bbpll_recalc_rate(clk_priv, g_pAD9361Phy->clks[BB_REFCLK]->rate);
        break;
        case ADC_CLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clks[BBPLL_CLK]->rate);
        break;
        case R2_CLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clks[ADC_CLK]->rate);
        break;
        case R1_CLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clks[R2_CLK]->rate);
        break;
        case CLKRF_CLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clks[R1_CLK]->rate);
        break;
        case RX_SAMPL_CLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clks[CLKRF_CLK]->rate);
        break;
        case DAC_CLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clks[ADC_CLK]->rate);
        break;
        case T2_CLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clks[DAC_CLK]->rate);
        break;
        case T1_CLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clks[T2_CLK]->rate);
        break;
        case CLKTF_CLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clks[T1_CLK]->rate);
        break;
        case TX_SAMPL_CLK:
            clk->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clks[CLKTF_CLK]->rate);
        break;
        case RX_RFPLL_INT:
            clk->rate = ad9361_rfpll_int_recalc_rate(clk_priv, g_pAD9361Phy->clks[RX_REFCLK]->rate);
        break;
        case TX_RFPLL_INT:
            clk->rate = ad9361_rfpll_int_recalc_rate(clk_priv, g_pAD9361Phy->clks[TX_REFCLK]->rate);
        break;
        case RX_RFPLL_DUMMY:
            clk->rate = g_pAD9361Phy->pdata->rx_synth_freq;
        break;
        case TX_RFPLL_DUMMY:
            clk->rate = g_pAD9361Phy->pdata->tx_synth_freq;
        break;
        case RX_RFPLL:
            clk->rate = ad9361_rfpll_recalc_rate(clk_priv);
        break;
        case TX_RFPLL:
            clk->rate = ad9361_rfpll_recalc_rate(clk_priv);
        break;
        default:
            DBGPRINTLN_CTX("Invalid clock source: %"PRIu32"", source);
        break;
    }

    return clk;
}

uint32_t ad9361_clk_get_rate(struct ad9361_clk_scale* clk_priv)
{
    uint32_t rate = 0;
    uint32_t source;

    source = clk_priv->source;

    switch(source)
    {
        case TX_REFCLK:
        case RX_REFCLK:
        case BB_REFCLK:
            rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clk_refin->rate);
        break;
        case TX_RFPLL_INT:
        case RX_RFPLL_INT:
            rate = ad9361_rfpll_int_recalc_rate(clk_priv, g_pAD9361Phy->clks[clk_priv->parent_source]->rate);
        break;
        case RX_RFPLL_DUMMY:
        case TX_RFPLL_DUMMY:
            rate = ad9361_rfpll_dummy_recalc_rate(clk_priv);
        break;
        case TX_RFPLL:
        case RX_RFPLL:
            rate = ad9361_rfpll_recalc_rate(clk_priv);
        break;
        case BBPLL_CLK:
            rate = ad9361_bbpll_recalc_rate(clk_priv, g_pAD9361Phy->clks[clk_priv->parent_source]->rate);
        break;
        case ADC_CLK:
        case R2_CLK:
        case R1_CLK:
        case CLKRF_CLK:
        case RX_SAMPL_CLK:
        case DAC_CLK:
        case T2_CLK:
        case T1_CLK:
        case CLKTF_CLK:
        case TX_SAMPL_CLK:
            rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clks[clk_priv->parent_source]->rate);
        break;
    }

    return rate;
}

int32_t ad9361_clk_set_rate(struct ad9361_clk_scale* clk_priv, uint32_t rate)
{
    uint32_t source;
    uint32_t round_rate;

    source = clk_priv->source;

    if(g_pAD9361Phy->clks[source]->rate != rate)
    {
        switch(source)
        {
            case TX_REFCLK:
            case RX_REFCLK:
            case BB_REFCLK:
                round_rate = ad9361_clk_factor_round_rate(clk_priv, rate, &g_pAD9361Phy->clk_refin->rate);

                ad9361_clk_factor_set_rate(clk_priv, round_rate, g_pAD9361Phy->clk_refin->rate);

                g_pAD9361Phy->clks[source]->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clk_refin->rate);
            break;
            case TX_RFPLL_INT:
            case RX_RFPLL_INT:
                round_rate = ad9361_rfpll_int_round_rate(clk_priv, rate, &g_pAD9361Phy->clks[clk_priv->parent_source]->rate);

                ad9361_rfpll_int_set_rate(clk_priv, round_rate, g_pAD9361Phy->clks[clk_priv->parent_source]->rate);

                g_pAD9361Phy->clks[source]->rate = ad9361_rfpll_int_recalc_rate(clk_priv, g_pAD9361Phy->clks[clk_priv->parent_source]->rate);
            break;
            case RX_RFPLL_DUMMY:
            case TX_RFPLL_DUMMY:
                ad9361_rfpll_dummy_set_rate(clk_priv, rate);
            break;
            case TX_RFPLL:
            case RX_RFPLL:
                round_rate = ad9361_rfpll_round_rate(clk_priv, rate);

                ad9361_rfpll_set_rate(clk_priv, round_rate);

                g_pAD9361Phy->clks[source]->rate = ad9361_rfpll_recalc_rate(clk_priv);
            break;
            case BBPLL_CLK:
                round_rate = ad9361_bbpll_round_rate(clk_priv, rate,&g_pAD9361Phy->clks[clk_priv->parent_source]->rate);

                ad9361_bbpll_set_rate(clk_priv, round_rate, g_pAD9361Phy->clks[clk_priv->parent_source]->rate);

                g_pAD9361Phy->clks[source]->rate = ad9361_bbpll_recalc_rate(clk_priv, g_pAD9361Phy->clks[clk_priv->parent_source]->rate);

                g_pAD9361Phy->bbpll_initialized = true;
            break;
            case ADC_CLK:
            case R2_CLK:
            case R1_CLK:
            case CLKRF_CLK:
            case RX_SAMPL_CLK:
            case DAC_CLK:
            case T2_CLK:
            case T1_CLK:
            case CLKTF_CLK:
            case TX_SAMPL_CLK:
                round_rate = ad9361_clk_factor_round_rate(clk_priv, rate, &g_pAD9361Phy->clks[clk_priv->parent_source]->rate);

                ad9361_clk_factor_set_rate(clk_priv, round_rate, g_pAD9361Phy->clks[clk_priv->parent_source]->rate);

                g_pAD9361Phy->clks[source]->rate = ad9361_clk_factor_recalc_rate(clk_priv, g_pAD9361Phy->clks[clk_priv->parent_source]->rate);
            break;
        }

        for(enum ad9361_clocks i = BB_REFCLK; i < BBPLL_CLK; i++)
            g_pAD9361Phy->clks[i]->rate = ad9361_clk_factor_recalc_rate(g_pAD9361Phy->ref_clk_scale[i], g_pAD9361Phy->clk_refin->rate);

        g_pAD9361Phy->clks[BBPLL_CLK]->rate = ad9361_bbpll_recalc_rate(g_pAD9361Phy->ref_clk_scale[BBPLL_CLK], g_pAD9361Phy->clks[g_pAD9361Phy->ref_clk_scale[BBPLL_CLK]->parent_source]->rate);

        for(enum ad9361_clocks i = ADC_CLK; i < RX_RFPLL_INT; i++)
            g_pAD9361Phy->clks[i]->rate = ad9361_clk_factor_recalc_rate(g_pAD9361Phy->ref_clk_scale[i], g_pAD9361Phy->clks[g_pAD9361Phy->ref_clk_scale[i]->parent_source]->rate);

        for(enum ad9361_clocks i = RX_RFPLL_INT; i < RX_RFPLL_DUMMY; i++)
            g_pAD9361Phy->clks[i]->rate = ad9361_rfpll_int_recalc_rate(g_pAD9361Phy->ref_clk_scale[i], g_pAD9361Phy->clks[g_pAD9361Phy->ref_clk_scale[i]->parent_source]->rate);

        for(enum ad9361_clocks i = RX_RFPLL_DUMMY; i < RX_RFPLL; i++)
            g_pAD9361Phy->clks[i]->rate = ad9361_rfpll_dummy_recalc_rate(g_pAD9361Phy->ref_clk_scale[i]);

        for(enum ad9361_clocks i = RX_RFPLL; i < NUM_AD9361_CLKS; i++)
            g_pAD9361Phy->clks[i]->rate = ad9361_rfpll_recalc_rate(g_pAD9361Phy->ref_clk_scale[i]);
    }
    else
    {
        if((source == BBPLL_CLK) && !g_pAD9361Phy->bbpll_initialized)
        {
            round_rate = ad9361_bbpll_round_rate(clk_priv, rate, &g_pAD9361Phy->clks[clk_priv->parent_source]->rate);

            ad9361_bbpll_set_rate(clk_priv, round_rate, g_pAD9361Phy->clks[clk_priv->parent_source]->rate);

            g_pAD9361Phy->clks[source]->rate = ad9361_bbpll_recalc_rate(clk_priv, g_pAD9361Phy->clks[clk_priv->parent_source]->rate);

            g_pAD9361Phy->bbpll_initialized = true;
        }
    }

    return 0;
}

/**
 * Register and initialize all the system clocks.
 * @param phy The AD9361 state structure.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_register_clocks()
{
    /* Scaled Reference Clocks */
    g_pAD9361Phy->clks[TX_REFCLK] = ad9361_clk_register("tx_refclk", "ad9361_ext_refclk", TX_REFCLK, EXT_REF_CLK);
    g_pAD9361Phy->clks[RX_REFCLK] = ad9361_clk_register("rx_refclk", "ad9361_ext_refclk", RX_REFCLK, EXT_REF_CLK);
    g_pAD9361Phy->clks[BB_REFCLK] = ad9361_clk_register("bb_refclk", "ad9361_ext_refclk", BB_REFCLK, EXT_REF_CLK);

    /* Base Band PLL Clock */
    g_pAD9361Phy->clks[BBPLL_CLK] = ad9361_clk_register("bbpll_clk", "bb_refclk", BBPLL_CLK, BB_REFCLK);

    g_pAD9361Phy->clks[ADC_CLK] = ad9361_clk_register("adc_clk", "bbpll_clk", ADC_CLK, BBPLL_CLK);
    g_pAD9361Phy->clks[R2_CLK] = ad9361_clk_register("r2_clk", "adc_clk", R2_CLK, ADC_CLK);
    g_pAD9361Phy->clks[R1_CLK] = ad9361_clk_register("r1_clk", "r2_clk", R1_CLK, R2_CLK);
    g_pAD9361Phy->clks[CLKRF_CLK] = ad9361_clk_register("clkrf_clk", "r1_clk", CLKRF_CLK, R1_CLK);
    g_pAD9361Phy->clks[RX_SAMPL_CLK] = ad9361_clk_register("rx_sampl_clk", "clkrf_clk", RX_SAMPL_CLK, CLKRF_CLK);

    g_pAD9361Phy->clks[DAC_CLK] = ad9361_clk_register("dac_clk", "adc_clk", DAC_CLK, ADC_CLK);
    g_pAD9361Phy->clks[T2_CLK] = ad9361_clk_register("t2_clk", "dac_clk", T2_CLK, DAC_CLK);
    g_pAD9361Phy->clks[T1_CLK] = ad9361_clk_register("t1_clk", "t2_clk", T1_CLK, T2_CLK);
    g_pAD9361Phy->clks[CLKTF_CLK] = ad9361_clk_register("clktf_clk", "t1_clk", CLKTF_CLK, T1_CLK);
    g_pAD9361Phy->clks[TX_SAMPL_CLK] = ad9361_clk_register("tx_sampl_clk", "clktf_clk", TX_SAMPL_CLK, CLKTF_CLK);

    g_pAD9361Phy->clks[RX_RFPLL_INT] = ad9361_clk_register("rx_rfpll", "rx_refclk", RX_RFPLL_INT, RX_REFCLK);
    g_pAD9361Phy->clks[TX_RFPLL_INT] = ad9361_clk_register("tx_rfpll", "tx_refclk", TX_RFPLL_INT, TX_REFCLK);
    g_pAD9361Phy->clks[RX_RFPLL_DUMMY] = ad9361_clk_register("rx_rfpll_dummy", NULL, RX_RFPLL_DUMMY, 0);
    g_pAD9361Phy->clks[TX_RFPLL_DUMMY] = ad9361_clk_register("tx_rfpll_dummy", NULL, TX_RFPLL_DUMMY, 0);
    g_pAD9361Phy->clks[RX_RFPLL] = ad9361_clk_register("rx_rfpll", NULL, RX_RFPLL, 0);
    g_pAD9361Phy->clks[TX_RFPLL] = ad9361_clk_register("tx_rfpll", NULL, TX_RFPLL, 0);

    return 0;
}

/**
 * Unregister all the system clocks.
 * @param phy The AD9361 state structure.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_unregister_clocks()
{
    for(uint8_t i = 0; i < NUM_AD9361_CLKS; i++)
    {
        free(g_pAD9361Phy->clks[i]);
        free(g_pAD9361Phy->ref_clk_scale[i]);
    }

    return 0;
}

/**
 * Perform an RSSI gain step calibration.
 * Note: Before running the function, provide a single tone within the channel
 *    bandwidth and monitor the received data. Adjust the tone amplitude until
 *    the received data is within a few dB of full scale but not overloading.
 * @param phy The AD9361 state structure.
 * @return 0 in case of success, negative error code otherwise.
 */
int32_t ad9361_rssi_gain_step_calib()
{
    uint32_t lna_error[4];
    uint32_t mixer_error[15];
    uint64_t lo_freq_hz;
    uint8_t lo_index;

    lo_freq_hz = ad9361_from_clk(ad9361_clk_get_rate(g_pAD9361Phy->ref_clk_scale[RX_RFPLL]));

    if(lo_freq_hz < 1300000000ULL)
        lo_index = 0;
    else if(lo_freq_hz < 3300000000ULL)
        lo_index = 1;
    else if(lo_freq_hz < 4100000000ULL)
        lo_index = 2;
    else
        lo_index = 3;

    /* Put the AD9361 into the Alert state. */
    ad9361_ensm_force_state(ENSM_STATE_ALERT);

    /* Program the directly-addressable register values. */
    ad9361_spi_write(REG_MAX_MIXER_CALIBRATION_GAIN_INDEX, MAX_MIXER_CALIBRATION_GAIN_INDEX(0x0F));
    ad9361_spi_write(REG_MEASURE_DURATION, GAIN_CAL_MEAS_DURATION(0x0E));
    ad9361_spi_write(REG_SETTLE_TIME, SETTLE_TIME(0x3F));
    ad9361_spi_write(REG_RSSI_CONFIG, RSSI_MODE_SELECT(0x3) | DEFAULT_RSSI_MEAS_MODE);
    ad9361_spi_write(REG_MEASURE_DURATION_01, MEASUREMENT_DURATION_0(0x0E));
    ad9361_spi_write(REG_LNA_GAIN, gain_step_calib_reg_val[lo_index][0]);

    /* Program the LNA gain step words into the internal table. */
    ad9361_spi_write(REG_CONFIG, CALIB_TABLE_SELECT(0x3) | START_CALIB_TABLE_CLOCK);

    for(uint8_t i = 0; i < 4; i++)
    {
        ad9361_spi_write(REG_WORD_ADDRESS, i);
        ad9361_spi_write(REG_GAIN_DIFF_WORDERROR_WRITE, gain_step_calib_reg_val[lo_index][i + 1]);
        ad9361_spi_write(REG_CONFIG, CALIB_TABLE_SELECT(0x3) | WRITE_LNA_GAIN_DIFF | START_CALIB_TABLE_CLOCK);

        usleep(3);    //Wait for data to fully write to internal table
    }

    ad9361_spi_write(REG_CONFIG, START_CALIB_TABLE_CLOCK);
    ad9361_spi_write(REG_CONFIG, 0x00);

    /* Run and wait until the calibration completes. */
    ad9361_run_calibration(RX_GAIN_STEP_CAL);

    /* Read the LNA and Mixer error terms into nonvolatile memory. */
    ad9361_spi_write(REG_CONFIG, CALIB_TABLE_SELECT(0x1) | READ_SELECT);

    for(uint8_t i = 0; i < 4; i++)
    {
        ad9361_spi_write(REG_WORD_ADDRESS, i);

        lna_error[i] = ad9361_spi_read(REG_GAIN_ERROR_READ);
    }

    ad9361_spi_write(REG_CONFIG, CALIB_TABLE_SELECT(0x1));

    for(uint8_t i = 0; i < 15; i++)
    {
        ad9361_spi_write(REG_WORD_ADDRESS, i);
        mixer_error[i] = ad9361_spi_read(REG_GAIN_ERROR_READ);
    }

    ad9361_spi_write(REG_CONFIG, 0x00);

    /* Programming gain step errors into the AD9361 in the field */
    ad9361_spi_write(REG_CONFIG, CALIB_TABLE_SELECT(0x3) | START_CALIB_TABLE_CLOCK);

    for(uint8_t i = 0; i < 4; i++)
    {
        ad9361_spi_write(REG_WORD_ADDRESS, i);
        ad9361_spi_write(REG_GAIN_DIFF_WORDERROR_WRITE, lna_error[i]);
        ad9361_spi_write(REG_CONFIG, CALIB_TABLE_SELECT(0x3) | WRITE_LNA_ERROR_TABLE | START_CALIB_TABLE_CLOCK);
    }

    ad9361_spi_write(REG_CONFIG, CALIB_TABLE_SELECT(0x3) | START_CALIB_TABLE_CLOCK);

    for(uint8_t i = 0; i < 15; i++)
    {
        ad9361_spi_write(REG_WORD_ADDRESS, i);
        ad9361_spi_write(REG_GAIN_DIFF_WORDERROR_WRITE, mixer_error[i]);
        ad9361_spi_write(REG_CONFIG, CALIB_TABLE_SELECT(0x3) | WRITE_MIXER_ERROR_TABLE | START_CALIB_TABLE_CLOCK);
    }

    ad9361_spi_write(REG_CONFIG, 0x00);

    ad9361_ensm_restore_prev_state();

    return 0;
}
